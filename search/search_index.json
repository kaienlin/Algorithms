{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Algorithms \u00b6 My own implementation of some algorithms 1 2 3 4 5 6 7 #include <iostream> int main () { std :: cout << \"hello, world\" << std :: endl ; return EXIT_SUCCESS ; } Categories \u00b6 Data Structures Graph String Miscellaneous Tags \u00b6 Dynamic Programming Divide & Conquer Greedy NP-Complete","title":"Home"},{"location":"#algorithms","text":"My own implementation of some algorithms 1 2 3 4 5 6 7 #include <iostream> int main () { std :: cout << \"hello, world\" << std :: endl ; return EXIT_SUCCESS ; }","title":"Algorithms"},{"location":"#categories","text":"Data Structures Graph String Miscellaneous","title":"Categories"},{"location":"#tags","text":"Dynamic Programming Divide & Conquer Greedy NP-Complete","title":"Tags"},{"location":"about/","text":"Author \u00b6 I am not good at algorithms, but I am trying my best.","title":"About"},{"location":"about/#author","text":"I am not good at algorithms, but I am trying my best.","title":"Author"},{"location":"data-structures/","text":"Data Structures \u00b6 Segment Tree","title":"Data Structrues"},{"location":"data-structures/#data-structures","text":"Segment Tree","title":"Data Structures"},{"location":"data-structures/segment-tree/","text":"Implementation \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 struct SegTree { constexpr static int MAXN = 1e5 + 5 ; int N ; int A [ MAXN ]; int T [ 4 * MAXN ], tag [ 4 * MAXN ]; void init ( int _N ) { N = _N ; } int lch ( int v ) { return v << 1 ; } int rch ( int v ) { return ( v << 1 ) | 1 ; } int combine ( int a , int b ) { return a + b ; } void pull ( int v ) { T [ v ] = combine ( T [ lch ( v )], T [ rch ( v )]); } void push ( int v , int l , int r ) { if ( tag [ v ] ) { int m = ( l + r ) >> 1 , lc = lch ( v ), rc = rch ( v ); T [ lc ] += ( m - l + 1 ) * tag [ v ]; T [ rc ] += ( r - m ) * tag [ v ]; tag [ lc ] += tag [ v ]; tag [ rc ] += tag [ v ]; tag [ v ] = 0 ; } } void build ( int v , int tl , int tr ) { if ( tl == tr ) { T [ v ] = A [ tl ]; } else { int tm = ( tl + tr ) >> 1 ; build ( lch ( v ), tl , tm ); build ( rch ( v ), tm + 1 , tr ); pull ( v ); } } int qry ( int v , int tl , int tr , int l , int r ) { if ( l > tr || r < tl ) return 0 ; if ( l <= tl && r >= tr ) return T [ v ]; int tm = ( tl + tr ) >> 1 ; push ( v , tl , tr ); return combine ( qry ( lch ( v ), tl , tm , l , r ), qry ( rch ( v ), tm + 1 , tr , l , r )); } void upd ( int v , int tl , int tr , int l , int r , int add ) { if ( l > tr || r < tl ) return ; if ( l <= tl && r >= tr ) { tag [ v ] += add ; T [ v ] += add * ( r - l + 1 ); return ; } int tm = ( tl + tr ) >> 1 ; push ( v , tl , tr ); upd ( lch ( v ), tl , tm , l , r , add ); upd ( rch ( v ), tm + 1 , tr , l , r , add ); pull ( v ); } } seg ;","title":"Segment tree"},{"location":"data-structures/segment-tree/#implementation","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 struct SegTree { constexpr static int MAXN = 1e5 + 5 ; int N ; int A [ MAXN ]; int T [ 4 * MAXN ], tag [ 4 * MAXN ]; void init ( int _N ) { N = _N ; } int lch ( int v ) { return v << 1 ; } int rch ( int v ) { return ( v << 1 ) | 1 ; } int combine ( int a , int b ) { return a + b ; } void pull ( int v ) { T [ v ] = combine ( T [ lch ( v )], T [ rch ( v )]); } void push ( int v , int l , int r ) { if ( tag [ v ] ) { int m = ( l + r ) >> 1 , lc = lch ( v ), rc = rch ( v ); T [ lc ] += ( m - l + 1 ) * tag [ v ]; T [ rc ] += ( r - m ) * tag [ v ]; tag [ lc ] += tag [ v ]; tag [ rc ] += tag [ v ]; tag [ v ] = 0 ; } } void build ( int v , int tl , int tr ) { if ( tl == tr ) { T [ v ] = A [ tl ]; } else { int tm = ( tl + tr ) >> 1 ; build ( lch ( v ), tl , tm ); build ( rch ( v ), tm + 1 , tr ); pull ( v ); } } int qry ( int v , int tl , int tr , int l , int r ) { if ( l > tr || r < tl ) return 0 ; if ( l <= tl && r >= tr ) return T [ v ]; int tm = ( tl + tr ) >> 1 ; push ( v , tl , tr ); return combine ( qry ( lch ( v ), tl , tm , l , r ), qry ( rch ( v ), tm + 1 , tr , l , r )); } void upd ( int v , int tl , int tr , int l , int r , int add ) { if ( l > tr || r < tl ) return ; if ( l <= tl && r >= tr ) { tag [ v ] += add ; T [ v ] += add * ( r - l + 1 ); return ; } int tm = ( tl + tr ) >> 1 ; push ( v , tl , tr ); upd ( lch ( v ), tl , tm , l , r , add ); upd ( rch ( v ), tm + 1 , tr , l , r , add ); pull ( v ); } } seg ;","title":"Implementation"},{"location":"graph/","text":"Graph \u00b6 Depth First Search","title":"Graph"},{"location":"graph/#graph","text":"Depth First Search","title":"Graph"},{"location":"graph/dfs/","text":"Depth First Search \u00b6 Basic DFS \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 constexpr int MAXN = 1e3 + 5 ; int N ; vector < int > G [ MAXN ]; int color [ MAXN ], tin [ MAXN ], tout [ MAXN ], timer ; const int WHITE = 0 , GREY = 1 , BLACK = 2 ; void is_back_edge ( int from , int to ) {} void is_cross_edge ( int from , int to ) {} bool is_ancestor ( int anc , int des ) { return tin [ anc ] < tin [ des ] && tout [ anc ] > tout [ des ]; } void dfs_util ( int v ) { color [ v ] = GREY ; tin [ v ] = timer ++ ; for ( int u : G [ v ] ) { if ( color [ u ] == WHITE ) dfs_util ( u ); else if ( color [ u ] == GREY ) is_back_edge ( v , u ); else if ( color [ u ] == BLACK ) is_cross_edge ( v , u ); } color [ v ] = BLACK ; tout [ v ] = timer ++ ; } void dfs () { fill ( color , color + N , WHITE ); timer = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( color [ i ] == WHITE ) dfs_util ( i ); } Topological Sort \u00b6 Find bridge \u00b6","title":"Depth First Search"},{"location":"graph/dfs/#depth-first-search","text":"","title":"Depth First Search"},{"location":"graph/dfs/#basic-dfs","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 constexpr int MAXN = 1e3 + 5 ; int N ; vector < int > G [ MAXN ]; int color [ MAXN ], tin [ MAXN ], tout [ MAXN ], timer ; const int WHITE = 0 , GREY = 1 , BLACK = 2 ; void is_back_edge ( int from , int to ) {} void is_cross_edge ( int from , int to ) {} bool is_ancestor ( int anc , int des ) { return tin [ anc ] < tin [ des ] && tout [ anc ] > tout [ des ]; } void dfs_util ( int v ) { color [ v ] = GREY ; tin [ v ] = timer ++ ; for ( int u : G [ v ] ) { if ( color [ u ] == WHITE ) dfs_util ( u ); else if ( color [ u ] == GREY ) is_back_edge ( v , u ); else if ( color [ u ] == BLACK ) is_cross_edge ( v , u ); } color [ v ] = BLACK ; tout [ v ] = timer ++ ; } void dfs () { fill ( color , color + N , WHITE ); timer = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( color [ i ] == WHITE ) dfs_util ( i ); }","title":"Basic DFS"},{"location":"graph/dfs/#topological-sort","text":"","title":"Topological Sort"},{"location":"graph/dfs/#find-bridge","text":"","title":"Find bridge"},{"location":"misc/","text":"Miscellaneous \u00b6","title":"Miscellaneous"},{"location":"misc/#miscellaneous","text":"","title":"Miscellaneous"},{"location":"string/","text":"String \u00b6","title":"String"},{"location":"string/#string","text":"","title":"String"}]}