{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Computer Science Note \u00b6 The documentation in this site is for: organize my knowledge better create a better view of what I have learned Courses \u00b6 This area mostly contains homework assignments, sometimes with some class notes. Algorithms \u00b6 My own implementation of some algorithms, mainly in C++. Miscellaneous \u00b6 Things that are hard to categorized, like Latex, Linux....","title":"Home"},{"location":"#computer-science-note","text":"The documentation in this site is for: organize my knowledge better create a better view of what I have learned","title":"Computer Science Note"},{"location":"#courses","text":"This area mostly contains homework assignments, sometimes with some class notes.","title":"Courses"},{"location":"#algorithms","text":"My own implementation of some algorithms, mainly in C++.","title":"Algorithms"},{"location":"#miscellaneous","text":"Things that are hard to categorized, like Latex, Linux....","title":"Miscellaneous"},{"location":"about/","text":"Author \u00b6 Department of Computer Science and Information Engineering in National Taiwan University That's all(?)","title":"About"},{"location":"about/#author","text":"Department of Computer Science and Information Engineering in National Taiwan University That's all(?)","title":"Author"},{"location":"algorithms/","text":"Algorithms \u00b6 Data Structures \u00b6 Segment Tree Graph \u00b6 Depth First Search","title":"Algorithms"},{"location":"algorithms/#algorithms","text":"","title":"Algorithms"},{"location":"algorithms/#data-structures","text":"Segment Tree","title":"Data Structures"},{"location":"algorithms/#graph","text":"Depth First Search","title":"Graph"},{"location":"algorithms/dfs/","text":"Depth First Search \u00b6 Basic DFS \u00b6 constexpr int MAXN = 1e3 + 5 ; int N ; vector < int > G [ MAXN ]; int color [ MAXN ], tin [ MAXN ], tout [ MAXN ], timer ; const int WHITE = 0 , GREY = 1 , BLACK = 2 ; void is_back_edge ( int from , int to ) {} void is_cross_edge ( int from , int to ) {} bool is_ancestor ( int anc , int des ) { return tin [ anc ] < tin [ des ] && tout [ anc ] > tout [ des ]; } void dfs_util ( int v ) { color [ v ] = GREY ; tin [ v ] = timer ++ ; for ( int u : G [ v ] ) { if ( color [ u ] == WHITE ) dfs_util ( u ); else if ( color [ u ] == GREY ) is_back_edge ( v , u ); else if ( color [ u ] == BLACK ) is_cross_edge ( v , u ); } color [ v ] = BLACK ; tout [ v ] = timer ++ ; } void dfs () { fill ( color , color + N , WHITE ); timer = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( color [ i ] == WHITE ) dfs_util ( i ); } Topological Sort \u00b6 Find bridge \u00b6","title":"Depth First Search"},{"location":"algorithms/dfs/#depth-first-search","text":"","title":"Depth First Search"},{"location":"algorithms/dfs/#basic-dfs","text":"constexpr int MAXN = 1e3 + 5 ; int N ; vector < int > G [ MAXN ]; int color [ MAXN ], tin [ MAXN ], tout [ MAXN ], timer ; const int WHITE = 0 , GREY = 1 , BLACK = 2 ; void is_back_edge ( int from , int to ) {} void is_cross_edge ( int from , int to ) {} bool is_ancestor ( int anc , int des ) { return tin [ anc ] < tin [ des ] && tout [ anc ] > tout [ des ]; } void dfs_util ( int v ) { color [ v ] = GREY ; tin [ v ] = timer ++ ; for ( int u : G [ v ] ) { if ( color [ u ] == WHITE ) dfs_util ( u ); else if ( color [ u ] == GREY ) is_back_edge ( v , u ); else if ( color [ u ] == BLACK ) is_cross_edge ( v , u ); } color [ v ] = BLACK ; tout [ v ] = timer ++ ; } void dfs () { fill ( color , color + N , WHITE ); timer = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( color [ i ] == WHITE ) dfs_util ( i ); }","title":"Basic DFS"},{"location":"algorithms/dfs/#topological-sort","text":"","title":"Topological Sort"},{"location":"algorithms/dfs/#find-bridge","text":"","title":"Find bridge"},{"location":"algorithms/segment-tree/","text":"Implementation \u00b6 struct SegTree { constexpr static int MAXN = 1e5 + 5 ; int N ; int A [ MAXN ]; int T [ 4 * MAXN ], tag [ 4 * MAXN ]; void init ( int _N ) { N = _N ; } int lch ( int v ) { return v << 1 ; } int rch ( int v ) { return ( v << 1 ) | 1 ; } int combine ( int a , int b ) { return a + b ; } void pull ( int v ) { T [ v ] = combine ( T [ lch ( v )], T [ rch ( v )]); } void push ( int v , int l , int r ) { if ( tag [ v ] ) { int m = ( l + r ) >> 1 , lc = lch ( v ), rc = rch ( v ); T [ lc ] += ( m - l + 1 ) * tag [ v ]; T [ rc ] += ( r - m ) * tag [ v ]; tag [ lc ] += tag [ v ]; tag [ rc ] += tag [ v ]; tag [ v ] = 0 ; } } void build ( int v , int tl , int tr ) { if ( tl == tr ) { T [ v ] = A [ tl ]; } else { int tm = ( tl + tr ) >> 1 ; build ( lch ( v ), tl , tm ); build ( rch ( v ), tm + 1 , tr ); pull ( v ); } } int qry ( int v , int tl , int tr , int l , int r ) { if ( l > tr || r < tl ) return 0 ; if ( l <= tl && r >= tr ) return T [ v ]; int tm = ( tl + tr ) >> 1 ; push ( v , tl , tr ); return combine ( qry ( lch ( v ), tl , tm , l , r ), qry ( rch ( v ), tm + 1 , tr , l , r )); } void upd ( int v , int tl , int tr , int l , int r , int add ) { if ( l > tr || r < tl ) return ; if ( l <= tl && r >= tr ) { tag [ v ] += add ; T [ v ] += add * ( r - l + 1 ); return ; } int tm = ( tl + tr ) >> 1 ; push ( v , tl , tr ); upd ( lch ( v ), tl , tm , l , r , add ); upd ( rch ( v ), tm + 1 , tr , l , r , add ); pull ( v ); } } seg ;","title":"Segment tree"},{"location":"algorithms/segment-tree/#implementation","text":"struct SegTree { constexpr static int MAXN = 1e5 + 5 ; int N ; int A [ MAXN ]; int T [ 4 * MAXN ], tag [ 4 * MAXN ]; void init ( int _N ) { N = _N ; } int lch ( int v ) { return v << 1 ; } int rch ( int v ) { return ( v << 1 ) | 1 ; } int combine ( int a , int b ) { return a + b ; } void pull ( int v ) { T [ v ] = combine ( T [ lch ( v )], T [ rch ( v )]); } void push ( int v , int l , int r ) { if ( tag [ v ] ) { int m = ( l + r ) >> 1 , lc = lch ( v ), rc = rch ( v ); T [ lc ] += ( m - l + 1 ) * tag [ v ]; T [ rc ] += ( r - m ) * tag [ v ]; tag [ lc ] += tag [ v ]; tag [ rc ] += tag [ v ]; tag [ v ] = 0 ; } } void build ( int v , int tl , int tr ) { if ( tl == tr ) { T [ v ] = A [ tl ]; } else { int tm = ( tl + tr ) >> 1 ; build ( lch ( v ), tl , tm ); build ( rch ( v ), tm + 1 , tr ); pull ( v ); } } int qry ( int v , int tl , int tr , int l , int r ) { if ( l > tr || r < tl ) return 0 ; if ( l <= tl && r >= tr ) return T [ v ]; int tm = ( tl + tr ) >> 1 ; push ( v , tl , tr ); return combine ( qry ( lch ( v ), tl , tm , l , r ), qry ( rch ( v ), tm + 1 , tr , l , r )); } void upd ( int v , int tl , int tr , int l , int r , int add ) { if ( l > tr || r < tl ) return ; if ( l <= tl && r >= tr ) { tag [ v ] += add ; T [ v ] += add * ( r - l + 1 ); return ; } int tm = ( tl + tr ) >> 1 ; push ( v , tl , tr ); upd ( lch ( v ), tl , tm , l , r , add ); upd ( rch ( v ), tm + 1 , tr , l , r , add ); pull ( v ); } } seg ;","title":"Implementation"},{"location":"courses/","text":"Courses \u00b6 Fall, 2019 \u00b6 Algorithm Design and Analysis System Programming Spring, 2019 \u00b6 Data Structures and Algorithms Network Administration and System Administration","title":"Courses"},{"location":"courses/#courses","text":"","title":"Courses"},{"location":"courses/#fall-2019","text":"Algorithm Design and Analysis System Programming","title":"Fall, 2019"},{"location":"courses/#spring-2019","text":"Data Structures and Algorithms Network Administration and System Administration","title":"Spring, 2019"},{"location":"courses/ada-fall-2019/","text":"Algorithm Design and Analysis \u00b6 Instructor: Hsiao, Hsu-Chun \u856d\u65ed\u541b Homework 1 \u00b6 Topics: Divide & Conquer, Dynamic Programming Programming Part: ADA Meetup Maximum Subarray Revisited Good Subpermutations Different Strings Hand-written Part: PDF file Homework 2 \u00b6 Topics: Dynamic Programming, Greedy Algorithm Homework 3 \u00b6 Topics: Graph Homework 4 \u00b6 Topics: NP-Completeness","title":"Algorithm Design and Analysis"},{"location":"courses/ada-fall-2019/#algorithm-design-and-analysis","text":"Instructor: Hsiao, Hsu-Chun \u856d\u65ed\u541b","title":"Algorithm Design and Analysis"},{"location":"courses/ada-fall-2019/#homework-1","text":"Topics: Divide & Conquer, Dynamic Programming Programming Part: ADA Meetup Maximum Subarray Revisited Good Subpermutations Different Strings Hand-written Part: PDF file","title":"Homework 1"},{"location":"courses/ada-fall-2019/#homework-2","text":"Topics: Dynamic Programming, Greedy Algorithm","title":"Homework 2"},{"location":"courses/ada-fall-2019/#homework-3","text":"Topics: Graph","title":"Homework 3"},{"location":"courses/ada-fall-2019/#homework-4","text":"Topics: NP-Completeness","title":"Homework 4"},{"location":"courses/ada-fall-2019/hw1/ada-meetup/","text":"ADA Meetup \u00b6 Problem Description \u00b6 Yun-Nung (Vivian) Chen's website Concept \u00b6 \u96e2\u6563\u5316 BIT Code \u00b6 #include <bits/stdc++.h> #define IOS {ios::sync_with_stdio(false);cin.tie(nullptr);} #pragma GCC optimize(\"Ofast\", \"no-stack-protector\", \"unroll-loops\") #pragma GCC optimize(\"no-stack-protector\") #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,sse4.2,popcnt,abm,mmx,avx,tune=native\") #pragma GCC diagnostic ignored \"-W\" using namespace std ; using LL = int64_t ; using ULL = uint64_t ; using LD = long double ; // input optimize inline int read_char () { constexpr int N = 1 << 20 ; static char buf [ N ]; static char * p = buf , * end = buf ; if ( p == end ) { if ( ( end = buf + fread ( buf , 1 , N , stdin )) == buf ) return EOF ; p = buf ; } return * p ++ ; } inline int read_int ( int & x ) { static char c , neg ; while ( ( c = read_char ()) < '-' ) if ( c == EOF ) return 0 ; neg = ( c == '-' ) ? - 1 : 1 ; x = ( neg == 1 ) ? c - '0' : 0 ; while ( ( c = read_char ()) >= '0' ) x = ( x << 3 ) + ( x << 1 ) + ( c - '0' ); x *= neg ; return 1 ; } const int MAXN = 1e6 + 5 ; int N ; int P [ MAXN ], F [ MAXN ], * ptr [ MAXN ], mp [ MAXN ]; bool cmp ( int * a , int * b ) { return * a < * b ; } int bit [ MAXN ]; inline int lowbit ( int x ) { return x & - x ; } int sum ( int idx ) { int ret = 0 ; for ( ; idx > 0 ; idx -= lowbit ( idx ) ) ret += bit [ idx ]; return ret ; } inline int sum ( int L , int R ) { if ( L < 1 ) L = 1 ; return sum ( R ) - sum ( L - 1 ); } void add ( int idx , int delta , int n ) { for ( ; idx <= n ; idx += lowbit ( idx ) ) bit [ idx ] += delta ; } int main () { read_int ( N ); for ( int i = 1 ; i <= N ; i ++ ) read_int ( P [ i ]); for ( int i = 1 ; i <= N ; i ++ ) read_int ( F [ i ]); for ( int i = 1 ; i <= N ; i ++ ) ptr [ i ] = & P [ i ]; sort ( ptr + 1 , ptr + N + 1 , cmp ); int n = 0 ; for ( int i = 1 ; i <= N ; ) { int v = * ptr [ i ]; ++ n ; for ( ; i <= N && * ptr [ i ] == v ; i ++ ) mp [ ptr [ i ] - P ] = n ; } long long ans = 0 ; add ( mp [ 1 ], 1 , n ); for ( int i = 2 ; i <= N ; i ++ ) { int lb = P [ i ] - F [ i ], ub = P [ i ] + F [ i ]; auto ll = lower_bound ( ptr + 1 , ptr + 1 + N , & lb , cmp ); auto rr = upper_bound ( ptr + 1 , ptr + 1 + N , & ub , cmp ) - 1 ; lb = mp [ * ll - P ]; ub = mp [ * rr - P ]; ans += sum ( lb , ub ); add ( mp [ i ], 1 , n ); } printf ( \"%lld \\n \" , ans ); return 0 ; } Tricks \u00b6 Just use GNU policy based data structures","title":"ADA Meetup"},{"location":"courses/ada-fall-2019/hw1/ada-meetup/#ada-meetup","text":"","title":"ADA Meetup"},{"location":"courses/ada-fall-2019/hw1/ada-meetup/#problem-description","text":"Yun-Nung (Vivian) Chen's website","title":"Problem Description"},{"location":"courses/ada-fall-2019/hw1/ada-meetup/#concept","text":"\u96e2\u6563\u5316 BIT","title":"Concept"},{"location":"courses/ada-fall-2019/hw1/ada-meetup/#code","text":"#include <bits/stdc++.h> #define IOS {ios::sync_with_stdio(false);cin.tie(nullptr);} #pragma GCC optimize(\"Ofast\", \"no-stack-protector\", \"unroll-loops\") #pragma GCC optimize(\"no-stack-protector\") #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,sse4.2,popcnt,abm,mmx,avx,tune=native\") #pragma GCC diagnostic ignored \"-W\" using namespace std ; using LL = int64_t ; using ULL = uint64_t ; using LD = long double ; // input optimize inline int read_char () { constexpr int N = 1 << 20 ; static char buf [ N ]; static char * p = buf , * end = buf ; if ( p == end ) { if ( ( end = buf + fread ( buf , 1 , N , stdin )) == buf ) return EOF ; p = buf ; } return * p ++ ; } inline int read_int ( int & x ) { static char c , neg ; while ( ( c = read_char ()) < '-' ) if ( c == EOF ) return 0 ; neg = ( c == '-' ) ? - 1 : 1 ; x = ( neg == 1 ) ? c - '0' : 0 ; while ( ( c = read_char ()) >= '0' ) x = ( x << 3 ) + ( x << 1 ) + ( c - '0' ); x *= neg ; return 1 ; } const int MAXN = 1e6 + 5 ; int N ; int P [ MAXN ], F [ MAXN ], * ptr [ MAXN ], mp [ MAXN ]; bool cmp ( int * a , int * b ) { return * a < * b ; } int bit [ MAXN ]; inline int lowbit ( int x ) { return x & - x ; } int sum ( int idx ) { int ret = 0 ; for ( ; idx > 0 ; idx -= lowbit ( idx ) ) ret += bit [ idx ]; return ret ; } inline int sum ( int L , int R ) { if ( L < 1 ) L = 1 ; return sum ( R ) - sum ( L - 1 ); } void add ( int idx , int delta , int n ) { for ( ; idx <= n ; idx += lowbit ( idx ) ) bit [ idx ] += delta ; } int main () { read_int ( N ); for ( int i = 1 ; i <= N ; i ++ ) read_int ( P [ i ]); for ( int i = 1 ; i <= N ; i ++ ) read_int ( F [ i ]); for ( int i = 1 ; i <= N ; i ++ ) ptr [ i ] = & P [ i ]; sort ( ptr + 1 , ptr + N + 1 , cmp ); int n = 0 ; for ( int i = 1 ; i <= N ; ) { int v = * ptr [ i ]; ++ n ; for ( ; i <= N && * ptr [ i ] == v ; i ++ ) mp [ ptr [ i ] - P ] = n ; } long long ans = 0 ; add ( mp [ 1 ], 1 , n ); for ( int i = 2 ; i <= N ; i ++ ) { int lb = P [ i ] - F [ i ], ub = P [ i ] + F [ i ]; auto ll = lower_bound ( ptr + 1 , ptr + 1 + N , & lb , cmp ); auto rr = upper_bound ( ptr + 1 , ptr + 1 + N , & ub , cmp ) - 1 ; lb = mp [ * ll - P ]; ub = mp [ * rr - P ]; ans += sum ( lb , ub ); add ( mp [ i ], 1 , n ); } printf ( \"%lld \\n \" , ans ); return 0 ; }","title":"Code"},{"location":"courses/ada-fall-2019/hw1/ada-meetup/#tricks","text":"Just use GNU policy based data structures","title":"Tricks"},{"location":"courses/ada-fall-2019/hw1/different-strings/","text":"Maximum Subarray Revisited \u00b6 Problem Description \u00b6 Yun-Nung (Vivian) Chen's website Concept \u00b6 Reversed Edit Distance Problem Code \u00b6 #include <bits/stdc++.h> #define IOS {ios::sync_with_stdio(false);cin.tie(nullptr);} #define gc getchar_unlocked() #pragma GCC optimize(\"Ofast\", \"no-stack-protector\", \"unroll-loops\") #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,sse4.2,popcnt,abm,mmx,avx,tune=native\") using namespace std ; const int MAXL = 2001 ; int na , nb ; char Sa [ MAXL ], Sb [ MAXL ]; int dp [ MAXL ][ MAXL ]; inline int min ( int a , int b ) { return a < b ? a : b ; } int main () { while ( ( Sa [ na ] = gc ) != '\\n' ) ++ na ; while ( ( Sb [ nb ] = gc ) >= 'A' ) ++ nb ; for ( int a = na - 1 ; a >= 0 ; -- a ) { for ( int b = nb - 1 ; b >= 0 ; -- b ) { if ( Sa [ a ] == Sb [ b ] ) dp [ a ][ b ] = 1 + min ( dp [ a + 1 ][ b + 1 ], min ( dp [ a ][ b + 1 ], dp [ a + 1 ][ b ])); else dp [ a ][ b ] = dp [ a + 1 ][ b + 1 ]; } } cout << dp [ 0 ][ 0 ]; return 0 ; }","title":"Maximum Subarray Revisited"},{"location":"courses/ada-fall-2019/hw1/different-strings/#maximum-subarray-revisited","text":"","title":"Maximum Subarray Revisited"},{"location":"courses/ada-fall-2019/hw1/different-strings/#problem-description","text":"Yun-Nung (Vivian) Chen's website","title":"Problem Description"},{"location":"courses/ada-fall-2019/hw1/different-strings/#concept","text":"Reversed Edit Distance Problem","title":"Concept"},{"location":"courses/ada-fall-2019/hw1/different-strings/#code","text":"#include <bits/stdc++.h> #define IOS {ios::sync_with_stdio(false);cin.tie(nullptr);} #define gc getchar_unlocked() #pragma GCC optimize(\"Ofast\", \"no-stack-protector\", \"unroll-loops\") #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,sse4.2,popcnt,abm,mmx,avx,tune=native\") using namespace std ; const int MAXL = 2001 ; int na , nb ; char Sa [ MAXL ], Sb [ MAXL ]; int dp [ MAXL ][ MAXL ]; inline int min ( int a , int b ) { return a < b ? a : b ; } int main () { while ( ( Sa [ na ] = gc ) != '\\n' ) ++ na ; while ( ( Sb [ nb ] = gc ) >= 'A' ) ++ nb ; for ( int a = na - 1 ; a >= 0 ; -- a ) { for ( int b = nb - 1 ; b >= 0 ; -- b ) { if ( Sa [ a ] == Sb [ b ] ) dp [ a ][ b ] = 1 + min ( dp [ a + 1 ][ b + 1 ], min ( dp [ a ][ b + 1 ], dp [ a + 1 ][ b ])); else dp [ a ][ b ] = dp [ a + 1 ][ b + 1 ]; } } cout << dp [ 0 ][ 0 ]; return 0 ; }","title":"Code"},{"location":"courses/ada-fall-2019/hw1/good-subpermutations/","text":"Maximum Subarray Revisited \u00b6 Problem Description \u00b6 Yun-Nung (Vivian) Chen's website Concept \u00b6 This problem is so difficult...... Code \u00b6 #include <bits/stdc++.h> #define IOS {ios::sync_with_stdio(false);cin.tie(nullptr);} #pragma GCC optimize(\"Ofast\", \"no-stack-protector\", \"unroll-loops\") #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,sse4.2,popcnt,abm,mmx,avx,tune=native\") using namespace std ; using LL = long long ; inline int read_char (); inline int read_int ( int & ); const int MAXN = 5e5 + 5 , NN = 1e6 + 5 ; const int T = 40 ; int N , A [ MAXN ], Mx [ MAXN ], Mn [ MAXN ]; int cnt [ NN ], cnt2 [ NN ]; LL Ans ; void solve ( int L , int R ) { if ( L == R ) return void ( ++ Ans ); if ( R - L <= T ) { for ( int l = L ; l <= R ; l ++ ) { int mx = A [ l ], mn = A [ l ]; for ( int r = l ; r <= R ; r ++ ) { mx = max ( mx , A [ r ]); mn = min ( mn , A [ r ]); Ans += ( mx - mn == r - l ); } } return ; } // D & C int m = ( L + R ) >> 1 ; solve ( L , m ); solve ( m + 1 , R ); // preprocess Mx [ m ] = Mn [ m ] = A [ m ]; for ( int i = m - 1 ; i >= L ; i -- ) Mx [ i ] = max ( Mx [ i + 1 ], A [ i ]), Mn [ i ] = min ( Mn [ i + 1 ], A [ i ]); Mx [ m + 1 ] = Mn [ m + 1 ] = A [ m + 1 ]; cnt [ Mn [ m + 1 ] + m + 1 ] = cnt2 [ Mx [ m + 1 ] - m - 1 + N ] = 0 ; for ( int i = m + 2 ; i <= R ; i ++ ) { Mx [ i ] = max ( Mx [ i - 1 ], A [ i ]), Mn [ i ] = min ( Mn [ i - 1 ], A [ i ]); cnt [ Mn [ i ] + i ] = cnt2 [ Mx [ i ] - i + N ] = 0 ; } // cross subarray int pmx = m , pmn = m ; for ( int r = m + 1 ; r <= R ; r ++ ) { int mx_r = Mx [ r ], mn_r = Mn [ r ]; for ( ; pmx >= L && Mx [ pmx ] < mx_r ; pmx -- ) { -- cnt [ Mx [ pmx ] + pmx ]; ++ cnt2 [ Mn [ pmx ] - pmx + N ]; } for ( ; pmn >= L && Mn [ pmn ] > mn_r ; pmn -- ) { ++ cnt [ Mx [ pmn ] + pmn ]; -- cnt2 [ Mn [ pmn ] - pmn + N ]; } if ( pmn < pmx ) Ans += cnt [ mn_r + r ]; else Ans += cnt2 [ mx_r - r + N ]; int idx = r - ( mx_r - mn_r ); Ans += ( idx <= m && idx > max ( pmx , pmn ) ); } for ( int l = m ; l >= L ; l -- ) { int idx = l + ( Mx [ l ] - Mn [ l ]); Ans += ( idx <= R && idx >= m + 1 && Mx [ idx ] < Mx [ l ] && Mn [ idx ] > Mn [ l ] ); } } int main () { IOS ; read_int ( N ); for ( int i = 1 ; i <= N ; i ++ ) read_int ( A [ i ]); solve ( 1 , N ); printf ( \"%lld \\n \" , Ans ); return 0 ; } // input optimize inline int read_char () { constexpr int N = 1 << 20 ; static char buf [ N ]; static char * p = buf , * end = buf ; if ( p == end ) { if ( ( end = buf + fread_unlocked ( buf , 1 , N , stdin )) == buf ) return EOF ; p = buf ; } return * p ++ ; } inline int read_int ( int & x ) { static char c , neg ; while ( ( c = read_char ()) < '-' ) if ( c == EOF ) return 0 ; neg = ( c == '-' ) ? - 1 : 1 ; x = ( neg == 1 ) ? c - '0' : 0 ; while ( ( c = read_char ()) >= '0' ) x = ( x << 3 ) + ( x << 1 ) + ( c - '0' ); x *= neg ; return 1 ; }","title":"Maximum Subarray Revisited"},{"location":"courses/ada-fall-2019/hw1/good-subpermutations/#maximum-subarray-revisited","text":"","title":"Maximum Subarray Revisited"},{"location":"courses/ada-fall-2019/hw1/good-subpermutations/#problem-description","text":"Yun-Nung (Vivian) Chen's website","title":"Problem Description"},{"location":"courses/ada-fall-2019/hw1/good-subpermutations/#concept","text":"This problem is so difficult......","title":"Concept"},{"location":"courses/ada-fall-2019/hw1/good-subpermutations/#code","text":"#include <bits/stdc++.h> #define IOS {ios::sync_with_stdio(false);cin.tie(nullptr);} #pragma GCC optimize(\"Ofast\", \"no-stack-protector\", \"unroll-loops\") #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,sse4.2,popcnt,abm,mmx,avx,tune=native\") using namespace std ; using LL = long long ; inline int read_char (); inline int read_int ( int & ); const int MAXN = 5e5 + 5 , NN = 1e6 + 5 ; const int T = 40 ; int N , A [ MAXN ], Mx [ MAXN ], Mn [ MAXN ]; int cnt [ NN ], cnt2 [ NN ]; LL Ans ; void solve ( int L , int R ) { if ( L == R ) return void ( ++ Ans ); if ( R - L <= T ) { for ( int l = L ; l <= R ; l ++ ) { int mx = A [ l ], mn = A [ l ]; for ( int r = l ; r <= R ; r ++ ) { mx = max ( mx , A [ r ]); mn = min ( mn , A [ r ]); Ans += ( mx - mn == r - l ); } } return ; } // D & C int m = ( L + R ) >> 1 ; solve ( L , m ); solve ( m + 1 , R ); // preprocess Mx [ m ] = Mn [ m ] = A [ m ]; for ( int i = m - 1 ; i >= L ; i -- ) Mx [ i ] = max ( Mx [ i + 1 ], A [ i ]), Mn [ i ] = min ( Mn [ i + 1 ], A [ i ]); Mx [ m + 1 ] = Mn [ m + 1 ] = A [ m + 1 ]; cnt [ Mn [ m + 1 ] + m + 1 ] = cnt2 [ Mx [ m + 1 ] - m - 1 + N ] = 0 ; for ( int i = m + 2 ; i <= R ; i ++ ) { Mx [ i ] = max ( Mx [ i - 1 ], A [ i ]), Mn [ i ] = min ( Mn [ i - 1 ], A [ i ]); cnt [ Mn [ i ] + i ] = cnt2 [ Mx [ i ] - i + N ] = 0 ; } // cross subarray int pmx = m , pmn = m ; for ( int r = m + 1 ; r <= R ; r ++ ) { int mx_r = Mx [ r ], mn_r = Mn [ r ]; for ( ; pmx >= L && Mx [ pmx ] < mx_r ; pmx -- ) { -- cnt [ Mx [ pmx ] + pmx ]; ++ cnt2 [ Mn [ pmx ] - pmx + N ]; } for ( ; pmn >= L && Mn [ pmn ] > mn_r ; pmn -- ) { ++ cnt [ Mx [ pmn ] + pmn ]; -- cnt2 [ Mn [ pmn ] - pmn + N ]; } if ( pmn < pmx ) Ans += cnt [ mn_r + r ]; else Ans += cnt2 [ mx_r - r + N ]; int idx = r - ( mx_r - mn_r ); Ans += ( idx <= m && idx > max ( pmx , pmn ) ); } for ( int l = m ; l >= L ; l -- ) { int idx = l + ( Mx [ l ] - Mn [ l ]); Ans += ( idx <= R && idx >= m + 1 && Mx [ idx ] < Mx [ l ] && Mn [ idx ] > Mn [ l ] ); } } int main () { IOS ; read_int ( N ); for ( int i = 1 ; i <= N ; i ++ ) read_int ( A [ i ]); solve ( 1 , N ); printf ( \"%lld \\n \" , Ans ); return 0 ; } // input optimize inline int read_char () { constexpr int N = 1 << 20 ; static char buf [ N ]; static char * p = buf , * end = buf ; if ( p == end ) { if ( ( end = buf + fread_unlocked ( buf , 1 , N , stdin )) == buf ) return EOF ; p = buf ; } return * p ++ ; } inline int read_int ( int & x ) { static char c , neg ; while ( ( c = read_char ()) < '-' ) if ( c == EOF ) return 0 ; neg = ( c == '-' ) ? - 1 : 1 ; x = ( neg == 1 ) ? c - '0' : 0 ; while ( ( c = read_char ()) >= '0' ) x = ( x << 3 ) + ( x << 1 ) + ( c - '0' ); x *= neg ; return 1 ; }","title":"Code"},{"location":"courses/ada-fall-2019/hw1/maximum-subarray-revisited/","text":"Maximum Subarray Revisited \u00b6 Problem Description \u00b6 Yun-Nung (Vivian) Chen's website Concept \u00b6 Store the process of divide and conquer (just as segment tree ) In each node representing [L, R] [L, R] , store 4 things: lmx = \\max\\limits_{L \\leq r \\leq R} \\sum_{i=L}^{r} A_i = \\max\\limits_{L \\leq r \\leq R} \\sum_{i=L}^{r} A_i rmx = \\max\\limits_{L \\leq \\ell \\leq R} \\sum_{i = \\ell}^{R} A_i = \\max\\limits_{L \\leq \\ell \\leq R} \\sum_{i = \\ell}^{R} A_i ans = \\max\\limits_{L \\leq \\ell \\leq r \\leq R} \\sum_{i = \\ell}^{r} A_i = \\max\\limits_{L \\leq \\ell \\leq r \\leq R} \\sum_{i = \\ell}^{r} A_i sum = \\sum_{i=L}^{R} A_i = \\sum_{i=L}^{R} A_i The \"merge\" step is as the code. Code \u00b6 #include <bits/stdc++.h> #define IOS {ios::sync_with_stdio(false);cin.tie(nullptr);} using namespace std ; using LL = int64_t ; using ULL = uint64_t ; using LD = long double ; inline int read_char (); inline int read_int ( int & ); inline void write_int ( LL ); constexpr int MAXN = 5e5 + 5 ; struct Item { LL lmx , rmx , sum , ans ; }; int N , A [ MAXN ]; Item seg [ 4 * MAXN ]; inline int lch ( int v ) { return ( v << 1 ); } inline int rch ( int v ) { return ( v << 1 ) | 1 ; } inline void combine ( Item & v , Item & a , Item & b ) { v . sum = a . sum + b . sum ; v . lmx = max ( a . lmx , a . sum + b . lmx ); v . rmx = max ( b . rmx , b . sum + a . rmx ); v . ans = max ( a . rmx + b . lmx , max ( a . ans , b . ans )); } void build ( int v , int tl , int tr ) { if ( tl == tr ) { seg [ v ] = { A [ tl ], A [ tl ], A [ tl ], A [ tl ]}; } else { int tm = ( tl + tr ) >> 1 ; build ( lch ( v ), tl , tm ); build ( rch ( v ), tm + 1 , tr ); combine ( seg [ v ], seg [ lch ( v )], seg [ rch ( v )]); } } void pt_upd ( int v , int tl , int tr , int pos , int new_v ) { if ( tl == tr ) { seg [ v ] = { new_v , new_v , new_v , new_v }; } else { int tm = ( tl + tr ) >> 1 ; if ( pos <= tm ) pt_upd ( lch ( v ), tl , tm , pos , new_v ); else pt_upd ( rch ( v ), tm + 1 , tr , pos , new_v ); combine ( seg [ v ], seg [ lch ( v )], seg [ rch ( v )]); } } inline LL qry () { return seg [ 1 ]. ans < 0 ? 0 : seg [ 1 ]. ans ; } int main () { int Q ; read_int ( N ); read_int ( Q ); for ( int i = 1 ; i <= N ; i ++ ) read_int ( A [ i ]); build ( 1 , 1 , N ); write_int ( qry ()); while ( Q -- ) { int pos , v ; read_int ( pos ); read_int ( v ); pt_upd ( 1 , 1 , N , pos , v ); write_int ( qry ()); } return 0 ; } // input optimize inline int read_char () { constexpr int N = 1 << 20 ; static char buf [ N ]; static char * p = buf , * end = buf ; if ( p == end ) { if ( ( end = buf + fread ( buf , 1 , N , stdin )) == buf ) return EOF ; p = buf ; } return * p ++ ; } inline int read_int ( int & x ) { static char c , neg ; while ( ( c = read_char ()) < '-' ) if ( c == EOF ) return 0 ; neg = ( c == '-' ) ? - 1 : 1 ; x = ( neg == 1 ) ? c - '0' : 0 ; while ( ( c = read_char ()) >= '0' ) x = ( x << 3 ) + ( x << 1 ) + ( c - '0' ); x *= neg ; return 1 ; } // output optimize #define _pc putchar_unlocked char _buf [ 128 ]; inline void write_int ( LL x ) { if ( ! x ) { _pc ( '0' ); _pc ( '\\n' ); return ; } int t = 0 ; while ( x ) { _buf [ t ++ ] = x % 10 + '0' ; x /= 10 ; } while ( t -- ) _pc ( _buf [ t ]); _pc ( '\\n' ); } #undef _pc","title":"Maximum Subarray Revisited"},{"location":"courses/ada-fall-2019/hw1/maximum-subarray-revisited/#maximum-subarray-revisited","text":"","title":"Maximum Subarray Revisited"},{"location":"courses/ada-fall-2019/hw1/maximum-subarray-revisited/#problem-description","text":"Yun-Nung (Vivian) Chen's website","title":"Problem Description"},{"location":"courses/ada-fall-2019/hw1/maximum-subarray-revisited/#concept","text":"Store the process of divide and conquer (just as segment tree ) In each node representing [L, R] [L, R] , store 4 things: lmx = \\max\\limits_{L \\leq r \\leq R} \\sum_{i=L}^{r} A_i = \\max\\limits_{L \\leq r \\leq R} \\sum_{i=L}^{r} A_i rmx = \\max\\limits_{L \\leq \\ell \\leq R} \\sum_{i = \\ell}^{R} A_i = \\max\\limits_{L \\leq \\ell \\leq R} \\sum_{i = \\ell}^{R} A_i ans = \\max\\limits_{L \\leq \\ell \\leq r \\leq R} \\sum_{i = \\ell}^{r} A_i = \\max\\limits_{L \\leq \\ell \\leq r \\leq R} \\sum_{i = \\ell}^{r} A_i sum = \\sum_{i=L}^{R} A_i = \\sum_{i=L}^{R} A_i The \"merge\" step is as the code.","title":"Concept"},{"location":"courses/ada-fall-2019/hw1/maximum-subarray-revisited/#code","text":"#include <bits/stdc++.h> #define IOS {ios::sync_with_stdio(false);cin.tie(nullptr);} using namespace std ; using LL = int64_t ; using ULL = uint64_t ; using LD = long double ; inline int read_char (); inline int read_int ( int & ); inline void write_int ( LL ); constexpr int MAXN = 5e5 + 5 ; struct Item { LL lmx , rmx , sum , ans ; }; int N , A [ MAXN ]; Item seg [ 4 * MAXN ]; inline int lch ( int v ) { return ( v << 1 ); } inline int rch ( int v ) { return ( v << 1 ) | 1 ; } inline void combine ( Item & v , Item & a , Item & b ) { v . sum = a . sum + b . sum ; v . lmx = max ( a . lmx , a . sum + b . lmx ); v . rmx = max ( b . rmx , b . sum + a . rmx ); v . ans = max ( a . rmx + b . lmx , max ( a . ans , b . ans )); } void build ( int v , int tl , int tr ) { if ( tl == tr ) { seg [ v ] = { A [ tl ], A [ tl ], A [ tl ], A [ tl ]}; } else { int tm = ( tl + tr ) >> 1 ; build ( lch ( v ), tl , tm ); build ( rch ( v ), tm + 1 , tr ); combine ( seg [ v ], seg [ lch ( v )], seg [ rch ( v )]); } } void pt_upd ( int v , int tl , int tr , int pos , int new_v ) { if ( tl == tr ) { seg [ v ] = { new_v , new_v , new_v , new_v }; } else { int tm = ( tl + tr ) >> 1 ; if ( pos <= tm ) pt_upd ( lch ( v ), tl , tm , pos , new_v ); else pt_upd ( rch ( v ), tm + 1 , tr , pos , new_v ); combine ( seg [ v ], seg [ lch ( v )], seg [ rch ( v )]); } } inline LL qry () { return seg [ 1 ]. ans < 0 ? 0 : seg [ 1 ]. ans ; } int main () { int Q ; read_int ( N ); read_int ( Q ); for ( int i = 1 ; i <= N ; i ++ ) read_int ( A [ i ]); build ( 1 , 1 , N ); write_int ( qry ()); while ( Q -- ) { int pos , v ; read_int ( pos ); read_int ( v ); pt_upd ( 1 , 1 , N , pos , v ); write_int ( qry ()); } return 0 ; } // input optimize inline int read_char () { constexpr int N = 1 << 20 ; static char buf [ N ]; static char * p = buf , * end = buf ; if ( p == end ) { if ( ( end = buf + fread ( buf , 1 , N , stdin )) == buf ) return EOF ; p = buf ; } return * p ++ ; } inline int read_int ( int & x ) { static char c , neg ; while ( ( c = read_char ()) < '-' ) if ( c == EOF ) return 0 ; neg = ( c == '-' ) ? - 1 : 1 ; x = ( neg == 1 ) ? c - '0' : 0 ; while ( ( c = read_char ()) >= '0' ) x = ( x << 3 ) + ( x << 1 ) + ( c - '0' ); x *= neg ; return 1 ; } // output optimize #define _pc putchar_unlocked char _buf [ 128 ]; inline void write_int ( LL x ) { if ( ! x ) { _pc ( '0' ); _pc ( '\\n' ); return ; } int t = 0 ; while ( x ) { _buf [ t ++ ] = x % 10 + '0' ; x /= 10 ; } while ( t -- ) _pc ( _buf [ t ]); _pc ( '\\n' ); } #undef _pc","title":"Code"},{"location":"misc/","text":"Miscellaneous \u00b6 Kubuntu installation note","title":"Miscellaneous"},{"location":"misc/#miscellaneous","text":"Kubuntu installation note","title":"Miscellaneous"},{"location":"misc/kubuntu-installation-note/","text":"Kubuntu Installation Note \u00b6 Because I frequently mess up my operating system, plus I am so bad at debugging Linux issues, I usually just resort to reinstallation . So to minimize the time wasted, I make this note.... set terminal shortcut \u00b6 System Settings -> Shortcuts -> custom shortcut -> edit -> new .... action is \"konsole\" (lowercase) install chrome \u00b6 Just do it Set Chrome as default browser \u00b6 update : the easy way: create a temporary html file, right click -> file extension setting -> change the priority Beside the one in System Setting, run: xdg-mime default google-chrome.desktop text/html Check ~/.config/mimeapps.list install packages \u00b6 vim wget curl build-essential git zsh exfat-fuse exfat-utils tmux python3-pip sudo apt install vim wget curl build-essential git zsh exfat-fuse exfat-utils tmux python3-pip dotfiles \u00b6 .profile .tmux.conf .vimrc generate ssh key and deploy \u00b6 ssh-keygen && ssh-copy-id b07902075@linux1.csie.org add ssh key to github clone repo \u00b6 Just do it install vscode \u00b6 extensions: material theme(dark), git lens install chinese pinyin input method (fcitx + google-pinyin) \u00b6 Install required packages sudo apt install fcitx-bin fcitx-config-gtk2 fcitx-frontend-qt4 fcitx-frontend-qt5 fcitx-googlepinyin fcitx-imlist fcitx-module-dbus Edit /etc/enviroment GTK_IM_MODULE = fcitx QT_IM_MODULE = fcitx XMODIFIERS = \"@im=fcitx\" Edit ~/.xprofile export GTK_IM_MODULE = fcitx export QT_IM_MODULE = fcitx export XMODIFIERS = \"@im=fcitx\" In System Settings -> Regional Settings -> Language change some setting Run im-config In System Settings , add fcitx to start-up routine Reboot In fcitx's configuration panel, add google-pinyin If you cannot toggle to traditional chinese, try ctrl+shift+F If there is error when starting fcitx, it is possibly an ibus related issue If fcitx still doesn't work, try run fcitx-diagnose install mkdocs for this website \u00b6 pip install mkdocs mkdocs-material mkdocs-macros-plugin pymdown-extensions install oh-my-zsh \u00b6 go to official page on github and follow its instructions configure themes \u00b6 Breeze, Breeze, Breeze... google cursor","title":"Kubuntu Installation Note"},{"location":"misc/kubuntu-installation-note/#kubuntu-installation-note","text":"Because I frequently mess up my operating system, plus I am so bad at debugging Linux issues, I usually just resort to reinstallation . So to minimize the time wasted, I make this note....","title":"Kubuntu Installation Note"},{"location":"misc/kubuntu-installation-note/#set-terminal-shortcut","text":"System Settings -> Shortcuts -> custom shortcut -> edit -> new .... action is \"konsole\" (lowercase)","title":"set terminal shortcut"},{"location":"misc/kubuntu-installation-note/#install-chrome","text":"Just do it","title":"install chrome"},{"location":"misc/kubuntu-installation-note/#set-chrome-as-default-browser","text":"update : the easy way: create a temporary html file, right click -> file extension setting -> change the priority Beside the one in System Setting, run: xdg-mime default google-chrome.desktop text/html Check ~/.config/mimeapps.list","title":"Set Chrome as default browser"},{"location":"misc/kubuntu-installation-note/#install-packages","text":"vim wget curl build-essential git zsh exfat-fuse exfat-utils tmux python3-pip sudo apt install vim wget curl build-essential git zsh exfat-fuse exfat-utils tmux python3-pip","title":"install packages"},{"location":"misc/kubuntu-installation-note/#dotfiles","text":".profile .tmux.conf .vimrc","title":"dotfiles"},{"location":"misc/kubuntu-installation-note/#generate-ssh-key-and-deploy","text":"ssh-keygen && ssh-copy-id b07902075@linux1.csie.org add ssh key to github","title":"generate ssh key and deploy"},{"location":"misc/kubuntu-installation-note/#clone-repo","text":"Just do it","title":"clone repo"},{"location":"misc/kubuntu-installation-note/#install-vscode","text":"extensions: material theme(dark), git lens","title":"install vscode"},{"location":"misc/kubuntu-installation-note/#install-chinese-pinyin-input-method-fcitx-google-pinyin","text":"Install required packages sudo apt install fcitx-bin fcitx-config-gtk2 fcitx-frontend-qt4 fcitx-frontend-qt5 fcitx-googlepinyin fcitx-imlist fcitx-module-dbus Edit /etc/enviroment GTK_IM_MODULE = fcitx QT_IM_MODULE = fcitx XMODIFIERS = \"@im=fcitx\" Edit ~/.xprofile export GTK_IM_MODULE = fcitx export QT_IM_MODULE = fcitx export XMODIFIERS = \"@im=fcitx\" In System Settings -> Regional Settings -> Language change some setting Run im-config In System Settings , add fcitx to start-up routine Reboot In fcitx's configuration panel, add google-pinyin If you cannot toggle to traditional chinese, try ctrl+shift+F If there is error when starting fcitx, it is possibly an ibus related issue If fcitx still doesn't work, try run fcitx-diagnose","title":"install chinese pinyin input method (fcitx + google-pinyin)"},{"location":"misc/kubuntu-installation-note/#install-mkdocs-for-this-website","text":"pip install mkdocs mkdocs-material mkdocs-macros-plugin pymdown-extensions","title":"install mkdocs for this website"},{"location":"misc/kubuntu-installation-note/#install-oh-my-zsh","text":"go to official page on github and follow its instructions","title":"install oh-my-zsh"},{"location":"misc/kubuntu-installation-note/#configure-themes","text":"Breeze, Breeze, Breeze... google cursor","title":"configure themes"}]}