{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Computer Science Note \u00b6 The documentation in this site is for: organize my knowledge better create a better view of what I have learned Courses \u00b6 This area mostly contains homework assignments, sometimes with some class notes. Algorithms \u00b6 My own implementation of some algorithms, mainly in C++.","title":"Home"},{"location":"#computer-science-note","text":"The documentation in this site is for: organize my knowledge better create a better view of what I have learned","title":"Computer Science Note"},{"location":"#courses","text":"This area mostly contains homework assignments, sometimes with some class notes.","title":"Courses"},{"location":"#algorithms","text":"My own implementation of some algorithms, mainly in C++.","title":"Algorithms"},{"location":"about/","text":"Author \u00b6 Department of Computer Science and Information Engineering in National Taiwan University That's all(?)","title":"About"},{"location":"about/#author","text":"Department of Computer Science and Information Engineering in National Taiwan University That's all(?)","title":"Author"},{"location":"algorithms/","text":"Algorithms \u00b6 Data Structures \u00b6 Segment Tree Graph \u00b6 Depth First Search","title":"Algorithms"},{"location":"algorithms/#algorithms","text":"","title":"Algorithms"},{"location":"algorithms/#data-structures","text":"Segment Tree","title":"Data Structures"},{"location":"algorithms/#graph","text":"Depth First Search","title":"Graph"},{"location":"algorithms/dfs/","text":"Depth First Search \u00b6 Basic DFS \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 constexpr int MAXN = 1e3 + 5 ; int N ; vector < int > G [ MAXN ]; int color [ MAXN ], tin [ MAXN ], tout [ MAXN ], timer ; const int WHITE = 0 , GREY = 1 , BLACK = 2 ; void is_back_edge ( int from , int to ) {} void is_cross_edge ( int from , int to ) {} bool is_ancestor ( int anc , int des ) { return tin [ anc ] < tin [ des ] && tout [ anc ] > tout [ des ]; } void dfs_util ( int v ) { color [ v ] = GREY ; tin [ v ] = timer ++ ; for ( int u : G [ v ] ) { if ( color [ u ] == WHITE ) dfs_util ( u ); else if ( color [ u ] == GREY ) is_back_edge ( v , u ); else if ( color [ u ] == BLACK ) is_cross_edge ( v , u ); } color [ v ] = BLACK ; tout [ v ] = timer ++ ; } void dfs () { fill ( color , color + N , WHITE ); timer = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( color [ i ] == WHITE ) dfs_util ( i ); } Topological Sort \u00b6 Find bridge \u00b6","title":"Depth First Search"},{"location":"algorithms/dfs/#depth-first-search","text":"","title":"Depth First Search"},{"location":"algorithms/dfs/#basic-dfs","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 constexpr int MAXN = 1e3 + 5 ; int N ; vector < int > G [ MAXN ]; int color [ MAXN ], tin [ MAXN ], tout [ MAXN ], timer ; const int WHITE = 0 , GREY = 1 , BLACK = 2 ; void is_back_edge ( int from , int to ) {} void is_cross_edge ( int from , int to ) {} bool is_ancestor ( int anc , int des ) { return tin [ anc ] < tin [ des ] && tout [ anc ] > tout [ des ]; } void dfs_util ( int v ) { color [ v ] = GREY ; tin [ v ] = timer ++ ; for ( int u : G [ v ] ) { if ( color [ u ] == WHITE ) dfs_util ( u ); else if ( color [ u ] == GREY ) is_back_edge ( v , u ); else if ( color [ u ] == BLACK ) is_cross_edge ( v , u ); } color [ v ] = BLACK ; tout [ v ] = timer ++ ; } void dfs () { fill ( color , color + N , WHITE ); timer = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( color [ i ] == WHITE ) dfs_util ( i ); }","title":"Basic DFS"},{"location":"algorithms/dfs/#topological-sort","text":"","title":"Topological Sort"},{"location":"algorithms/dfs/#find-bridge","text":"","title":"Find bridge"},{"location":"algorithms/segment-tree/","text":"Implementation \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 struct SegTree { constexpr static int MAXN = 1e5 + 5 ; int N ; int A [ MAXN ]; int T [ 4 * MAXN ], tag [ 4 * MAXN ]; void init ( int _N ) { N = _N ; } int lch ( int v ) { return v << 1 ; } int rch ( int v ) { return ( v << 1 ) | 1 ; } int combine ( int a , int b ) { return a + b ; } void pull ( int v ) { T [ v ] = combine ( T [ lch ( v )], T [ rch ( v )]); } void push ( int v , int l , int r ) { if ( tag [ v ] ) { int m = ( l + r ) >> 1 , lc = lch ( v ), rc = rch ( v ); T [ lc ] += ( m - l + 1 ) * tag [ v ]; T [ rc ] += ( r - m ) * tag [ v ]; tag [ lc ] += tag [ v ]; tag [ rc ] += tag [ v ]; tag [ v ] = 0 ; } } void build ( int v , int tl , int tr ) { if ( tl == tr ) { T [ v ] = A [ tl ]; } else { int tm = ( tl + tr ) >> 1 ; build ( lch ( v ), tl , tm ); build ( rch ( v ), tm + 1 , tr ); pull ( v ); } } int qry ( int v , int tl , int tr , int l , int r ) { if ( l > tr || r < tl ) return 0 ; if ( l <= tl && r >= tr ) return T [ v ]; int tm = ( tl + tr ) >> 1 ; push ( v , tl , tr ); return combine ( qry ( lch ( v ), tl , tm , l , r ), qry ( rch ( v ), tm + 1 , tr , l , r )); } void upd ( int v , int tl , int tr , int l , int r , int add ) { if ( l > tr || r < tl ) return ; if ( l <= tl && r >= tr ) { tag [ v ] += add ; T [ v ] += add * ( r - l + 1 ); return ; } int tm = ( tl + tr ) >> 1 ; push ( v , tl , tr ); upd ( lch ( v ), tl , tm , l , r , add ); upd ( rch ( v ), tm + 1 , tr , l , r , add ); pull ( v ); } } seg ;","title":"Segment tree"},{"location":"algorithms/segment-tree/#implementation","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 struct SegTree { constexpr static int MAXN = 1e5 + 5 ; int N ; int A [ MAXN ]; int T [ 4 * MAXN ], tag [ 4 * MAXN ]; void init ( int _N ) { N = _N ; } int lch ( int v ) { return v << 1 ; } int rch ( int v ) { return ( v << 1 ) | 1 ; } int combine ( int a , int b ) { return a + b ; } void pull ( int v ) { T [ v ] = combine ( T [ lch ( v )], T [ rch ( v )]); } void push ( int v , int l , int r ) { if ( tag [ v ] ) { int m = ( l + r ) >> 1 , lc = lch ( v ), rc = rch ( v ); T [ lc ] += ( m - l + 1 ) * tag [ v ]; T [ rc ] += ( r - m ) * tag [ v ]; tag [ lc ] += tag [ v ]; tag [ rc ] += tag [ v ]; tag [ v ] = 0 ; } } void build ( int v , int tl , int tr ) { if ( tl == tr ) { T [ v ] = A [ tl ]; } else { int tm = ( tl + tr ) >> 1 ; build ( lch ( v ), tl , tm ); build ( rch ( v ), tm + 1 , tr ); pull ( v ); } } int qry ( int v , int tl , int tr , int l , int r ) { if ( l > tr || r < tl ) return 0 ; if ( l <= tl && r >= tr ) return T [ v ]; int tm = ( tl + tr ) >> 1 ; push ( v , tl , tr ); return combine ( qry ( lch ( v ), tl , tm , l , r ), qry ( rch ( v ), tm + 1 , tr , l , r )); } void upd ( int v , int tl , int tr , int l , int r , int add ) { if ( l > tr || r < tl ) return ; if ( l <= tl && r >= tr ) { tag [ v ] += add ; T [ v ] += add * ( r - l + 1 ); return ; } int tm = ( tl + tr ) >> 1 ; push ( v , tl , tr ); upd ( lch ( v ), tl , tm , l , r , add ); upd ( rch ( v ), tm + 1 , tr , l , r , add ); pull ( v ); } } seg ;","title":"Implementation"},{"location":"courses/","text":"Courses \u00b6 Fall, 2019 \u00b6 Algorithm Design and Analysis System Programming Linear Algebra Spring, 2019 \u00b6","title":"Courses"},{"location":"courses/#courses","text":"","title":"Courses"},{"location":"courses/#fall-2019","text":"Algorithm Design and Analysis System Programming Linear Algebra","title":"Fall, 2019"},{"location":"courses/#spring-2019","text":"","title":"Spring, 2019"}]}