{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Algorithms \u00b6 My own implementation of some algorithms 1 2 3 4 5 6 7 #include <iostream> int main () { std :: cout << \"hello, world\" << std :: endl ; return EXIT_SUCCESS ; } Categories \u00b6 Data Structures Graph String Miscellaneous Tags \u00b6 Dynamic Programming Divide & Conquer Greedy NP-Complete","title":"Home"},{"location":"#algorithms","text":"My own implementation of some algorithms 1 2 3 4 5 6 7 #include <iostream> int main () { std :: cout << \"hello, world\" << std :: endl ; return EXIT_SUCCESS ; }","title":"Algorithms"},{"location":"#categories","text":"Data Structures Graph String Miscellaneous","title":"Categories"},{"location":"#tags","text":"Dynamic Programming Divide & Conquer Greedy NP-Complete","title":"Tags"},{"location":"about/","text":"Author \u00b6 I am not good at algorithms, but I am trying my best.","title":"About"},{"location":"about/#author","text":"I am not good at algorithms, but I am trying my best.","title":"Author"},{"location":"data-structures/","text":"Data Structures \u00b6 Segment Tree","title":"Home"},{"location":"data-structures/#data-structures","text":"Segment Tree","title":"Data Structures"},{"location":"data-structures/segment-tree/","text":"Implementation \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 constexpr int MAXN = 1e5 + 5 ; int N , A [ MAXN ]; int seg [ 4 * MAXN ], lazy [ 4 * MAXN ]; inline int lch ( int v ) { return 2 * v ; } inline int rch ( int v ) { return 2 * v + 1 ; } inline int combine ( int a , int b ) { return a + b ; } inline void push ( int v , int l , int r ) { int m = ( l + r ) & gt ; & gt ; 1 ; seg [ lch ( v )] += ( m - l + 1 ) * lazy [ v ]; seg [ rch ( v )] += ( r - m ) * lazy [ v ]; lazy [ lch ( v )] += lazy [ v ]; lazy [ rch ( v )] += lazy [ v ]; lazy [ v ] = 0 ; } void build ( int v , int tl , int tr ) { if ( tl == tr ) { seg [ v ] = A [ tl ]; } else { int tm = ( tl + tr ) & gt ; & gt ; 1 ; build ( lch ( v ), tl , tm ); build ( rch ( v ), tm + 1 , tr ); seg [ v ] = combine ( seg [ lch ( v )], seg [ rch ( v )]); } } int range_q ( int v , int tl , int tr , int l , int r ) { if ( l & gt ; r ) return 0 ; if ( l == tl & amp ; & amp ; r == tr ) return seg [ v ]; push ( v , tl , tr ); int tm = ( tl + tr ) & gt ; & gt ; 1 ; return combine ( range_q ( lch ( v ), tl , tm , l , min ( r , tm )), range_q ( rch ( v ), tm + 1 , tr , max ( l , tm + 1 ), r )); } void point_upd ( int v , int tl , int tr , int pos , int new_val ) { if ( tl == tr ) { seg [ v ] = new_val ; } else { push ( v , tl , tr ); int tm = ( tl + tr ) & gt ; & gt ; 1 ; if ( pos & lt ; = tm ) point_upd ( lch ( v ), tl , tm , pos , new_val ); else point_upd ( rch ( v ), tm + 1 , tr , pos , new_val ); seg [ v ] = combine ( seg [ lch ( v )], seg [ rch ( v )]); } } void range_upd ( int v , int tl , int tr , int l , int r , int add ) { if ( l & gt ; r ) return ; if ( tl == l & amp ; & amp ; tr == r ) { seg [ v ] += add * ( r - l + 1 ); lazy [ v ] += add ; } else { push ( v , tl , tr ); int tm = ( tl + tr ) & gt ; & gt ; 1 ; range_upd ( lch ( v ), tl , tm , l , min ( r , tm ), add ); range_upd ( rch ( v ), tm + 1 , tr , max ( l , tm + 1 ), r , add ); seg [ v ] = combine ( seg [ lch ( v )], seg [ rch ( v )]); } }","title":"Segment tree"},{"location":"data-structures/segment-tree/#implementation","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 constexpr int MAXN = 1e5 + 5 ; int N , A [ MAXN ]; int seg [ 4 * MAXN ], lazy [ 4 * MAXN ]; inline int lch ( int v ) { return 2 * v ; } inline int rch ( int v ) { return 2 * v + 1 ; } inline int combine ( int a , int b ) { return a + b ; } inline void push ( int v , int l , int r ) { int m = ( l + r ) & gt ; & gt ; 1 ; seg [ lch ( v )] += ( m - l + 1 ) * lazy [ v ]; seg [ rch ( v )] += ( r - m ) * lazy [ v ]; lazy [ lch ( v )] += lazy [ v ]; lazy [ rch ( v )] += lazy [ v ]; lazy [ v ] = 0 ; } void build ( int v , int tl , int tr ) { if ( tl == tr ) { seg [ v ] = A [ tl ]; } else { int tm = ( tl + tr ) & gt ; & gt ; 1 ; build ( lch ( v ), tl , tm ); build ( rch ( v ), tm + 1 , tr ); seg [ v ] = combine ( seg [ lch ( v )], seg [ rch ( v )]); } } int range_q ( int v , int tl , int tr , int l , int r ) { if ( l & gt ; r ) return 0 ; if ( l == tl & amp ; & amp ; r == tr ) return seg [ v ]; push ( v , tl , tr ); int tm = ( tl + tr ) & gt ; & gt ; 1 ; return combine ( range_q ( lch ( v ), tl , tm , l , min ( r , tm )), range_q ( rch ( v ), tm + 1 , tr , max ( l , tm + 1 ), r )); } void point_upd ( int v , int tl , int tr , int pos , int new_val ) { if ( tl == tr ) { seg [ v ] = new_val ; } else { push ( v , tl , tr ); int tm = ( tl + tr ) & gt ; & gt ; 1 ; if ( pos & lt ; = tm ) point_upd ( lch ( v ), tl , tm , pos , new_val ); else point_upd ( rch ( v ), tm + 1 , tr , pos , new_val ); seg [ v ] = combine ( seg [ lch ( v )], seg [ rch ( v )]); } } void range_upd ( int v , int tl , int tr , int l , int r , int add ) { if ( l & gt ; r ) return ; if ( tl == l & amp ; & amp ; tr == r ) { seg [ v ] += add * ( r - l + 1 ); lazy [ v ] += add ; } else { push ( v , tl , tr ); int tm = ( tl + tr ) & gt ; & gt ; 1 ; range_upd ( lch ( v ), tl , tm , l , min ( r , tm ), add ); range_upd ( rch ( v ), tm + 1 , tr , max ( l , tm + 1 ), r , add ); seg [ v ] = combine ( seg [ lch ( v )], seg [ rch ( v )]); } }","title":"Implementation"},{"location":"graph/","text":"Graph \u00b6","title":"Home"},{"location":"graph/#graph","text":"","title":"Graph"},{"location":"misc/","text":"Miscellaneous \u00b6","title":"Home"},{"location":"misc/#miscellaneous","text":"","title":"Miscellaneous"},{"location":"string/","text":"String \u00b6","title":"Home"},{"location":"string/#string","text":"","title":"String"}]}