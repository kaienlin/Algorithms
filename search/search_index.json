{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Computer Science Note \u00b6 The documentation in this site is for: organize my knowledge better create a better view of what I have learned Courses \u00b6 This area mostly contains homework assignments, sometimes with some class notes. Algorithms \u00b6 My own implementation of some algorithms, mainly in C++. Miscellaneous \u00b6 Things that are hard to categorized, like Latex, Linux....","title":"Home"},{"location":"#computer-science-note","text":"The documentation in this site is for: organize my knowledge better create a better view of what I have learned","title":"Computer Science Note"},{"location":"#courses","text":"This area mostly contains homework assignments, sometimes with some class notes.","title":"Courses"},{"location":"#algorithms","text":"My own implementation of some algorithms, mainly in C++.","title":"Algorithms"},{"location":"#miscellaneous","text":"Things that are hard to categorized, like Latex, Linux....","title":"Miscellaneous"},{"location":"about/","text":"Author \u00b6 Department of Computer Science and Information Engineering in National Taiwan University That's all(?)","title":"About"},{"location":"about/#author","text":"Department of Computer Science and Information Engineering in National Taiwan University That's all(?)","title":"Author"},{"location":"algorithms/","text":"Algorithms \u00b6 Data Structures \u00b6 Segment Tree Graph \u00b6 Depth First Search","title":"Algorithms"},{"location":"algorithms/#algorithms","text":"","title":"Algorithms"},{"location":"algorithms/#data-structures","text":"Segment Tree","title":"Data Structures"},{"location":"algorithms/#graph","text":"Depth First Search","title":"Graph"},{"location":"algorithms/dfs/","text":"Depth First Search \u00b6 Basic DFS \u00b6 constexpr int MAXN = 1e3 + 5 ; int N ; vector < int > G [ MAXN ]; int color [ MAXN ], tin [ MAXN ], tout [ MAXN ], timer ; const int WHITE = 0 , GREY = 1 , BLACK = 2 ; void is_back_edge ( int from , int to ) {} void is_cross_edge ( int from , int to ) {} bool is_ancestor ( int anc , int des ) { return tin [ anc ] < tin [ des ] && tout [ anc ] > tout [ des ]; } void dfs_util ( int v ) { color [ v ] = GREY ; tin [ v ] = timer ++ ; for ( int u : G [ v ] ) { if ( color [ u ] == WHITE ) dfs_util ( u ); else if ( color [ u ] == GREY ) is_back_edge ( v , u ); else if ( color [ u ] == BLACK ) is_cross_edge ( v , u ); } color [ v ] = BLACK ; tout [ v ] = timer ++ ; } void dfs () { fill ( color , color + N , WHITE ); timer = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( color [ i ] == WHITE ) dfs_util ( i ); } Topological Sort \u00b6 Find bridge \u00b6","title":"Depth First Search"},{"location":"algorithms/dfs/#depth-first-search","text":"","title":"Depth First Search"},{"location":"algorithms/dfs/#basic-dfs","text":"constexpr int MAXN = 1e3 + 5 ; int N ; vector < int > G [ MAXN ]; int color [ MAXN ], tin [ MAXN ], tout [ MAXN ], timer ; const int WHITE = 0 , GREY = 1 , BLACK = 2 ; void is_back_edge ( int from , int to ) {} void is_cross_edge ( int from , int to ) {} bool is_ancestor ( int anc , int des ) { return tin [ anc ] < tin [ des ] && tout [ anc ] > tout [ des ]; } void dfs_util ( int v ) { color [ v ] = GREY ; tin [ v ] = timer ++ ; for ( int u : G [ v ] ) { if ( color [ u ] == WHITE ) dfs_util ( u ); else if ( color [ u ] == GREY ) is_back_edge ( v , u ); else if ( color [ u ] == BLACK ) is_cross_edge ( v , u ); } color [ v ] = BLACK ; tout [ v ] = timer ++ ; } void dfs () { fill ( color , color + N , WHITE ); timer = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( color [ i ] == WHITE ) dfs_util ( i ); }","title":"Basic DFS"},{"location":"algorithms/dfs/#topological-sort","text":"","title":"Topological Sort"},{"location":"algorithms/dfs/#find-bridge","text":"","title":"Find bridge"},{"location":"algorithms/segment-tree/","text":"Implementation \u00b6 struct SegTree { constexpr static int MAXN = 1e5 + 5 ; int N ; int A [ MAXN ]; int T [ 4 * MAXN ], tag [ 4 * MAXN ]; void init ( int _N ) { N = _N ; } int lch ( int v ) { return v << 1 ; } int rch ( int v ) { return ( v << 1 ) | 1 ; } int combine ( int a , int b ) { return a + b ; } void pull ( int v ) { T [ v ] = combine ( T [ lch ( v )], T [ rch ( v )]); } void push ( int v , int l , int r ) { if ( tag [ v ] ) { int m = ( l + r ) >> 1 , lc = lch ( v ), rc = rch ( v ); T [ lc ] += ( m - l + 1 ) * tag [ v ]; T [ rc ] += ( r - m ) * tag [ v ]; tag [ lc ] += tag [ v ]; tag [ rc ] += tag [ v ]; tag [ v ] = 0 ; } } void build ( int v , int tl , int tr ) { if ( tl == tr ) { T [ v ] = A [ tl ]; } else { int tm = ( tl + tr ) >> 1 ; build ( lch ( v ), tl , tm ); build ( rch ( v ), tm + 1 , tr ); pull ( v ); } } int qry ( int v , int tl , int tr , int l , int r ) { if ( l > tr || r < tl ) return 0 ; if ( l <= tl && r >= tr ) return T [ v ]; int tm = ( tl + tr ) >> 1 ; push ( v , tl , tr ); return combine ( qry ( lch ( v ), tl , tm , l , r ), qry ( rch ( v ), tm + 1 , tr , l , r )); } void upd ( int v , int tl , int tr , int l , int r , int add ) { if ( l > tr || r < tl ) return ; if ( l <= tl && r >= tr ) { tag [ v ] += add ; T [ v ] += add * ( r - l + 1 ); return ; } int tm = ( tl + tr ) >> 1 ; push ( v , tl , tr ); upd ( lch ( v ), tl , tm , l , r , add ); upd ( rch ( v ), tm + 1 , tr , l , r , add ); pull ( v ); } } seg ;","title":"Segment tree"},{"location":"algorithms/segment-tree/#implementation","text":"struct SegTree { constexpr static int MAXN = 1e5 + 5 ; int N ; int A [ MAXN ]; int T [ 4 * MAXN ], tag [ 4 * MAXN ]; void init ( int _N ) { N = _N ; } int lch ( int v ) { return v << 1 ; } int rch ( int v ) { return ( v << 1 ) | 1 ; } int combine ( int a , int b ) { return a + b ; } void pull ( int v ) { T [ v ] = combine ( T [ lch ( v )], T [ rch ( v )]); } void push ( int v , int l , int r ) { if ( tag [ v ] ) { int m = ( l + r ) >> 1 , lc = lch ( v ), rc = rch ( v ); T [ lc ] += ( m - l + 1 ) * tag [ v ]; T [ rc ] += ( r - m ) * tag [ v ]; tag [ lc ] += tag [ v ]; tag [ rc ] += tag [ v ]; tag [ v ] = 0 ; } } void build ( int v , int tl , int tr ) { if ( tl == tr ) { T [ v ] = A [ tl ]; } else { int tm = ( tl + tr ) >> 1 ; build ( lch ( v ), tl , tm ); build ( rch ( v ), tm + 1 , tr ); pull ( v ); } } int qry ( int v , int tl , int tr , int l , int r ) { if ( l > tr || r < tl ) return 0 ; if ( l <= tl && r >= tr ) return T [ v ]; int tm = ( tl + tr ) >> 1 ; push ( v , tl , tr ); return combine ( qry ( lch ( v ), tl , tm , l , r ), qry ( rch ( v ), tm + 1 , tr , l , r )); } void upd ( int v , int tl , int tr , int l , int r , int add ) { if ( l > tr || r < tl ) return ; if ( l <= tl && r >= tr ) { tag [ v ] += add ; T [ v ] += add * ( r - l + 1 ); return ; } int tm = ( tl + tr ) >> 1 ; push ( v , tl , tr ); upd ( lch ( v ), tl , tm , l , r , add ); upd ( rch ( v ), tm + 1 , tr , l , r , add ); pull ( v ); } } seg ;","title":"Implementation"},{"location":"courses/","text":"Courses \u00b6 Fall, 2019 \u00b6 Algorithm Design and Analysis System Programming Spring, 2019 \u00b6 Data Structures and Algorithms Network Administration and System Administration","title":"Courses"},{"location":"courses/#courses","text":"","title":"Courses"},{"location":"courses/#fall-2019","text":"Algorithm Design and Analysis System Programming","title":"Fall, 2019"},{"location":"courses/#spring-2019","text":"Data Structures and Algorithms Network Administration and System Administration","title":"Spring, 2019"},{"location":"courses/ada-fall-2019/","text":"Algorithm Design and Analysis \u00b6 Instructor: Hsu-Chun Hsiao \u856d\u65ed\u541b Homework 1 \u00b6 Topics: Divide & Conquer, Dynamic Programming Programming Part: ADA Meetup Maximum Subarray Revisited Good Subpermutations Different Strings Hand-written Part: PDF file Homework 2 \u00b6 Topics: Dynamic Programming, Greedy Algorithm Programming Part: Line of Battle Chunithm Pokemon GO Weigh Anchor Hand-written Part: PDF file Homework 3 \u00b6 Topics: Graph Programming Part: Idol Master! Traveling Pony Problem Magic Song Hand-written Part: PDF file Homework 4 \u00b6 Topics: NP-Completeness Programming Part: Loopy Tippy Reachability Coefficient Yet Another Permutation Problem Hex Hand-written Part: PDF file","title":"Algorithm Design and Analysis"},{"location":"courses/ada-fall-2019/#algorithm-design-and-analysis","text":"Instructor: Hsu-Chun Hsiao \u856d\u65ed\u541b","title":"Algorithm Design and Analysis"},{"location":"courses/ada-fall-2019/#homework-1","text":"Topics: Divide & Conquer, Dynamic Programming Programming Part: ADA Meetup Maximum Subarray Revisited Good Subpermutations Different Strings Hand-written Part: PDF file","title":"Homework 1"},{"location":"courses/ada-fall-2019/#homework-2","text":"Topics: Dynamic Programming, Greedy Algorithm Programming Part: Line of Battle Chunithm Pokemon GO Weigh Anchor Hand-written Part: PDF file","title":"Homework 2"},{"location":"courses/ada-fall-2019/#homework-3","text":"Topics: Graph Programming Part: Idol Master! Traveling Pony Problem Magic Song Hand-written Part: PDF file","title":"Homework 3"},{"location":"courses/ada-fall-2019/#homework-4","text":"Topics: NP-Completeness Programming Part: Loopy Tippy Reachability Coefficient Yet Another Permutation Problem Hex Hand-written Part: PDF file","title":"Homework 4"},{"location":"courses/ada-fall-2019/hw1/ada-meetup/","text":"ADA Meetup \u00b6 Problem Description \u00b6 Yun-Nung (Vivian) Chen's website Concept \u00b6 \u96e2\u6563\u5316 BIT Code \u00b6 #include <bits/stdc++.h> #define IOS {ios::sync_with_stdio(false);cin.tie(nullptr);} #pragma GCC optimize(\"Ofast\", \"no-stack-protector\", \"unroll-loops\") #pragma GCC optimize(\"no-stack-protector\") #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,sse4.2,popcnt,abm,mmx,avx,tune=native\") #pragma GCC diagnostic ignored \"-W\" using namespace std ; using LL = int64_t ; using ULL = uint64_t ; using LD = long double ; // input optimize inline int read_char () { constexpr int N = 1 << 20 ; static char buf [ N ]; static char * p = buf , * end = buf ; if ( p == end ) { if ( ( end = buf + fread ( buf , 1 , N , stdin )) == buf ) return EOF ; p = buf ; } return * p ++ ; } inline int read_int ( int & x ) { static char c , neg ; while ( ( c = read_char ()) < '-' ) if ( c == EOF ) return 0 ; neg = ( c == '-' ) ? - 1 : 1 ; x = ( neg == 1 ) ? c - '0' : 0 ; while ( ( c = read_char ()) >= '0' ) x = ( x << 3 ) + ( x << 1 ) + ( c - '0' ); x *= neg ; return 1 ; } const int MAXN = 1e6 + 5 ; int N ; int P [ MAXN ], F [ MAXN ], * ptr [ MAXN ], mp [ MAXN ]; bool cmp ( int * a , int * b ) { return * a < * b ; } int bit [ MAXN ]; inline int lowbit ( int x ) { return x & - x ; } int sum ( int idx ) { int ret = 0 ; for ( ; idx > 0 ; idx -= lowbit ( idx ) ) ret += bit [ idx ]; return ret ; } inline int sum ( int L , int R ) { if ( L < 1 ) L = 1 ; return sum ( R ) - sum ( L - 1 ); } void add ( int idx , int delta , int n ) { for ( ; idx <= n ; idx += lowbit ( idx ) ) bit [ idx ] += delta ; } int main () { read_int ( N ); for ( int i = 1 ; i <= N ; i ++ ) read_int ( P [ i ]); for ( int i = 1 ; i <= N ; i ++ ) read_int ( F [ i ]); for ( int i = 1 ; i <= N ; i ++ ) ptr [ i ] = & P [ i ]; sort ( ptr + 1 , ptr + N + 1 , cmp ); int n = 0 ; for ( int i = 1 ; i <= N ; ) { int v = * ptr [ i ]; ++ n ; for ( ; i <= N && * ptr [ i ] == v ; i ++ ) mp [ ptr [ i ] - P ] = n ; } long long ans = 0 ; add ( mp [ 1 ], 1 , n ); for ( int i = 2 ; i <= N ; i ++ ) { int lb = P [ i ] - F [ i ], ub = P [ i ] + F [ i ]; auto ll = lower_bound ( ptr + 1 , ptr + 1 + N , & lb , cmp ); auto rr = upper_bound ( ptr + 1 , ptr + 1 + N , & ub , cmp ) - 1 ; lb = mp [ * ll - P ]; ub = mp [ * rr - P ]; ans += sum ( lb , ub ); add ( mp [ i ], 1 , n ); } printf ( \"%lld \\n \" , ans ); return 0 ; } Tricks \u00b6 Just use GNU policy based data structures","title":"ADA Meetup"},{"location":"courses/ada-fall-2019/hw1/ada-meetup/#ada-meetup","text":"","title":"ADA Meetup"},{"location":"courses/ada-fall-2019/hw1/ada-meetup/#problem-description","text":"Yun-Nung (Vivian) Chen's website","title":"Problem Description"},{"location":"courses/ada-fall-2019/hw1/ada-meetup/#concept","text":"\u96e2\u6563\u5316 BIT","title":"Concept"},{"location":"courses/ada-fall-2019/hw1/ada-meetup/#code","text":"#include <bits/stdc++.h> #define IOS {ios::sync_with_stdio(false);cin.tie(nullptr);} #pragma GCC optimize(\"Ofast\", \"no-stack-protector\", \"unroll-loops\") #pragma GCC optimize(\"no-stack-protector\") #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,sse4.2,popcnt,abm,mmx,avx,tune=native\") #pragma GCC diagnostic ignored \"-W\" using namespace std ; using LL = int64_t ; using ULL = uint64_t ; using LD = long double ; // input optimize inline int read_char () { constexpr int N = 1 << 20 ; static char buf [ N ]; static char * p = buf , * end = buf ; if ( p == end ) { if ( ( end = buf + fread ( buf , 1 , N , stdin )) == buf ) return EOF ; p = buf ; } return * p ++ ; } inline int read_int ( int & x ) { static char c , neg ; while ( ( c = read_char ()) < '-' ) if ( c == EOF ) return 0 ; neg = ( c == '-' ) ? - 1 : 1 ; x = ( neg == 1 ) ? c - '0' : 0 ; while ( ( c = read_char ()) >= '0' ) x = ( x << 3 ) + ( x << 1 ) + ( c - '0' ); x *= neg ; return 1 ; } const int MAXN = 1e6 + 5 ; int N ; int P [ MAXN ], F [ MAXN ], * ptr [ MAXN ], mp [ MAXN ]; bool cmp ( int * a , int * b ) { return * a < * b ; } int bit [ MAXN ]; inline int lowbit ( int x ) { return x & - x ; } int sum ( int idx ) { int ret = 0 ; for ( ; idx > 0 ; idx -= lowbit ( idx ) ) ret += bit [ idx ]; return ret ; } inline int sum ( int L , int R ) { if ( L < 1 ) L = 1 ; return sum ( R ) - sum ( L - 1 ); } void add ( int idx , int delta , int n ) { for ( ; idx <= n ; idx += lowbit ( idx ) ) bit [ idx ] += delta ; } int main () { read_int ( N ); for ( int i = 1 ; i <= N ; i ++ ) read_int ( P [ i ]); for ( int i = 1 ; i <= N ; i ++ ) read_int ( F [ i ]); for ( int i = 1 ; i <= N ; i ++ ) ptr [ i ] = & P [ i ]; sort ( ptr + 1 , ptr + N + 1 , cmp ); int n = 0 ; for ( int i = 1 ; i <= N ; ) { int v = * ptr [ i ]; ++ n ; for ( ; i <= N && * ptr [ i ] == v ; i ++ ) mp [ ptr [ i ] - P ] = n ; } long long ans = 0 ; add ( mp [ 1 ], 1 , n ); for ( int i = 2 ; i <= N ; i ++ ) { int lb = P [ i ] - F [ i ], ub = P [ i ] + F [ i ]; auto ll = lower_bound ( ptr + 1 , ptr + 1 + N , & lb , cmp ); auto rr = upper_bound ( ptr + 1 , ptr + 1 + N , & ub , cmp ) - 1 ; lb = mp [ * ll - P ]; ub = mp [ * rr - P ]; ans += sum ( lb , ub ); add ( mp [ i ], 1 , n ); } printf ( \"%lld \\n \" , ans ); return 0 ; }","title":"Code"},{"location":"courses/ada-fall-2019/hw1/ada-meetup/#tricks","text":"Just use GNU policy based data structures","title":"Tricks"},{"location":"courses/ada-fall-2019/hw1/different-strings/","text":"Maximum Subarray Revisited \u00b6 Problem Description \u00b6 Yun-Nung (Vivian) Chen's website Concept \u00b6 Reversed Edit Distance Problem Code \u00b6 #include <bits/stdc++.h> #define IOS {ios::sync_with_stdio(false);cin.tie(nullptr);} #define gc getchar_unlocked() #pragma GCC optimize(\"Ofast\", \"no-stack-protector\", \"unroll-loops\") #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,sse4.2,popcnt,abm,mmx,avx,tune=native\") using namespace std ; const int MAXL = 2001 ; int na , nb ; char Sa [ MAXL ], Sb [ MAXL ]; int dp [ MAXL ][ MAXL ]; inline int min ( int a , int b ) { return a < b ? a : b ; } int main () { while ( ( Sa [ na ] = gc ) != '\\n' ) ++ na ; while ( ( Sb [ nb ] = gc ) >= 'A' ) ++ nb ; for ( int a = na - 1 ; a >= 0 ; -- a ) { for ( int b = nb - 1 ; b >= 0 ; -- b ) { if ( Sa [ a ] == Sb [ b ] ) dp [ a ][ b ] = 1 + min ( dp [ a + 1 ][ b + 1 ], min ( dp [ a ][ b + 1 ], dp [ a + 1 ][ b ])); else dp [ a ][ b ] = dp [ a + 1 ][ b + 1 ]; } } cout << dp [ 0 ][ 0 ]; return 0 ; }","title":"Maximum Subarray Revisited"},{"location":"courses/ada-fall-2019/hw1/different-strings/#maximum-subarray-revisited","text":"","title":"Maximum Subarray Revisited"},{"location":"courses/ada-fall-2019/hw1/different-strings/#problem-description","text":"Yun-Nung (Vivian) Chen's website","title":"Problem Description"},{"location":"courses/ada-fall-2019/hw1/different-strings/#concept","text":"Reversed Edit Distance Problem","title":"Concept"},{"location":"courses/ada-fall-2019/hw1/different-strings/#code","text":"#include <bits/stdc++.h> #define IOS {ios::sync_with_stdio(false);cin.tie(nullptr);} #define gc getchar_unlocked() #pragma GCC optimize(\"Ofast\", \"no-stack-protector\", \"unroll-loops\") #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,sse4.2,popcnt,abm,mmx,avx,tune=native\") using namespace std ; const int MAXL = 2001 ; int na , nb ; char Sa [ MAXL ], Sb [ MAXL ]; int dp [ MAXL ][ MAXL ]; inline int min ( int a , int b ) { return a < b ? a : b ; } int main () { while ( ( Sa [ na ] = gc ) != '\\n' ) ++ na ; while ( ( Sb [ nb ] = gc ) >= 'A' ) ++ nb ; for ( int a = na - 1 ; a >= 0 ; -- a ) { for ( int b = nb - 1 ; b >= 0 ; -- b ) { if ( Sa [ a ] == Sb [ b ] ) dp [ a ][ b ] = 1 + min ( dp [ a + 1 ][ b + 1 ], min ( dp [ a ][ b + 1 ], dp [ a + 1 ][ b ])); else dp [ a ][ b ] = dp [ a + 1 ][ b + 1 ]; } } cout << dp [ 0 ][ 0 ]; return 0 ; }","title":"Code"},{"location":"courses/ada-fall-2019/hw1/good-subpermutations/","text":"Maximum Subarray Revisited \u00b6 Problem Description \u00b6 Yun-Nung (Vivian) Chen's website Concept \u00b6 This problem is so difficult...... Code \u00b6 #include <bits/stdc++.h> #define IOS {ios::sync_with_stdio(false);cin.tie(nullptr);} #pragma GCC optimize(\"Ofast\", \"no-stack-protector\", \"unroll-loops\") #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,sse4.2,popcnt,abm,mmx,avx,tune=native\") using namespace std ; using LL = long long ; inline int read_char (); inline int read_int ( int & ); const int MAXN = 5e5 + 5 , NN = 1e6 + 5 ; const int T = 40 ; int N , A [ MAXN ], Mx [ MAXN ], Mn [ MAXN ]; int cnt [ NN ], cnt2 [ NN ]; LL Ans ; void solve ( int L , int R ) { if ( L == R ) return void ( ++ Ans ); if ( R - L <= T ) { for ( int l = L ; l <= R ; l ++ ) { int mx = A [ l ], mn = A [ l ]; for ( int r = l ; r <= R ; r ++ ) { mx = max ( mx , A [ r ]); mn = min ( mn , A [ r ]); Ans += ( mx - mn == r - l ); } } return ; } // D & C int m = ( L + R ) >> 1 ; solve ( L , m ); solve ( m + 1 , R ); // preprocess Mx [ m ] = Mn [ m ] = A [ m ]; for ( int i = m - 1 ; i >= L ; i -- ) Mx [ i ] = max ( Mx [ i + 1 ], A [ i ]), Mn [ i ] = min ( Mn [ i + 1 ], A [ i ]); Mx [ m + 1 ] = Mn [ m + 1 ] = A [ m + 1 ]; cnt [ Mn [ m + 1 ] + m + 1 ] = cnt2 [ Mx [ m + 1 ] - m - 1 + N ] = 0 ; for ( int i = m + 2 ; i <= R ; i ++ ) { Mx [ i ] = max ( Mx [ i - 1 ], A [ i ]), Mn [ i ] = min ( Mn [ i - 1 ], A [ i ]); cnt [ Mn [ i ] + i ] = cnt2 [ Mx [ i ] - i + N ] = 0 ; } // cross subarray int pmx = m , pmn = m ; for ( int r = m + 1 ; r <= R ; r ++ ) { int mx_r = Mx [ r ], mn_r = Mn [ r ]; for ( ; pmx >= L && Mx [ pmx ] < mx_r ; pmx -- ) { -- cnt [ Mx [ pmx ] + pmx ]; ++ cnt2 [ Mn [ pmx ] - pmx + N ]; } for ( ; pmn >= L && Mn [ pmn ] > mn_r ; pmn -- ) { ++ cnt [ Mx [ pmn ] + pmn ]; -- cnt2 [ Mn [ pmn ] - pmn + N ]; } if ( pmn < pmx ) Ans += cnt [ mn_r + r ]; else Ans += cnt2 [ mx_r - r + N ]; int idx = r - ( mx_r - mn_r ); Ans += ( idx <= m && idx > max ( pmx , pmn ) ); } for ( int l = m ; l >= L ; l -- ) { int idx = l + ( Mx [ l ] - Mn [ l ]); Ans += ( idx <= R && idx >= m + 1 && Mx [ idx ] < Mx [ l ] && Mn [ idx ] > Mn [ l ] ); } } int main () { IOS ; read_int ( N ); for ( int i = 1 ; i <= N ; i ++ ) read_int ( A [ i ]); solve ( 1 , N ); printf ( \"%lld \\n \" , Ans ); return 0 ; } // input optimize inline int read_char () { constexpr int N = 1 << 20 ; static char buf [ N ]; static char * p = buf , * end = buf ; if ( p == end ) { if ( ( end = buf + fread_unlocked ( buf , 1 , N , stdin )) == buf ) return EOF ; p = buf ; } return * p ++ ; } inline int read_int ( int & x ) { static char c , neg ; while ( ( c = read_char ()) < '-' ) if ( c == EOF ) return 0 ; neg = ( c == '-' ) ? - 1 : 1 ; x = ( neg == 1 ) ? c - '0' : 0 ; while ( ( c = read_char ()) >= '0' ) x = ( x << 3 ) + ( x << 1 ) + ( c - '0' ); x *= neg ; return 1 ; }","title":"Maximum Subarray Revisited"},{"location":"courses/ada-fall-2019/hw1/good-subpermutations/#maximum-subarray-revisited","text":"","title":"Maximum Subarray Revisited"},{"location":"courses/ada-fall-2019/hw1/good-subpermutations/#problem-description","text":"Yun-Nung (Vivian) Chen's website","title":"Problem Description"},{"location":"courses/ada-fall-2019/hw1/good-subpermutations/#concept","text":"This problem is so difficult......","title":"Concept"},{"location":"courses/ada-fall-2019/hw1/good-subpermutations/#code","text":"#include <bits/stdc++.h> #define IOS {ios::sync_with_stdio(false);cin.tie(nullptr);} #pragma GCC optimize(\"Ofast\", \"no-stack-protector\", \"unroll-loops\") #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,sse4.2,popcnt,abm,mmx,avx,tune=native\") using namespace std ; using LL = long long ; inline int read_char (); inline int read_int ( int & ); const int MAXN = 5e5 + 5 , NN = 1e6 + 5 ; const int T = 40 ; int N , A [ MAXN ], Mx [ MAXN ], Mn [ MAXN ]; int cnt [ NN ], cnt2 [ NN ]; LL Ans ; void solve ( int L , int R ) { if ( L == R ) return void ( ++ Ans ); if ( R - L <= T ) { for ( int l = L ; l <= R ; l ++ ) { int mx = A [ l ], mn = A [ l ]; for ( int r = l ; r <= R ; r ++ ) { mx = max ( mx , A [ r ]); mn = min ( mn , A [ r ]); Ans += ( mx - mn == r - l ); } } return ; } // D & C int m = ( L + R ) >> 1 ; solve ( L , m ); solve ( m + 1 , R ); // preprocess Mx [ m ] = Mn [ m ] = A [ m ]; for ( int i = m - 1 ; i >= L ; i -- ) Mx [ i ] = max ( Mx [ i + 1 ], A [ i ]), Mn [ i ] = min ( Mn [ i + 1 ], A [ i ]); Mx [ m + 1 ] = Mn [ m + 1 ] = A [ m + 1 ]; cnt [ Mn [ m + 1 ] + m + 1 ] = cnt2 [ Mx [ m + 1 ] - m - 1 + N ] = 0 ; for ( int i = m + 2 ; i <= R ; i ++ ) { Mx [ i ] = max ( Mx [ i - 1 ], A [ i ]), Mn [ i ] = min ( Mn [ i - 1 ], A [ i ]); cnt [ Mn [ i ] + i ] = cnt2 [ Mx [ i ] - i + N ] = 0 ; } // cross subarray int pmx = m , pmn = m ; for ( int r = m + 1 ; r <= R ; r ++ ) { int mx_r = Mx [ r ], mn_r = Mn [ r ]; for ( ; pmx >= L && Mx [ pmx ] < mx_r ; pmx -- ) { -- cnt [ Mx [ pmx ] + pmx ]; ++ cnt2 [ Mn [ pmx ] - pmx + N ]; } for ( ; pmn >= L && Mn [ pmn ] > mn_r ; pmn -- ) { ++ cnt [ Mx [ pmn ] + pmn ]; -- cnt2 [ Mn [ pmn ] - pmn + N ]; } if ( pmn < pmx ) Ans += cnt [ mn_r + r ]; else Ans += cnt2 [ mx_r - r + N ]; int idx = r - ( mx_r - mn_r ); Ans += ( idx <= m && idx > max ( pmx , pmn ) ); } for ( int l = m ; l >= L ; l -- ) { int idx = l + ( Mx [ l ] - Mn [ l ]); Ans += ( idx <= R && idx >= m + 1 && Mx [ idx ] < Mx [ l ] && Mn [ idx ] > Mn [ l ] ); } } int main () { IOS ; read_int ( N ); for ( int i = 1 ; i <= N ; i ++ ) read_int ( A [ i ]); solve ( 1 , N ); printf ( \"%lld \\n \" , Ans ); return 0 ; } // input optimize inline int read_char () { constexpr int N = 1 << 20 ; static char buf [ N ]; static char * p = buf , * end = buf ; if ( p == end ) { if ( ( end = buf + fread_unlocked ( buf , 1 , N , stdin )) == buf ) return EOF ; p = buf ; } return * p ++ ; } inline int read_int ( int & x ) { static char c , neg ; while ( ( c = read_char ()) < '-' ) if ( c == EOF ) return 0 ; neg = ( c == '-' ) ? - 1 : 1 ; x = ( neg == 1 ) ? c - '0' : 0 ; while ( ( c = read_char ()) >= '0' ) x = ( x << 3 ) + ( x << 1 ) + ( c - '0' ); x *= neg ; return 1 ; }","title":"Code"},{"location":"courses/ada-fall-2019/hw1/maximum-subarray-revisited/","text":"Maximum Subarray Revisited \u00b6 Problem Description \u00b6 Yun-Nung (Vivian) Chen's website Concept \u00b6 Store the process of divide and conquer (just as segment tree ) In each node representing [L, R] [L, R] , store 4 things: lmx = \\max\\limits_{L \\leq r \\leq R} \\sum_{i=L}^{r} A_i = \\max\\limits_{L \\leq r \\leq R} \\sum_{i=L}^{r} A_i rmx = \\max\\limits_{L \\leq \\ell \\leq R} \\sum_{i = \\ell}^{R} A_i = \\max\\limits_{L \\leq \\ell \\leq R} \\sum_{i = \\ell}^{R} A_i ans = \\max\\limits_{L \\leq \\ell \\leq r \\leq R} \\sum_{i = \\ell}^{r} A_i = \\max\\limits_{L \\leq \\ell \\leq r \\leq R} \\sum_{i = \\ell}^{r} A_i sum = \\sum_{i=L}^{R} A_i = \\sum_{i=L}^{R} A_i The \"merge\" step is as the code. Code \u00b6 #include <bits/stdc++.h> #define IOS {ios::sync_with_stdio(false);cin.tie(nullptr);} using namespace std ; using LL = int64_t ; using ULL = uint64_t ; using LD = long double ; inline int read_char (); inline int read_int ( int & ); inline void write_int ( LL ); constexpr int MAXN = 5e5 + 5 ; struct Item { LL lmx , rmx , sum , ans ; }; int N , A [ MAXN ]; Item seg [ 4 * MAXN ]; inline int lch ( int v ) { return ( v << 1 ); } inline int rch ( int v ) { return ( v << 1 ) | 1 ; } inline void combine ( Item & v , Item & a , Item & b ) { v . sum = a . sum + b . sum ; v . lmx = max ( a . lmx , a . sum + b . lmx ); v . rmx = max ( b . rmx , b . sum + a . rmx ); v . ans = max ( a . rmx + b . lmx , max ( a . ans , b . ans )); } void build ( int v , int tl , int tr ) { if ( tl == tr ) { seg [ v ] = { A [ tl ], A [ tl ], A [ tl ], A [ tl ]}; } else { int tm = ( tl + tr ) >> 1 ; build ( lch ( v ), tl , tm ); build ( rch ( v ), tm + 1 , tr ); combine ( seg [ v ], seg [ lch ( v )], seg [ rch ( v )]); } } void pt_upd ( int v , int tl , int tr , int pos , int new_v ) { if ( tl == tr ) { seg [ v ] = { new_v , new_v , new_v , new_v }; } else { int tm = ( tl + tr ) >> 1 ; if ( pos <= tm ) pt_upd ( lch ( v ), tl , tm , pos , new_v ); else pt_upd ( rch ( v ), tm + 1 , tr , pos , new_v ); combine ( seg [ v ], seg [ lch ( v )], seg [ rch ( v )]); } } inline LL qry () { return seg [ 1 ]. ans < 0 ? 0 : seg [ 1 ]. ans ; } int main () { int Q ; read_int ( N ); read_int ( Q ); for ( int i = 1 ; i <= N ; i ++ ) read_int ( A [ i ]); build ( 1 , 1 , N ); write_int ( qry ()); while ( Q -- ) { int pos , v ; read_int ( pos ); read_int ( v ); pt_upd ( 1 , 1 , N , pos , v ); write_int ( qry ()); } return 0 ; } // input optimize inline int read_char () { constexpr int N = 1 << 20 ; static char buf [ N ]; static char * p = buf , * end = buf ; if ( p == end ) { if ( ( end = buf + fread ( buf , 1 , N , stdin )) == buf ) return EOF ; p = buf ; } return * p ++ ; } inline int read_int ( int & x ) { static char c , neg ; while ( ( c = read_char ()) < '-' ) if ( c == EOF ) return 0 ; neg = ( c == '-' ) ? - 1 : 1 ; x = ( neg == 1 ) ? c - '0' : 0 ; while ( ( c = read_char ()) >= '0' ) x = ( x << 3 ) + ( x << 1 ) + ( c - '0' ); x *= neg ; return 1 ; } // output optimize #define _pc putchar_unlocked char _buf [ 128 ]; inline void write_int ( LL x ) { if ( ! x ) { _pc ( '0' ); _pc ( '\\n' ); return ; } int t = 0 ; while ( x ) { _buf [ t ++ ] = x % 10 + '0' ; x /= 10 ; } while ( t -- ) _pc ( _buf [ t ]); _pc ( '\\n' ); } #undef _pc","title":"Maximum Subarray Revisited"},{"location":"courses/ada-fall-2019/hw1/maximum-subarray-revisited/#maximum-subarray-revisited","text":"","title":"Maximum Subarray Revisited"},{"location":"courses/ada-fall-2019/hw1/maximum-subarray-revisited/#problem-description","text":"Yun-Nung (Vivian) Chen's website","title":"Problem Description"},{"location":"courses/ada-fall-2019/hw1/maximum-subarray-revisited/#concept","text":"Store the process of divide and conquer (just as segment tree ) In each node representing [L, R] [L, R] , store 4 things: lmx = \\max\\limits_{L \\leq r \\leq R} \\sum_{i=L}^{r} A_i = \\max\\limits_{L \\leq r \\leq R} \\sum_{i=L}^{r} A_i rmx = \\max\\limits_{L \\leq \\ell \\leq R} \\sum_{i = \\ell}^{R} A_i = \\max\\limits_{L \\leq \\ell \\leq R} \\sum_{i = \\ell}^{R} A_i ans = \\max\\limits_{L \\leq \\ell \\leq r \\leq R} \\sum_{i = \\ell}^{r} A_i = \\max\\limits_{L \\leq \\ell \\leq r \\leq R} \\sum_{i = \\ell}^{r} A_i sum = \\sum_{i=L}^{R} A_i = \\sum_{i=L}^{R} A_i The \"merge\" step is as the code.","title":"Concept"},{"location":"courses/ada-fall-2019/hw1/maximum-subarray-revisited/#code","text":"#include <bits/stdc++.h> #define IOS {ios::sync_with_stdio(false);cin.tie(nullptr);} using namespace std ; using LL = int64_t ; using ULL = uint64_t ; using LD = long double ; inline int read_char (); inline int read_int ( int & ); inline void write_int ( LL ); constexpr int MAXN = 5e5 + 5 ; struct Item { LL lmx , rmx , sum , ans ; }; int N , A [ MAXN ]; Item seg [ 4 * MAXN ]; inline int lch ( int v ) { return ( v << 1 ); } inline int rch ( int v ) { return ( v << 1 ) | 1 ; } inline void combine ( Item & v , Item & a , Item & b ) { v . sum = a . sum + b . sum ; v . lmx = max ( a . lmx , a . sum + b . lmx ); v . rmx = max ( b . rmx , b . sum + a . rmx ); v . ans = max ( a . rmx + b . lmx , max ( a . ans , b . ans )); } void build ( int v , int tl , int tr ) { if ( tl == tr ) { seg [ v ] = { A [ tl ], A [ tl ], A [ tl ], A [ tl ]}; } else { int tm = ( tl + tr ) >> 1 ; build ( lch ( v ), tl , tm ); build ( rch ( v ), tm + 1 , tr ); combine ( seg [ v ], seg [ lch ( v )], seg [ rch ( v )]); } } void pt_upd ( int v , int tl , int tr , int pos , int new_v ) { if ( tl == tr ) { seg [ v ] = { new_v , new_v , new_v , new_v }; } else { int tm = ( tl + tr ) >> 1 ; if ( pos <= tm ) pt_upd ( lch ( v ), tl , tm , pos , new_v ); else pt_upd ( rch ( v ), tm + 1 , tr , pos , new_v ); combine ( seg [ v ], seg [ lch ( v )], seg [ rch ( v )]); } } inline LL qry () { return seg [ 1 ]. ans < 0 ? 0 : seg [ 1 ]. ans ; } int main () { int Q ; read_int ( N ); read_int ( Q ); for ( int i = 1 ; i <= N ; i ++ ) read_int ( A [ i ]); build ( 1 , 1 , N ); write_int ( qry ()); while ( Q -- ) { int pos , v ; read_int ( pos ); read_int ( v ); pt_upd ( 1 , 1 , N , pos , v ); write_int ( qry ()); } return 0 ; } // input optimize inline int read_char () { constexpr int N = 1 << 20 ; static char buf [ N ]; static char * p = buf , * end = buf ; if ( p == end ) { if ( ( end = buf + fread ( buf , 1 , N , stdin )) == buf ) return EOF ; p = buf ; } return * p ++ ; } inline int read_int ( int & x ) { static char c , neg ; while ( ( c = read_char ()) < '-' ) if ( c == EOF ) return 0 ; neg = ( c == '-' ) ? - 1 : 1 ; x = ( neg == 1 ) ? c - '0' : 0 ; while ( ( c = read_char ()) >= '0' ) x = ( x << 3 ) + ( x << 1 ) + ( c - '0' ); x *= neg ; return 1 ; } // output optimize #define _pc putchar_unlocked char _buf [ 128 ]; inline void write_int ( LL x ) { if ( ! x ) { _pc ( '0' ); _pc ( '\\n' ); return ; } int t = 0 ; while ( x ) { _buf [ t ++ ] = x % 10 + '0' ; x /= 10 ; } while ( t -- ) _pc ( _buf [ t ]); _pc ( '\\n' ); } #undef _pc","title":"Code"},{"location":"courses/ada-fall-2019/hw2/chunithm/","text":"Chunithm \u00b6 Problem Description \u00b6 Yun-Nung (Vivian) Chen's website Concept \u00b6 \u55ae\u8abf\u968a\u5217\u512a\u5316 Code \u00b6 #include <bits/stdc++.h> #define IOS {ios::sync_with_stdio(false);cin.tie(nullptr);} using namespace std ; using LL = long long ; using ULL = unsigned long long ; inline int read_int ( int & x ); constexpr int MAXN = 1e5 + 5 ; constexpr int MAXM = 300 + 5 ; // dp[i][j] = min(dp[i-1][k] + cost(k, j) + cost(note[i-1], note[i]), dp[i-1][k] + cost(k, note[i]) + cost(note[i-1], j)) for all 0 <= k < M int N , M , K ; int note [ MAXN ]; int _dp [ 2 ][ MAXM ]; inline int cost ( int i , int j ) { return max ( 0 , abs ( i - j ) - K ); } int main () { read_int ( N ); read_int ( M ); read_int ( K ); for ( int i = 1 ; i <= N ; i ++ ) read_int ( note [ i ]); int * dp = _dp [ 0 ], * dp2 = _dp [ 1 ]; int mn_b = 0 ; for ( int i = 2 ; i <= N ; i ++ ) { int mn_b_tmp = INT_MAX ; for ( int j = 0 ; j < M ; j ++ ) { int mn_a = min ( dp [ max ( 0 , j - K )], dp [ min ( M - 1 , j + K )]); dp2 [ j ] = min ( mn_a + cost ( note [ i - 1 ], note [ i ]), cost ( note [ i - 1 ], j ) + mn_b ); mn_b_tmp = min ( mn_b_tmp , dp2 [ j ] + cost ( j , note [ i + 1 ])); } mn_b = mn_b_tmp ; swap ( dp , dp2 ); } cout << * min_element ( dp , dp + M ) << '\\n' ; return 0 ; } // input optimize inline int read_char () { constexpr int N = 1 << 20 ; static char buf [ N ]; static char * p = buf , * end = buf ; if ( p == end ) { if ( ( end = buf + fread_unlocked ( buf , 1 , N , stdin )) == buf ) return EOF ; p = buf ; } return * p ++ ; } inline int read_int ( int & x ) { static char c , neg ; while ( ( c = read_char ()) < '-' ) if ( c == EOF ) return 0 ; neg = ( c == '-' ) ? - 1 : 1 ; x = ( neg == 1 ) ? c - '0' : 0 ; while ( ( c = read_char ()) >= '0' ) x = ( x << 3 ) + ( x << 1 ) + ( c - '0' ); x *= neg ; return 1 ; } // output optimize #define _pc putchar_unlocked char _buf [ 128 ]; inline void write_int ( LL x ) { if ( ! x ) { _pc ( '0' ); _pc ( '\\n' ); return ; } int t = 0 ; while ( x ) { _buf [ t ++ ] = x % 10 + '0' ; x /= 10 ; } while ( t -- ) _pc ( _buf [ t ]); _pc ( '\\n' ); } #undef _pc","title":"Chunithm"},{"location":"courses/ada-fall-2019/hw2/chunithm/#chunithm","text":"","title":"Chunithm"},{"location":"courses/ada-fall-2019/hw2/chunithm/#problem-description","text":"Yun-Nung (Vivian) Chen's website","title":"Problem Description"},{"location":"courses/ada-fall-2019/hw2/chunithm/#concept","text":"\u55ae\u8abf\u968a\u5217\u512a\u5316","title":"Concept"},{"location":"courses/ada-fall-2019/hw2/chunithm/#code","text":"#include <bits/stdc++.h> #define IOS {ios::sync_with_stdio(false);cin.tie(nullptr);} using namespace std ; using LL = long long ; using ULL = unsigned long long ; inline int read_int ( int & x ); constexpr int MAXN = 1e5 + 5 ; constexpr int MAXM = 300 + 5 ; // dp[i][j] = min(dp[i-1][k] + cost(k, j) + cost(note[i-1], note[i]), dp[i-1][k] + cost(k, note[i]) + cost(note[i-1], j)) for all 0 <= k < M int N , M , K ; int note [ MAXN ]; int _dp [ 2 ][ MAXM ]; inline int cost ( int i , int j ) { return max ( 0 , abs ( i - j ) - K ); } int main () { read_int ( N ); read_int ( M ); read_int ( K ); for ( int i = 1 ; i <= N ; i ++ ) read_int ( note [ i ]); int * dp = _dp [ 0 ], * dp2 = _dp [ 1 ]; int mn_b = 0 ; for ( int i = 2 ; i <= N ; i ++ ) { int mn_b_tmp = INT_MAX ; for ( int j = 0 ; j < M ; j ++ ) { int mn_a = min ( dp [ max ( 0 , j - K )], dp [ min ( M - 1 , j + K )]); dp2 [ j ] = min ( mn_a + cost ( note [ i - 1 ], note [ i ]), cost ( note [ i - 1 ], j ) + mn_b ); mn_b_tmp = min ( mn_b_tmp , dp2 [ j ] + cost ( j , note [ i + 1 ])); } mn_b = mn_b_tmp ; swap ( dp , dp2 ); } cout << * min_element ( dp , dp + M ) << '\\n' ; return 0 ; } // input optimize inline int read_char () { constexpr int N = 1 << 20 ; static char buf [ N ]; static char * p = buf , * end = buf ; if ( p == end ) { if ( ( end = buf + fread_unlocked ( buf , 1 , N , stdin )) == buf ) return EOF ; p = buf ; } return * p ++ ; } inline int read_int ( int & x ) { static char c , neg ; while ( ( c = read_char ()) < '-' ) if ( c == EOF ) return 0 ; neg = ( c == '-' ) ? - 1 : 1 ; x = ( neg == 1 ) ? c - '0' : 0 ; while ( ( c = read_char ()) >= '0' ) x = ( x << 3 ) + ( x << 1 ) + ( c - '0' ); x *= neg ; return 1 ; } // output optimize #define _pc putchar_unlocked char _buf [ 128 ]; inline void write_int ( LL x ) { if ( ! x ) { _pc ( '0' ); _pc ( '\\n' ); return ; } int t = 0 ; while ( x ) { _buf [ t ++ ] = x % 10 + '0' ; x /= 10 ; } while ( t -- ) _pc ( _buf [ t ]); _pc ( '\\n' ); } #undef _pc","title":"Code"},{"location":"courses/ada-fall-2019/hw2/line-of-battle/","text":"Line of Battle \u00b6 Problem Description \u00b6 Yun-Nung (Vivian) Chen's website Concept \u00b6 dynamic programming binary search Code \u00b6 #include <bits/stdc++.h> namespace ada { class Xoroshiro128 { public : using result_type = uint32_t ; static constexpr result_type ( min )() { return 0 ; } static constexpr result_type ( max )() { return UINT32_MAX ; } static inline result_type rotl ( const result_type x , int k ) { return ( x << k ) | ( x >> ( 32 - k )); } Xoroshiro128 () : Xoroshiro128 ( 1 , 2 , 3 , 4 ) {} Xoroshiro128 ( result_type a , result_type b , result_type c , result_type d ) : s { a , b , c , d } {} result_type operator ()() { const result_type result = rotl ( s [ 0 ] + s [ 3 ], 7 ) + s [ 0 ]; const result_type t = s [ 1 ] << 9 ; s [ 2 ] ^= s [ 0 ]; s [ 3 ] ^= s [ 1 ]; s [ 1 ] ^= s [ 2 ]; s [ 0 ] ^= s [ 3 ]; s [ 2 ] ^= t ; s [ 3 ] = rotl ( s [ 3 ], 11 ); return result ; } private : std :: array < result_type , 4 > s ; }; namespace { int c_lead , c_team ; Xoroshiro128 rng ; } // namespace int Init () { int n ; uint32_t s1 , s2 , s3 , s4 ; std :: cin >> n >> c_lead >> c_team >> s1 >> s2 >> s3 >> s4 ; rng = Xoroshiro128 ( s1 , s2 , s3 , s4 ); return n ; } int GetLeadership () { return uint64_t ( rng ()) * c_lead >> 32 ; } int GetTeamValue () { int tmp = int ( uint64_t ( rng ()) * c_team >> 32 ) + 1 ; return int ( c_team / sqrt ( tmp )); } } // namespace ada #define IOS {ios::sync_with_stdio(false);cin.tie(nullptr);} using namespace std ; using LL = int64_t ; using ULL = uint64_t ; using LD = long double ; using pii = pair < int , int > ; constexpr int MAXN = 2e6 + 5 ; constexpr int MOD = 1e9 + 7 ; int n ; int lead [ MAXN ], team [ MAXN ]; int dp [ MAXN ], dp2 [ MAXN ]; LL psum [ MAXN ]; int my_bsearch ( LL x ) { int l = 1 , r = n + 1 ; while ( l + 1 < r ) { int m = ( l + r ) >> 1 ; ( x < psum [ m ] ? r : l ) = m ; } return r ; } int main () { IOS ; n = ada :: Init (); for ( int i = 1 ; i <= n ; i ++ ) lead [ i ] = ada :: GetLeadership (); for ( int i = 1 ; i <= n ; i ++ ) team [ i ] = ada :: GetTeamValue (); for ( int i = 1 ; i <= n ; i ++ ) psum [ i ] = psum [ i - 1 ] + team [ i ]; dp2 [ n + 1 ] = 1 ; for ( int i = n ; i >= 1 ; i -- ) { int p = my_bsearch ( lead [ i ] + psum [ i ]); dp [ i ] = ( dp2 [ i + 1 ] - dp2 [ p + 1 ]); dp [ i ] += dp [ i ] < 0 ? MOD : 0 ; dp2 [ i ] = ( dp [ i ] + dp2 [ i + 1 ]); dp2 [ i ] -= dp2 [ i ] >= MOD ? MOD : 0 ; } cout << dp [ 1 ] << '\\n' ; return 0 ; }","title":"Line of Battle"},{"location":"courses/ada-fall-2019/hw2/line-of-battle/#line-of-battle","text":"","title":"Line of Battle"},{"location":"courses/ada-fall-2019/hw2/line-of-battle/#problem-description","text":"Yun-Nung (Vivian) Chen's website","title":"Problem Description"},{"location":"courses/ada-fall-2019/hw2/line-of-battle/#concept","text":"dynamic programming binary search","title":"Concept"},{"location":"courses/ada-fall-2019/hw2/line-of-battle/#code","text":"#include <bits/stdc++.h> namespace ada { class Xoroshiro128 { public : using result_type = uint32_t ; static constexpr result_type ( min )() { return 0 ; } static constexpr result_type ( max )() { return UINT32_MAX ; } static inline result_type rotl ( const result_type x , int k ) { return ( x << k ) | ( x >> ( 32 - k )); } Xoroshiro128 () : Xoroshiro128 ( 1 , 2 , 3 , 4 ) {} Xoroshiro128 ( result_type a , result_type b , result_type c , result_type d ) : s { a , b , c , d } {} result_type operator ()() { const result_type result = rotl ( s [ 0 ] + s [ 3 ], 7 ) + s [ 0 ]; const result_type t = s [ 1 ] << 9 ; s [ 2 ] ^= s [ 0 ]; s [ 3 ] ^= s [ 1 ]; s [ 1 ] ^= s [ 2 ]; s [ 0 ] ^= s [ 3 ]; s [ 2 ] ^= t ; s [ 3 ] = rotl ( s [ 3 ], 11 ); return result ; } private : std :: array < result_type , 4 > s ; }; namespace { int c_lead , c_team ; Xoroshiro128 rng ; } // namespace int Init () { int n ; uint32_t s1 , s2 , s3 , s4 ; std :: cin >> n >> c_lead >> c_team >> s1 >> s2 >> s3 >> s4 ; rng = Xoroshiro128 ( s1 , s2 , s3 , s4 ); return n ; } int GetLeadership () { return uint64_t ( rng ()) * c_lead >> 32 ; } int GetTeamValue () { int tmp = int ( uint64_t ( rng ()) * c_team >> 32 ) + 1 ; return int ( c_team / sqrt ( tmp )); } } // namespace ada #define IOS {ios::sync_with_stdio(false);cin.tie(nullptr);} using namespace std ; using LL = int64_t ; using ULL = uint64_t ; using LD = long double ; using pii = pair < int , int > ; constexpr int MAXN = 2e6 + 5 ; constexpr int MOD = 1e9 + 7 ; int n ; int lead [ MAXN ], team [ MAXN ]; int dp [ MAXN ], dp2 [ MAXN ]; LL psum [ MAXN ]; int my_bsearch ( LL x ) { int l = 1 , r = n + 1 ; while ( l + 1 < r ) { int m = ( l + r ) >> 1 ; ( x < psum [ m ] ? r : l ) = m ; } return r ; } int main () { IOS ; n = ada :: Init (); for ( int i = 1 ; i <= n ; i ++ ) lead [ i ] = ada :: GetLeadership (); for ( int i = 1 ; i <= n ; i ++ ) team [ i ] = ada :: GetTeamValue (); for ( int i = 1 ; i <= n ; i ++ ) psum [ i ] = psum [ i - 1 ] + team [ i ]; dp2 [ n + 1 ] = 1 ; for ( int i = n ; i >= 1 ; i -- ) { int p = my_bsearch ( lead [ i ] + psum [ i ]); dp [ i ] = ( dp2 [ i + 1 ] - dp2 [ p + 1 ]); dp [ i ] += dp [ i ] < 0 ? MOD : 0 ; dp2 [ i ] = ( dp [ i ] + dp2 [ i + 1 ]); dp2 [ i ] -= dp2 [ i ] >= MOD ? MOD : 0 ; } cout << dp [ 1 ] << '\\n' ; return 0 ; }","title":"Code"},{"location":"courses/ada-fall-2019/hw2/pokemon-go/","text":"Pokemon GO \u00b6 Problem Description \u00b6 Yun-Nung (Vivian) Chen's website Concept \u00b6 Knapsack Problem Code \u00b6 #include <bits/stdc++.h> #define IOS {ios::sync_with_stdio(false);cin.tie(nullptr);} #pragma GCC optimize(\"Ofast\", \"no-stack-protector\", \"unroll-loops\") #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,sse4.2,popcnt,abm,mmx,avx,tune=native\") using namespace std ; using LL = int64_t ; using ULL = uint64_t ; using LD = long double ; using pii = pair < int , int > ; constexpr int MAXB = 100 ; constexpr int MAXN = 105 ; constexpr int MAXK = 105 ; int dp [ MAXK ][ MAXB * MAXN ]; int A [ MAXN ], B [ MAXN ]; int N , K ; int main () { IOS ; cin >> N >> K ; for ( int i = 1 ; i <= N ; i ++ ) cin >> A [ i ] >> B [ i ]; vector < int > arr ; for ( int i = 1 ; i <= N ; i ++ ) { int mx = - 1 , mx_idx ; for ( int j = 0 ; j <= arr . size (); j ++ ) { int bsum = 0 ; for ( int k = 0 ; k < j ; k ++ ) bsum += B [ arr [ k ]]; int asum = 0 ; for ( int k = j ; k < arr . size (); k ++ ) asum += A [ arr [ k ]]; int val = asum * B [ i ] + bsum * A [ i ]; if ( val > mx ) { mx = val ; mx_idx = j ; } } if ( mx_idx == arr . size () ) arr . push_back ( i ); else arr . insert ( arr . begin () + mx_idx , i ); } memset ( dp , - 1 , sizeof ( dp )); dp [ 0 ][ 0 ] = 0 ; for ( int i : arr ) for ( int k = K - 1 ; k >= 0 ; k -- ) for ( int xp = 10000 - B [ i ]; xp >= 0 ; xp -- ) if ( dp [ k ][ xp ] != - 1 ) dp [ k + 1 ][ xp + B [ i ]] = max ( dp [ k + 1 ][ xp + B [ i ]], dp [ k ][ xp ] + A [ i ] * xp ); cout << * max_element ( dp [ K ], dp [ K ] + 10001 ) << '\\n' ; return 0 ; } // input optimize inline int read_char () { constexpr int N = 1 << 20 ; static char buf [ N ]; static char * p = buf , * end = buf ; if ( p == end ) { if ( ( end = buf + fread_unlocked ( buf , 1 , N , stdin )) == buf ) return EOF ; p = buf ; } return * p ++ ; } inline int read_int ( int & x ) { static char c , neg ; while ( ( c = read_char ()) < '-' ) if ( c == EOF ) return 0 ; neg = ( c == '-' ) ? - 1 : 1 ; x = ( neg == 1 ) ? c - '0' : 0 ; while ( ( c = read_char ()) >= '0' ) x = ( x << 3 ) + ( x << 1 ) + ( c - '0' ); x *= neg ; return 1 ; } // output optimize #define _pc putchar_unlocked char _buf [ 128 ]; inline void write_int ( LL x ) { if ( ! x ) { _pc ( '0' ); _pc ( '\\n' ); return ; } int t = 0 ; while ( x ) { _buf [ t ++ ] = x % 10 + '0' ; x /= 10 ; } while ( t -- ) _pc ( _buf [ t ]); _pc ( '\\n' ); } #undef _pc","title":"Pokemon GO"},{"location":"courses/ada-fall-2019/hw2/pokemon-go/#pokemon-go","text":"","title":"Pokemon GO"},{"location":"courses/ada-fall-2019/hw2/pokemon-go/#problem-description","text":"Yun-Nung (Vivian) Chen's website","title":"Problem Description"},{"location":"courses/ada-fall-2019/hw2/pokemon-go/#concept","text":"Knapsack Problem","title":"Concept"},{"location":"courses/ada-fall-2019/hw2/pokemon-go/#code","text":"#include <bits/stdc++.h> #define IOS {ios::sync_with_stdio(false);cin.tie(nullptr);} #pragma GCC optimize(\"Ofast\", \"no-stack-protector\", \"unroll-loops\") #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,sse4.2,popcnt,abm,mmx,avx,tune=native\") using namespace std ; using LL = int64_t ; using ULL = uint64_t ; using LD = long double ; using pii = pair < int , int > ; constexpr int MAXB = 100 ; constexpr int MAXN = 105 ; constexpr int MAXK = 105 ; int dp [ MAXK ][ MAXB * MAXN ]; int A [ MAXN ], B [ MAXN ]; int N , K ; int main () { IOS ; cin >> N >> K ; for ( int i = 1 ; i <= N ; i ++ ) cin >> A [ i ] >> B [ i ]; vector < int > arr ; for ( int i = 1 ; i <= N ; i ++ ) { int mx = - 1 , mx_idx ; for ( int j = 0 ; j <= arr . size (); j ++ ) { int bsum = 0 ; for ( int k = 0 ; k < j ; k ++ ) bsum += B [ arr [ k ]]; int asum = 0 ; for ( int k = j ; k < arr . size (); k ++ ) asum += A [ arr [ k ]]; int val = asum * B [ i ] + bsum * A [ i ]; if ( val > mx ) { mx = val ; mx_idx = j ; } } if ( mx_idx == arr . size () ) arr . push_back ( i ); else arr . insert ( arr . begin () + mx_idx , i ); } memset ( dp , - 1 , sizeof ( dp )); dp [ 0 ][ 0 ] = 0 ; for ( int i : arr ) for ( int k = K - 1 ; k >= 0 ; k -- ) for ( int xp = 10000 - B [ i ]; xp >= 0 ; xp -- ) if ( dp [ k ][ xp ] != - 1 ) dp [ k + 1 ][ xp + B [ i ]] = max ( dp [ k + 1 ][ xp + B [ i ]], dp [ k ][ xp ] + A [ i ] * xp ); cout << * max_element ( dp [ K ], dp [ K ] + 10001 ) << '\\n' ; return 0 ; } // input optimize inline int read_char () { constexpr int N = 1 << 20 ; static char buf [ N ]; static char * p = buf , * end = buf ; if ( p == end ) { if ( ( end = buf + fread_unlocked ( buf , 1 , N , stdin )) == buf ) return EOF ; p = buf ; } return * p ++ ; } inline int read_int ( int & x ) { static char c , neg ; while ( ( c = read_char ()) < '-' ) if ( c == EOF ) return 0 ; neg = ( c == '-' ) ? - 1 : 1 ; x = ( neg == 1 ) ? c - '0' : 0 ; while ( ( c = read_char ()) >= '0' ) x = ( x << 3 ) + ( x << 1 ) + ( c - '0' ); x *= neg ; return 1 ; } // output optimize #define _pc putchar_unlocked char _buf [ 128 ]; inline void write_int ( LL x ) { if ( ! x ) { _pc ( '0' ); _pc ( '\\n' ); return ; } int t = 0 ; while ( x ) { _buf [ t ++ ] = x % 10 + '0' ; x /= 10 ; } while ( t -- ) _pc ( _buf [ t ]); _pc ( '\\n' ); } #undef _pc","title":"Code"},{"location":"courses/ada-fall-2019/hw2/weigh-anchor/","text":"Weigh Anchor \u00b6 Problem Description \u00b6 Yun-Nung (Vivian) Chen's website Concept \u00b6 Greedy Code \u00b6 #include <bits/stdc++.h> #define IOS {ios::sync_with_stdio(false);cin.tie(nullptr);} using namespace std ; using LL = long long ; int read_int ( int & ); int main () { int N ; int s1 , s2 , s3 , s12 , s13 , s23 , s123 ; int c1 = 0 , c2 = 0 , c3 = 0 , c12 = 0 , c23 = 0 , c13 = 0 , c123 = 0 ; read_int ( N ); read_int ( s1 ); read_int ( s2 ); read_int ( s3 ); if ( s1 > s2 ) swap ( s1 , s2 ); if ( s2 > s3 ) swap ( s2 , s3 ); if ( s1 > s2 ) swap ( s1 , s2 ); s123 = s1 + s2 + s3 ; s12 = s1 + s2 , s13 = s1 + s3 , s23 = s2 + s3 ; int ans = 0 ; if ( s12 > s3 ) { bool fail = false ; for ( int i = 1 ; i <= N ; i ++ ) { int a ; read_int ( a ); if ( a <= s1 ) ++ c1 ; else if ( a <= s2 ) ++ c2 ; else if ( a <= s3 ) ++ c3 ; else if ( a <= s12 ) ++ c12 ; else if ( a <= s13 ) ++ c13 ; else if ( a <= s23 ) ++ c23 ; else if ( a <= s123 ) ++ c123 ; else fail = true ; } if ( fail ) { cout << \"-1 \\n \" ; return 0 ; } ans = c123 ; while ( c23 > 0 || c13 > 0 || c12 > 0 || c3 > 0 || c2 > 0 || c1 > 0 ) { if ( c23 > 0 ) { -- c23 ; if ( c1 > 0 ) -- c1 ; } else if ( c13 > 0 ) { -- c13 ; if ( c2 > 0 ) -- c2 ; else if ( c1 > 0 ) -- c1 ; } else if ( c12 > 0 ) { -- c12 ; if ( c3 > 0 ) -- c3 ; else if ( c2 > 0 ) -- c2 ; else if ( c1 > 0 ) -- c1 ; } else if ( c3 > 0 ) { -- c3 ; if ( c2 > 0 ) { -- c2 ; if ( c1 > 0 ) -- c1 ; } else if ( c1 > 0 ) { c1 -= 2 ; } else if ( c3 > 0 ) -- c3 ; // s12!! } else if ( c2 > 0 ) { -- c2 ; // s2 if ( c2 > 0 ) -- c2 ; // s3 else if ( c1 > 0 ) -- c1 ; // s3 if ( c1 > 0 ) -- c1 ; // s1 } else if ( c1 > 0 ) { c1 -= 3 ; } ++ ans ; } } else { bool fail = false ; for ( int i = 1 ; i <= N ; i ++ ) { int a ; read_int ( a ); if ( a <= s1 ) ++ c1 ; else if ( a <= s2 ) ++ c2 ; else if ( a <= s12 ) ++ c12 ; else if ( a <= s3 ) ++ c3 ; else if ( a <= s13 ) ++ c13 ; else if ( a <= s23 ) ++ c23 ; else if ( a <= s123 ) ++ c123 ; else fail = true ; } if ( fail ) { cout << \"-1 \\n \" ; return 0 ; } ans = c123 ; while ( c23 > 0 || c13 > 0 || c12 > 0 || c3 > 0 || c2 > 0 || c1 > 0 ) { if ( c23 > 0 ) { -- c23 ; if ( c1 > 0 ) -- c1 ; } else if ( c13 > 0 ) { -- c13 ; if ( c2 > 0 ) -- c2 ; // s2 else if ( c1 > 0 ) -- c1 ; // s2 } else if ( c3 > 0 ) { -- c3 ; if ( c2 > 0 ) { -- c2 ; // s2 if ( c1 > 0 ) -- c1 ; // s1 } else if ( c1 > 0 ) { c1 -= 2 ; // s1 , s2 } else if ( c12 > 0 ) -- c12 ; } else if ( c12 > 0 ) { -- c12 ; // s3 if ( c2 > 0 ) { -- c2 ; // s2 if ( c1 > 0 ) -- c1 ; } else if ( c1 > 0 ) { c1 -= 2 ; } else if ( c12 > 0 ) -- c12 ; } else if ( c2 > 0 ) { -- c2 ; // s2 if ( c2 > 0 ) -- c2 ; // s3 else if ( c1 > 0 ) -- c1 ; // s3 if ( c1 > 0 ) -- c1 ; // s1 } else if ( c1 > 0 ) { c1 -= 3 ; } ++ ans ; } } cout << ans << '\\n' ; return 0 ; } // input optimize inline int read_char () { constexpr int N = 1 << 20 ; static char buf [ N ]; static char * p = buf , * end = buf ; if ( p == end ) { if ( ( end = buf + fread_unlocked ( buf , 1 , N , stdin )) == buf ) return EOF ; p = buf ; } return * p ++ ; } inline int read_int ( int & x ) { static char c , neg ; while ( ( c = read_char ()) < '-' ) if ( c == EOF ) return 0 ; neg = ( c == '-' ) ? - 1 : 1 ; x = ( neg == 1 ) ? c - '0' : 0 ; while ( ( c = read_char ()) >= '0' ) x = ( x << 3 ) + ( x << 1 ) + ( c - '0' ); x *= neg ; return 1 ; } // output optimize #define _pc putchar_unlocked char _buf [ 128 ]; inline void write_int ( LL x ) { if ( ! x ) { _pc ( '0' ); _pc ( '\\n' ); return ; } int t = 0 ; while ( x ) { _buf [ t ++ ] = x % 10 + '0' ; x /= 10 ; } while ( t -- ) _pc ( _buf [ t ]); _pc ( '\\n' ); } #undef _pc","title":"Weigh Anchor"},{"location":"courses/ada-fall-2019/hw2/weigh-anchor/#weigh-anchor","text":"","title":"Weigh Anchor"},{"location":"courses/ada-fall-2019/hw2/weigh-anchor/#problem-description","text":"Yun-Nung (Vivian) Chen's website","title":"Problem Description"},{"location":"courses/ada-fall-2019/hw2/weigh-anchor/#concept","text":"Greedy","title":"Concept"},{"location":"courses/ada-fall-2019/hw2/weigh-anchor/#code","text":"#include <bits/stdc++.h> #define IOS {ios::sync_with_stdio(false);cin.tie(nullptr);} using namespace std ; using LL = long long ; int read_int ( int & ); int main () { int N ; int s1 , s2 , s3 , s12 , s13 , s23 , s123 ; int c1 = 0 , c2 = 0 , c3 = 0 , c12 = 0 , c23 = 0 , c13 = 0 , c123 = 0 ; read_int ( N ); read_int ( s1 ); read_int ( s2 ); read_int ( s3 ); if ( s1 > s2 ) swap ( s1 , s2 ); if ( s2 > s3 ) swap ( s2 , s3 ); if ( s1 > s2 ) swap ( s1 , s2 ); s123 = s1 + s2 + s3 ; s12 = s1 + s2 , s13 = s1 + s3 , s23 = s2 + s3 ; int ans = 0 ; if ( s12 > s3 ) { bool fail = false ; for ( int i = 1 ; i <= N ; i ++ ) { int a ; read_int ( a ); if ( a <= s1 ) ++ c1 ; else if ( a <= s2 ) ++ c2 ; else if ( a <= s3 ) ++ c3 ; else if ( a <= s12 ) ++ c12 ; else if ( a <= s13 ) ++ c13 ; else if ( a <= s23 ) ++ c23 ; else if ( a <= s123 ) ++ c123 ; else fail = true ; } if ( fail ) { cout << \"-1 \\n \" ; return 0 ; } ans = c123 ; while ( c23 > 0 || c13 > 0 || c12 > 0 || c3 > 0 || c2 > 0 || c1 > 0 ) { if ( c23 > 0 ) { -- c23 ; if ( c1 > 0 ) -- c1 ; } else if ( c13 > 0 ) { -- c13 ; if ( c2 > 0 ) -- c2 ; else if ( c1 > 0 ) -- c1 ; } else if ( c12 > 0 ) { -- c12 ; if ( c3 > 0 ) -- c3 ; else if ( c2 > 0 ) -- c2 ; else if ( c1 > 0 ) -- c1 ; } else if ( c3 > 0 ) { -- c3 ; if ( c2 > 0 ) { -- c2 ; if ( c1 > 0 ) -- c1 ; } else if ( c1 > 0 ) { c1 -= 2 ; } else if ( c3 > 0 ) -- c3 ; // s12!! } else if ( c2 > 0 ) { -- c2 ; // s2 if ( c2 > 0 ) -- c2 ; // s3 else if ( c1 > 0 ) -- c1 ; // s3 if ( c1 > 0 ) -- c1 ; // s1 } else if ( c1 > 0 ) { c1 -= 3 ; } ++ ans ; } } else { bool fail = false ; for ( int i = 1 ; i <= N ; i ++ ) { int a ; read_int ( a ); if ( a <= s1 ) ++ c1 ; else if ( a <= s2 ) ++ c2 ; else if ( a <= s12 ) ++ c12 ; else if ( a <= s3 ) ++ c3 ; else if ( a <= s13 ) ++ c13 ; else if ( a <= s23 ) ++ c23 ; else if ( a <= s123 ) ++ c123 ; else fail = true ; } if ( fail ) { cout << \"-1 \\n \" ; return 0 ; } ans = c123 ; while ( c23 > 0 || c13 > 0 || c12 > 0 || c3 > 0 || c2 > 0 || c1 > 0 ) { if ( c23 > 0 ) { -- c23 ; if ( c1 > 0 ) -- c1 ; } else if ( c13 > 0 ) { -- c13 ; if ( c2 > 0 ) -- c2 ; // s2 else if ( c1 > 0 ) -- c1 ; // s2 } else if ( c3 > 0 ) { -- c3 ; if ( c2 > 0 ) { -- c2 ; // s2 if ( c1 > 0 ) -- c1 ; // s1 } else if ( c1 > 0 ) { c1 -= 2 ; // s1 , s2 } else if ( c12 > 0 ) -- c12 ; } else if ( c12 > 0 ) { -- c12 ; // s3 if ( c2 > 0 ) { -- c2 ; // s2 if ( c1 > 0 ) -- c1 ; } else if ( c1 > 0 ) { c1 -= 2 ; } else if ( c12 > 0 ) -- c12 ; } else if ( c2 > 0 ) { -- c2 ; // s2 if ( c2 > 0 ) -- c2 ; // s3 else if ( c1 > 0 ) -- c1 ; // s3 if ( c1 > 0 ) -- c1 ; // s1 } else if ( c1 > 0 ) { c1 -= 3 ; } ++ ans ; } } cout << ans << '\\n' ; return 0 ; } // input optimize inline int read_char () { constexpr int N = 1 << 20 ; static char buf [ N ]; static char * p = buf , * end = buf ; if ( p == end ) { if ( ( end = buf + fread_unlocked ( buf , 1 , N , stdin )) == buf ) return EOF ; p = buf ; } return * p ++ ; } inline int read_int ( int & x ) { static char c , neg ; while ( ( c = read_char ()) < '-' ) if ( c == EOF ) return 0 ; neg = ( c == '-' ) ? - 1 : 1 ; x = ( neg == 1 ) ? c - '0' : 0 ; while ( ( c = read_char ()) >= '0' ) x = ( x << 3 ) + ( x << 1 ) + ( c - '0' ); x *= neg ; return 1 ; } // output optimize #define _pc putchar_unlocked char _buf [ 128 ]; inline void write_int ( LL x ) { if ( ! x ) { _pc ( '0' ); _pc ( '\\n' ); return ; } int t = 0 ; while ( x ) { _buf [ t ++ ] = x % 10 + '0' ; x /= 10 ; } while ( t -- ) _pc ( _buf [ t ]); _pc ( '\\n' ); } #undef _pc","title":"Code"},{"location":"courses/ada-fall-2019/hw3/idol-master/","text":"Idol Master! \u00b6 Problem Description \u00b6 Yun-Nung (Vivian) Chen's website Concept \u00b6 path compression copy-on-write to avoid resetting counting array to 0 Code \u00b6 #include <bits/stdc++.h> #define IOS {ios::sync_with_stdio(false);cin.tie(nullptr);} #pragma GCC optimize(\"Ofast\", \"no-stack-protector\", \"unroll-loops\") #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,sse4.2,popcnt,abm,mmx,avx,tune=native\") using namespace std ; using LL = int64_t ; using ULL = uint64_t ; using LD = long double ; using pii = pair < int , int > ; constexpr int MAXN = ( 1 << 18 ) + 5 ; inline int read_int ( int & x ); inline void write_int ( LL x ); int N ; int G [ MAXN ], ref_cnt [ MAXN ], cnt [ MAXN ], label [ MAXN ], len [ MAXN ]; bool done [ MAXN ]; void dfs ( int o ) { int v = G [ o ], d = 1 ; while ( v && ref_cnt [ v ] == 1 ) v = G [ v ], ++ d ; G [ o ] = v ; len [ o ] = d ; done [ o ] = true ; if ( v && ! done [ v ] ) dfs ( v ); } void compress () { for ( int i = 1 ; i <= N ; i ++ ) if ( ref_cnt [ i ] == 0 ) dfs ( i ); } int main () { read_int ( N ); for ( int i = 1 ; i <= N ; i ++ ) { read_int ( G [ i ]); ref_cnt [ G [ i ]] ++ ; } compress (); int Q ; read_int ( Q ); for ( int q = 1 ; q <= Q ; q ++ ) { int ans = 0 ; int nx ; read_int ( nx ); for ( int _ = 0 ; _ < nx ; ++ _ ) { int x ; read_int ( x ); while ( cnt [ x ] == 0 ) { ans += len [ x ]; x = G [ x ]; if ( ! x ) break ; if ( label [ x ] != q ) { label [ x ] = q ; cnt [ x ] = ref_cnt [ x ]; } cnt [ x ] -- ; } } write_int ( ans ); } return 0 ; } // input optimize inline int read_char () { constexpr int N = 1 << 20 ; static char buf [ N ]; static char * p = buf , * end = buf ; if ( p == end ) { if ( ( end = buf + fread_unlocked ( buf , 1 , N , stdin )) == buf ) return EOF ; p = buf ; } return * p ++ ; } inline int read_int ( int & x ) { static char c , neg ; while ( ( c = read_char ()) < '-' ) if ( c == EOF ) return 0 ; neg = ( c == '-' ) ? - 1 : 1 ; x = ( neg == 1 ) ? c - '0' : 0 ; while ( ( c = read_char ()) >= '0' ) x = ( x << 3 ) + ( x << 1 ) + ( c - '0' ); x *= neg ; return 1 ; } // output optimize #define _pc putchar_unlocked char _buf [ 128 ]; inline void write_int ( LL x ) { if ( ! x ) { _pc ( '0' ); _pc ( '\\n' ); return ; } int t = 0 ; while ( x ) { _buf [ t ++ ] = x % 10 + '0' ; x /= 10 ; } while ( t -- ) _pc ( _buf [ t ]); _pc ( '\\n' ); } #undef _pc","title":"Idol Master!"},{"location":"courses/ada-fall-2019/hw3/idol-master/#idol-master","text":"","title":"Idol Master!"},{"location":"courses/ada-fall-2019/hw3/idol-master/#problem-description","text":"Yun-Nung (Vivian) Chen's website","title":"Problem Description"},{"location":"courses/ada-fall-2019/hw3/idol-master/#concept","text":"path compression copy-on-write to avoid resetting counting array to 0","title":"Concept"},{"location":"courses/ada-fall-2019/hw3/idol-master/#code","text":"#include <bits/stdc++.h> #define IOS {ios::sync_with_stdio(false);cin.tie(nullptr);} #pragma GCC optimize(\"Ofast\", \"no-stack-protector\", \"unroll-loops\") #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,sse4.2,popcnt,abm,mmx,avx,tune=native\") using namespace std ; using LL = int64_t ; using ULL = uint64_t ; using LD = long double ; using pii = pair < int , int > ; constexpr int MAXN = ( 1 << 18 ) + 5 ; inline int read_int ( int & x ); inline void write_int ( LL x ); int N ; int G [ MAXN ], ref_cnt [ MAXN ], cnt [ MAXN ], label [ MAXN ], len [ MAXN ]; bool done [ MAXN ]; void dfs ( int o ) { int v = G [ o ], d = 1 ; while ( v && ref_cnt [ v ] == 1 ) v = G [ v ], ++ d ; G [ o ] = v ; len [ o ] = d ; done [ o ] = true ; if ( v && ! done [ v ] ) dfs ( v ); } void compress () { for ( int i = 1 ; i <= N ; i ++ ) if ( ref_cnt [ i ] == 0 ) dfs ( i ); } int main () { read_int ( N ); for ( int i = 1 ; i <= N ; i ++ ) { read_int ( G [ i ]); ref_cnt [ G [ i ]] ++ ; } compress (); int Q ; read_int ( Q ); for ( int q = 1 ; q <= Q ; q ++ ) { int ans = 0 ; int nx ; read_int ( nx ); for ( int _ = 0 ; _ < nx ; ++ _ ) { int x ; read_int ( x ); while ( cnt [ x ] == 0 ) { ans += len [ x ]; x = G [ x ]; if ( ! x ) break ; if ( label [ x ] != q ) { label [ x ] = q ; cnt [ x ] = ref_cnt [ x ]; } cnt [ x ] -- ; } } write_int ( ans ); } return 0 ; } // input optimize inline int read_char () { constexpr int N = 1 << 20 ; static char buf [ N ]; static char * p = buf , * end = buf ; if ( p == end ) { if ( ( end = buf + fread_unlocked ( buf , 1 , N , stdin )) == buf ) return EOF ; p = buf ; } return * p ++ ; } inline int read_int ( int & x ) { static char c , neg ; while ( ( c = read_char ()) < '-' ) if ( c == EOF ) return 0 ; neg = ( c == '-' ) ? - 1 : 1 ; x = ( neg == 1 ) ? c - '0' : 0 ; while ( ( c = read_char ()) >= '0' ) x = ( x << 3 ) + ( x << 1 ) + ( c - '0' ); x *= neg ; return 1 ; } // output optimize #define _pc putchar_unlocked char _buf [ 128 ]; inline void write_int ( LL x ) { if ( ! x ) { _pc ( '0' ); _pc ( '\\n' ); return ; } int t = 0 ; while ( x ) { _buf [ t ++ ] = x % 10 + '0' ; x /= 10 ; } while ( t -- ) _pc ( _buf [ t ]); _pc ( '\\n' ); } #undef _pc","title":"Code"},{"location":"courses/ada-fall-2019/hw3/magic-song/","text":"Magic Song \u00b6 Problem Description \u00b6 Yun-Nung (Vivian) Chen's website Concept \u00b6 methods to convert the input to a graph: hash table ( __gnu_pbds::gp_hash_table ) \u96e2\u6563\u5316 + std::lower_bound longest path on DAG dynamic programming Code \u00b6 #include <bits/stdc++.h> #include <bits/extc++.h> #define IOS {ios::sync_with_stdio(false);cin.tie(nullptr);} #define unordered_map __gnu_pbds::gp_hash_table #pragma GCC optimize(\"Ofast\", \"no-stack-protector\", \"unroll-loops\") #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,sse4.2,popcnt,abm,mmx,avx,tune=native\") using namespace std ; using LL = int64_t ; using ULL = uint64_t ; using LD = long double ; using pii = pair < int , int > ; inline int read_int ( int & x ); constexpr int MAXN = 1e5 + 5 , MAXM = 5e5 + 5 ; constexpr int MAXV = 1e6 + 2e5 + 100 ; constexpr LL INF = ( 1LL << 61 ) + 1 ; int N , M ; int A [ MAXN ]; vector < int > V [ MAXN ]; vector < pii > G [ MAXV ]; void add_edge ( int from , int to , int w ) { G [ from ]. push_back ( { to , w } ); } int nd = 0 ; unordered_map < ULL , int > mp ; ULL get_hash ( int a , int b ) { return (( ULL ) a << 31 ) | b ; } int add_node ( int s , int t ) { auto res = mp . insert ( make_pair ( get_hash ( s , t ), nd ) ); if ( res . second ) { ++ nd ; V [ s ]. push_back ( t ); } return res . first -> second ; } int get_node ( int s , int t ) { return mp [ get_hash ( s , t ) ]; } LL dist [ MAXV ]; bool vis [ MAXV ], done [ MAXV ]; LL dfs ( int v ) { vis [ v ] = true ; for ( pii p : G [ v ] ) { if ( ! vis [ p . first ] ) dfs ( p . first ); else if ( ! done [ p . first ] ) return ( dist [ v ] = INF ); dist [ v ] = max ( dist [ v ], dist [ p . first ] + p . second ); if ( dist [ v ] >= INF ) return INF ; } done [ v ] = true ; return dist [ v ]; } int main () { IOS ; int T ; read_int ( T ); while ( T -- ) { read_int ( N ); read_int ( M ); for ( int i = 1 ; i <= N ; i ++ ) { read_int ( A [ i ]); add_node ( i , A [ i ]); } for ( int i = 0 ; i < M ; i ++ ) { int s1 , t1 , s2 , t2 ; read_int ( s1 ); read_int ( t1 ); read_int ( s2 ); read_int ( t2 ); int from = add_node ( s1 , t1 ); int to = add_node ( s2 , t2 ); add_edge ( from , to , 1 ); } int S = nd ; for ( int i = 1 ; i <= N ; i ++ ) { sort ( V [ i ]. begin (), V [ i ]. end ()); int prev_id = S , prev_pos = 0 ; for ( int j = 0 ; j < V [ i ]. size (); j ++ ) { int now_id = get_node ( i , V [ i ][ j ]), now_pos = V [ i ][ j ]; add_edge ( prev_id , now_id , now_pos - prev_pos ); prev_id = now_id , prev_pos = now_pos ; } V [ i ]. clear (); } LL ans = dfs ( S ); if ( ans >= INF ) cout << \"LoveLive! \\n \" ; else cout << ans << '\\n' ; memset ( vis , 0 , sizeof ( vis )); memset ( done , 0 , sizeof ( done )); memset ( dist , 0 , sizeof ( dist )); for ( int i = 0 ; i <= nd ; i ++ ) G [ i ]. clear (); mp . clear (); nd = 0 ; } return EXIT_SUCCESS ; } // input optimize inline int read_char () { constexpr int N = 1 << 20 ; static char buf [ N ]; static char * p = buf , * end = buf ; if ( p == end ) { if ( ( end = buf + fread_unlocked ( buf , 1 , N , stdin )) == buf ) return EOF ; p = buf ; } return * p ++ ; } inline int read_int ( int & x ) { static char c , neg ; while ( ( c = read_char ()) < '-' ) if ( c == EOF ) return 0 ; neg = ( c == '-' ) ? - 1 : 1 ; x = ( neg == 1 ) ? c - '0' : 0 ; while ( ( c = read_char ()) >= '0' ) x = ( x << 3 ) + ( x << 1 ) + ( c - '0' ); x *= neg ; return 1 ; } // output optimize #define _pc putchar_unlocked char _buf [ 128 ]; inline void write_int ( LL x ) { if ( ! x ) { _pc ( '0' ); _pc ( '\\n' ); return ; } int t = 0 ; while ( x ) { _buf [ t ++ ] = x % 10 + '0' ; x /= 10 ; } while ( t -- ) _pc ( _buf [ t ]); _pc ( '\\n' ); } #undef _pc","title":"Magic Song"},{"location":"courses/ada-fall-2019/hw3/magic-song/#magic-song","text":"","title":"Magic Song"},{"location":"courses/ada-fall-2019/hw3/magic-song/#problem-description","text":"Yun-Nung (Vivian) Chen's website","title":"Problem Description"},{"location":"courses/ada-fall-2019/hw3/magic-song/#concept","text":"methods to convert the input to a graph: hash table ( __gnu_pbds::gp_hash_table ) \u96e2\u6563\u5316 + std::lower_bound longest path on DAG dynamic programming","title":"Concept"},{"location":"courses/ada-fall-2019/hw3/magic-song/#code","text":"#include <bits/stdc++.h> #include <bits/extc++.h> #define IOS {ios::sync_with_stdio(false);cin.tie(nullptr);} #define unordered_map __gnu_pbds::gp_hash_table #pragma GCC optimize(\"Ofast\", \"no-stack-protector\", \"unroll-loops\") #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,sse4.2,popcnt,abm,mmx,avx,tune=native\") using namespace std ; using LL = int64_t ; using ULL = uint64_t ; using LD = long double ; using pii = pair < int , int > ; inline int read_int ( int & x ); constexpr int MAXN = 1e5 + 5 , MAXM = 5e5 + 5 ; constexpr int MAXV = 1e6 + 2e5 + 100 ; constexpr LL INF = ( 1LL << 61 ) + 1 ; int N , M ; int A [ MAXN ]; vector < int > V [ MAXN ]; vector < pii > G [ MAXV ]; void add_edge ( int from , int to , int w ) { G [ from ]. push_back ( { to , w } ); } int nd = 0 ; unordered_map < ULL , int > mp ; ULL get_hash ( int a , int b ) { return (( ULL ) a << 31 ) | b ; } int add_node ( int s , int t ) { auto res = mp . insert ( make_pair ( get_hash ( s , t ), nd ) ); if ( res . second ) { ++ nd ; V [ s ]. push_back ( t ); } return res . first -> second ; } int get_node ( int s , int t ) { return mp [ get_hash ( s , t ) ]; } LL dist [ MAXV ]; bool vis [ MAXV ], done [ MAXV ]; LL dfs ( int v ) { vis [ v ] = true ; for ( pii p : G [ v ] ) { if ( ! vis [ p . first ] ) dfs ( p . first ); else if ( ! done [ p . first ] ) return ( dist [ v ] = INF ); dist [ v ] = max ( dist [ v ], dist [ p . first ] + p . second ); if ( dist [ v ] >= INF ) return INF ; } done [ v ] = true ; return dist [ v ]; } int main () { IOS ; int T ; read_int ( T ); while ( T -- ) { read_int ( N ); read_int ( M ); for ( int i = 1 ; i <= N ; i ++ ) { read_int ( A [ i ]); add_node ( i , A [ i ]); } for ( int i = 0 ; i < M ; i ++ ) { int s1 , t1 , s2 , t2 ; read_int ( s1 ); read_int ( t1 ); read_int ( s2 ); read_int ( t2 ); int from = add_node ( s1 , t1 ); int to = add_node ( s2 , t2 ); add_edge ( from , to , 1 ); } int S = nd ; for ( int i = 1 ; i <= N ; i ++ ) { sort ( V [ i ]. begin (), V [ i ]. end ()); int prev_id = S , prev_pos = 0 ; for ( int j = 0 ; j < V [ i ]. size (); j ++ ) { int now_id = get_node ( i , V [ i ][ j ]), now_pos = V [ i ][ j ]; add_edge ( prev_id , now_id , now_pos - prev_pos ); prev_id = now_id , prev_pos = now_pos ; } V [ i ]. clear (); } LL ans = dfs ( S ); if ( ans >= INF ) cout << \"LoveLive! \\n \" ; else cout << ans << '\\n' ; memset ( vis , 0 , sizeof ( vis )); memset ( done , 0 , sizeof ( done )); memset ( dist , 0 , sizeof ( dist )); for ( int i = 0 ; i <= nd ; i ++ ) G [ i ]. clear (); mp . clear (); nd = 0 ; } return EXIT_SUCCESS ; } // input optimize inline int read_char () { constexpr int N = 1 << 20 ; static char buf [ N ]; static char * p = buf , * end = buf ; if ( p == end ) { if ( ( end = buf + fread_unlocked ( buf , 1 , N , stdin )) == buf ) return EOF ; p = buf ; } return * p ++ ; } inline int read_int ( int & x ) { static char c , neg ; while ( ( c = read_char ()) < '-' ) if ( c == EOF ) return 0 ; neg = ( c == '-' ) ? - 1 : 1 ; x = ( neg == 1 ) ? c - '0' : 0 ; while ( ( c = read_char ()) >= '0' ) x = ( x << 3 ) + ( x << 1 ) + ( c - '0' ); x *= neg ; return 1 ; } // output optimize #define _pc putchar_unlocked char _buf [ 128 ]; inline void write_int ( LL x ) { if ( ! x ) { _pc ( '0' ); _pc ( '\\n' ); return ; } int t = 0 ; while ( x ) { _buf [ t ++ ] = x % 10 + '0' ; x /= 10 ; } while ( t -- ) _pc ( _buf [ t ]); _pc ( '\\n' ); } #undef _pc","title":"Code"},{"location":"courses/ada-fall-2019/hw3/traveling-pony-problem/","text":"Traveling Pony Problem \u00b6 Problem Description \u00b6 Yun-Nung (Vivian) Chen's website Concept \u00b6 First Stage: Find the minimum possible protection min_l By altered Dijkstra By Disjoint Set Union (the usage is like Kruskal ) Second Stage: Run normal Dijkstra On the graph which all edges' weight \\leq \\leq min_l Code \u00b6 #include <bits/stdc++.h> #define IOS {ios::sync_with_stdio(false);cin.tie(nullptr);} #pragma GCC optimize(\"Ofast\", \"no-stack-protector\", \"unroll-loops\") #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,sse4.2,popcnt,abm,mmx,avx,tune=native\") using namespace std ; using LL = int64_t ; using ULL = uint64_t ; using LD = long double ; using pii = pair < LL , LL > ; inline int read_int ( int & ); constexpr int MAXN = 2e5 + 5 , MAXM = 5e5 + 5 ; constexpr LL INF = ( 1LL << 61 ) + 1 ; int n ; struct DSU { int parent [ MAXN ], size [ MAXN ]; void init ( int n ) { for ( int i = 0 ; i < n ; i ++ ) mk_set ( i ); } void mk_set ( int v ) { parent [ v ] = v ; size [ v ] = 1 ; } int find_set ( int v ) { if ( v == parent [ v ] ) return v ; return ( parent [ v ] = find_set ( parent [ v ])); } void unite_set ( int v , int u ) { v = find_set ( v ), u = find_set ( u ); if ( v != u ) { if ( size [ v ] < size [ u ] ) swap ( v , u ); parent [ u ] = v ; size [ v ] += size [ u ]; } } } dsu ; struct Dijkstra { vector < pii > adj [ MAXN ]; // first: weight, second: to LL min_d [ MAXN ]; Dijkstra () = default ; void add_edge ( int u , int v , int w ) { adj [ u ]. push_back ( { w , v } ); } LL run ( int src , int dst ) { fill ( min_d , min_d + n , INF ); min_d [ src ] = 0 ; priority_queue < pii , vector < pii > , greater < pii > > pq ; pq . push ({ 0 , src }); while ( ! pq . empty () ) { LL v = pq . top (). second , d_v = pq . top (). first ; pq . pop (); if ( d_v != min_d [ v ] ) continue ; if ( v == dst ) return d_v ; for ( auto e : adj [ v ] ) { LL to = e . second , wei = e . first ; if ( d_v + wei < min_d [ to ] ) { min_d [ to ] = min_d [ v ] + wei ; pq . push ( { min_d [ to ], to } ); } } } } } G ; struct Edge { int x , y , d , l ; bool operator < ( const Edge & rhs ) const { return l < rhs . l ; } }; Edge edges [ MAXM ]; int main () { IOS ; int m ; read_int ( n ); read_int ( m ); int s , t ; read_int ( s ); read_int ( t ); if ( s == t ) { cout << \"0 0 \\n \" ; return 0 ; } for ( int i = 0 ; i < m ; i ++ ) { read_int ( edges [ i ]. x ); read_int ( edges [ i ]. y ); read_int ( edges [ i ]. d ); read_int ( edges [ i ]. l ); } sort ( edges , edges + m ); if ( edges [ 0 ]. l == edges [ m - 1 ]. l ) { for ( auto e : edges ) { G . add_edge ( e . x , e . y , e . d ); G . add_edge ( e . y , e . x , e . d ); } cout << G . run ( s , t ) << ' ' << edges [ 0 ]. l << '\\n' ; return 0 ; } int L = 0 ; dsu . init ( n ); for ( Edge * it = edges ; it != edges + m ; ++ it ) { dsu . unite_set ( it -> x , it -> y ); G . add_edge ( it -> x , it -> y , it -> d ); G . add_edge ( it -> y , it -> x , it -> d ); if ( dsu . find_set ( s ) == dsu . find_set ( t ) ) { L = it -> l ; for ( ++ it ; it != edges + m && it -> l == L ; ++ it ) { G . add_edge ( it -> x , it -> y , it -> d ); G . add_edge ( it -> y , it -> x , it -> d ); } break ; } } cout << G . run ( s , t ) << ' ' << L << '\\n' ; return 0 ; } // input optimize inline int read_char () { constexpr int N = 1 << 20 ; static char buf [ N ]; static char * p = buf , * end = buf ; if ( p == end ) { if ( ( end = buf + fread_unlocked ( buf , 1 , N , stdin )) == buf ) return EOF ; p = buf ; } return * p ++ ; } inline int read_int ( int & x ) { static char c , neg ; while ( ( c = read_char ()) < '-' ) if ( c == EOF ) return 0 ; neg = ( c == '-' ) ? - 1 : 1 ; x = ( neg == 1 ) ? c - '0' : 0 ; while ( ( c = read_char ()) >= '0' ) x = ( x << 3 ) + ( x << 1 ) + ( c - '0' ); x *= neg ; return 1 ; } // output optimize #define _pc putchar_unlocked char _buf [ 128 ]; inline void write_int ( LL x ) { if ( ! x ) { _pc ( '0' ); _pc ( '\\n' ); return ; } int t = 0 ; while ( x ) { _buf [ t ++ ] = x % 10 + '0' ; x /= 10 ; } while ( t -- ) _pc ( _buf [ t ]); _pc ( '\\n' ); } #undef _pc","title":"Traveling Pony Problem"},{"location":"courses/ada-fall-2019/hw3/traveling-pony-problem/#traveling-pony-problem","text":"","title":"Traveling Pony Problem"},{"location":"courses/ada-fall-2019/hw3/traveling-pony-problem/#problem-description","text":"Yun-Nung (Vivian) Chen's website","title":"Problem Description"},{"location":"courses/ada-fall-2019/hw3/traveling-pony-problem/#concept","text":"First Stage: Find the minimum possible protection min_l By altered Dijkstra By Disjoint Set Union (the usage is like Kruskal ) Second Stage: Run normal Dijkstra On the graph which all edges' weight \\leq \\leq min_l","title":"Concept"},{"location":"courses/ada-fall-2019/hw3/traveling-pony-problem/#code","text":"#include <bits/stdc++.h> #define IOS {ios::sync_with_stdio(false);cin.tie(nullptr);} #pragma GCC optimize(\"Ofast\", \"no-stack-protector\", \"unroll-loops\") #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,sse4.2,popcnt,abm,mmx,avx,tune=native\") using namespace std ; using LL = int64_t ; using ULL = uint64_t ; using LD = long double ; using pii = pair < LL , LL > ; inline int read_int ( int & ); constexpr int MAXN = 2e5 + 5 , MAXM = 5e5 + 5 ; constexpr LL INF = ( 1LL << 61 ) + 1 ; int n ; struct DSU { int parent [ MAXN ], size [ MAXN ]; void init ( int n ) { for ( int i = 0 ; i < n ; i ++ ) mk_set ( i ); } void mk_set ( int v ) { parent [ v ] = v ; size [ v ] = 1 ; } int find_set ( int v ) { if ( v == parent [ v ] ) return v ; return ( parent [ v ] = find_set ( parent [ v ])); } void unite_set ( int v , int u ) { v = find_set ( v ), u = find_set ( u ); if ( v != u ) { if ( size [ v ] < size [ u ] ) swap ( v , u ); parent [ u ] = v ; size [ v ] += size [ u ]; } } } dsu ; struct Dijkstra { vector < pii > adj [ MAXN ]; // first: weight, second: to LL min_d [ MAXN ]; Dijkstra () = default ; void add_edge ( int u , int v , int w ) { adj [ u ]. push_back ( { w , v } ); } LL run ( int src , int dst ) { fill ( min_d , min_d + n , INF ); min_d [ src ] = 0 ; priority_queue < pii , vector < pii > , greater < pii > > pq ; pq . push ({ 0 , src }); while ( ! pq . empty () ) { LL v = pq . top (). second , d_v = pq . top (). first ; pq . pop (); if ( d_v != min_d [ v ] ) continue ; if ( v == dst ) return d_v ; for ( auto e : adj [ v ] ) { LL to = e . second , wei = e . first ; if ( d_v + wei < min_d [ to ] ) { min_d [ to ] = min_d [ v ] + wei ; pq . push ( { min_d [ to ], to } ); } } } } } G ; struct Edge { int x , y , d , l ; bool operator < ( const Edge & rhs ) const { return l < rhs . l ; } }; Edge edges [ MAXM ]; int main () { IOS ; int m ; read_int ( n ); read_int ( m ); int s , t ; read_int ( s ); read_int ( t ); if ( s == t ) { cout << \"0 0 \\n \" ; return 0 ; } for ( int i = 0 ; i < m ; i ++ ) { read_int ( edges [ i ]. x ); read_int ( edges [ i ]. y ); read_int ( edges [ i ]. d ); read_int ( edges [ i ]. l ); } sort ( edges , edges + m ); if ( edges [ 0 ]. l == edges [ m - 1 ]. l ) { for ( auto e : edges ) { G . add_edge ( e . x , e . y , e . d ); G . add_edge ( e . y , e . x , e . d ); } cout << G . run ( s , t ) << ' ' << edges [ 0 ]. l << '\\n' ; return 0 ; } int L = 0 ; dsu . init ( n ); for ( Edge * it = edges ; it != edges + m ; ++ it ) { dsu . unite_set ( it -> x , it -> y ); G . add_edge ( it -> x , it -> y , it -> d ); G . add_edge ( it -> y , it -> x , it -> d ); if ( dsu . find_set ( s ) == dsu . find_set ( t ) ) { L = it -> l ; for ( ++ it ; it != edges + m && it -> l == L ; ++ it ) { G . add_edge ( it -> x , it -> y , it -> d ); G . add_edge ( it -> y , it -> x , it -> d ); } break ; } } cout << G . run ( s , t ) << ' ' << L << '\\n' ; return 0 ; } // input optimize inline int read_char () { constexpr int N = 1 << 20 ; static char buf [ N ]; static char * p = buf , * end = buf ; if ( p == end ) { if ( ( end = buf + fread_unlocked ( buf , 1 , N , stdin )) == buf ) return EOF ; p = buf ; } return * p ++ ; } inline int read_int ( int & x ) { static char c , neg ; while ( ( c = read_char ()) < '-' ) if ( c == EOF ) return 0 ; neg = ( c == '-' ) ? - 1 : 1 ; x = ( neg == 1 ) ? c - '0' : 0 ; while ( ( c = read_char ()) >= '0' ) x = ( x << 3 ) + ( x << 1 ) + ( c - '0' ); x *= neg ; return 1 ; } // output optimize #define _pc putchar_unlocked char _buf [ 128 ]; inline void write_int ( LL x ) { if ( ! x ) { _pc ( '0' ); _pc ( '\\n' ); return ; } int t = 0 ; while ( x ) { _buf [ t ++ ] = x % 10 + '0' ; x /= 10 ; } while ( t -- ) _pc ( _buf [ t ]); _pc ( '\\n' ); } #undef _pc","title":"Code"},{"location":"courses/ada-fall-2019/hw4/hex/","text":"Hex \u00b6 Problem Description \u00b6 Yun-Nung (Vivian) Chen's website TA's Hint \u00b6 There are many different approaches that can solve this problem. You can try the following ways (or combine some of them): alpha-beta pruning Monte Carlo simulation heuristic algorithms based on human knowledge Concept \u00b6 assign each possible move a weight by some heuristics choose the move with highest weight my heuristics is bad and the code is ugly, please don't read it Code \u00b6 #include <bits/stdc++.h> #include \"hex.h\" using namespace std ; using pii = pair < int , int > ; constexpr int MAXN = 8 ; constexpr int Me = 1 , He = 2 ; const vector < pii > Adj = { pii ( - 1 , 1 ), pii ( - 1 , 0 ), pii ( 1 , - 1 ), pii ( 1 , 0 ), pii ( - 1 , 1 ), pii ( 0 , 1 )}; const vector < pii > GoodUp = { pii ( - 1 , 1 ), pii ( - 1 , 0 )}; const vector < pii > GoodDown = { pii ( 1 , - 1 ), pii ( 1 , 0 )}; const vector < pii > BadAdj = { pii ( 0 , - 1 ), pii ( 1 , - 1 ), pii ( - 1 , 1 ), pii ( 0 , 1 )}; const vector < pii > GoodBri = { pii ( - 2 , 1 ), pii ( 2 , - 1 )}; const vector < pii > BadBri = { pii ( 1 , - 2 ), pii ( - 1 , 2 )}; const vector < pii > Block = { pii ( 1 , 0 ), pii ( 0 , 1 )}; int board [ MAXN ][ MAXN ]; int n ; pii SRC ; int W [ MAXN ][ MAXN ]; int cnt ; void init2 ( int _n ) { n = _n ; cnt = 0 ; memset ( board , 0 , sizeof board ); } void init ( int _n ) { if ( _n == 5 ) { init2 ( _n ); return ; } srand ( 7902064 ); n = _n ; memset ( board , 0 , sizeof board ); memset ( W , 0 , sizeof ( W )); int x = n / 2 , y = n / 2 ; if ( n % 2 == 0 ) -- x ; W [ x ][ y ] += 100 ; SRC = pii ( x , y ); } bool in_board ( int i , int j ) { return i >= 0 && j >= 0 && i < n && j < n ; } int how_many ( int i , int j , int label , vector < pii > DIR ) { int cnt = 0 ; for ( pii d : DIR ) { int ni = i + d . first , nj = j + d . second ; if ( in_board ( ni , nj ) && board [ ni ][ nj ] == label ) ++ cnt ; } return cnt ; } int plus_adj ( int i , int j , int add , vector < pii > DIR ) { int cnt = 0 ; for ( pii d : DIR ) { int ni = i + d . first , nj = j + d . second ; if ( in_board ( ni , nj ) && board [ ni ][ nj ] == 0 ) W [ ni ][ nj ] += add , ++ cnt ; } return cnt ; } void good ( int i , int j ) { int up_me = how_many ( i , j , Me , GoodUp ); if ( up_me >= 1 || i == 0 ) ++ W [ i ][ j ]; int down_me = how_many ( i , j , Me , GoodDown ); if ( down_me >= 1 || i == n - 1 ) ++ W [ i ][ j ]; } void bad ( int i , int j ) { int up_he = how_many ( i , j , He , GoodUp ); int down_he = how_many ( i , j , He , GoodDown ); if ( up_he > 0 ) W [ i ][ j ] -- ; if ( down_he > 0 ) W [ i ][ j ] -- ; } void block ( int i , int j ) { int a = how_many ( i , j , He , BadAdj ); if ( a > 0 ) W [ i ][ j ] += 2 ; } pii decide2 ( pii p ) { if ( p != make_pair ( - 1 , - 1 ) ) board [ p . first ][ p . second ] = He ; if ( cnt == 0 ) { ++ cnt ; int x = n / 2 , y = n / 2 ; if ( n % 2 == 0 ) -- x ; board [ x ][ y ] = Me ; return pii ( x , y ); } memset ( W , 0 , sizeof ( W )); for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { good ( i , j ); bad ( i , j ); block ( i , j ); } } int best = 0 ; pii best_pos = { 0 , 0 }; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( board [ i ][ j ] == 0 && W [ i ][ j ] > best ) { best = W [ i ][ j ]; best_pos = pii ( i , j ); } } } board [ best_pos . first ][ best_pos . second ] = Me ; ++ cnt ; return best_pos ; } pii decide ( pii p ) { if ( n == 5 ) return decide2 ( p ); if ( p != make_pair ( - 1 , - 1 ) ) board [ p . first ][ p . second ] = He ; if ( p . second > 0 ) W [ p . first ][ p . second - 1 ] += 1 ; plus_adj ( p . first , p . second , 1 , Block ); for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( board [ i ][ j ] == Me ) { if ( how_many ( i , j , Me , GoodUp ) == 0 ) plus_adj ( i , j , 2 , GoodUp ); if ( how_many ( i , j , Me , GoodDown ) == 0 ) plus_adj ( i , j , 2 , GoodDown ); } for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( board [ i ][ j ] == 0 && ( how_many ( i , j , He , GoodUp ) == 2 || how_many ( i , j , He , GoodDown ) == 2 ) ) W [ i ][ j ] = 0 ; int best = - 1 ; vector < pii > L ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( board [ i ][ j ] == 0 && W [ i ][ j ] > best ) { best = W [ i ][ j ]; L . clear (); L . push_back ( pii ( i , j )); } else if ( board [ i ][ j ] == 0 && W [ i ][ j ] == best ) { L . push_back ( pii ( i , j )); } } } pii best_pos = L [ rand () % L . size ()]; board [ best_pos . first ][ best_pos . second ] = Me ; memset ( W , 0 , sizeof ( W )); return best_pos ; }","title":"Hex"},{"location":"courses/ada-fall-2019/hw4/hex/#hex","text":"","title":"Hex"},{"location":"courses/ada-fall-2019/hw4/hex/#problem-description","text":"Yun-Nung (Vivian) Chen's website","title":"Problem Description"},{"location":"courses/ada-fall-2019/hw4/hex/#tas-hint","text":"There are many different approaches that can solve this problem. You can try the following ways (or combine some of them): alpha-beta pruning Monte Carlo simulation heuristic algorithms based on human knowledge","title":"TA's Hint"},{"location":"courses/ada-fall-2019/hw4/hex/#concept","text":"assign each possible move a weight by some heuristics choose the move with highest weight my heuristics is bad and the code is ugly, please don't read it","title":"Concept"},{"location":"courses/ada-fall-2019/hw4/hex/#code","text":"#include <bits/stdc++.h> #include \"hex.h\" using namespace std ; using pii = pair < int , int > ; constexpr int MAXN = 8 ; constexpr int Me = 1 , He = 2 ; const vector < pii > Adj = { pii ( - 1 , 1 ), pii ( - 1 , 0 ), pii ( 1 , - 1 ), pii ( 1 , 0 ), pii ( - 1 , 1 ), pii ( 0 , 1 )}; const vector < pii > GoodUp = { pii ( - 1 , 1 ), pii ( - 1 , 0 )}; const vector < pii > GoodDown = { pii ( 1 , - 1 ), pii ( 1 , 0 )}; const vector < pii > BadAdj = { pii ( 0 , - 1 ), pii ( 1 , - 1 ), pii ( - 1 , 1 ), pii ( 0 , 1 )}; const vector < pii > GoodBri = { pii ( - 2 , 1 ), pii ( 2 , - 1 )}; const vector < pii > BadBri = { pii ( 1 , - 2 ), pii ( - 1 , 2 )}; const vector < pii > Block = { pii ( 1 , 0 ), pii ( 0 , 1 )}; int board [ MAXN ][ MAXN ]; int n ; pii SRC ; int W [ MAXN ][ MAXN ]; int cnt ; void init2 ( int _n ) { n = _n ; cnt = 0 ; memset ( board , 0 , sizeof board ); } void init ( int _n ) { if ( _n == 5 ) { init2 ( _n ); return ; } srand ( 7902064 ); n = _n ; memset ( board , 0 , sizeof board ); memset ( W , 0 , sizeof ( W )); int x = n / 2 , y = n / 2 ; if ( n % 2 == 0 ) -- x ; W [ x ][ y ] += 100 ; SRC = pii ( x , y ); } bool in_board ( int i , int j ) { return i >= 0 && j >= 0 && i < n && j < n ; } int how_many ( int i , int j , int label , vector < pii > DIR ) { int cnt = 0 ; for ( pii d : DIR ) { int ni = i + d . first , nj = j + d . second ; if ( in_board ( ni , nj ) && board [ ni ][ nj ] == label ) ++ cnt ; } return cnt ; } int plus_adj ( int i , int j , int add , vector < pii > DIR ) { int cnt = 0 ; for ( pii d : DIR ) { int ni = i + d . first , nj = j + d . second ; if ( in_board ( ni , nj ) && board [ ni ][ nj ] == 0 ) W [ ni ][ nj ] += add , ++ cnt ; } return cnt ; } void good ( int i , int j ) { int up_me = how_many ( i , j , Me , GoodUp ); if ( up_me >= 1 || i == 0 ) ++ W [ i ][ j ]; int down_me = how_many ( i , j , Me , GoodDown ); if ( down_me >= 1 || i == n - 1 ) ++ W [ i ][ j ]; } void bad ( int i , int j ) { int up_he = how_many ( i , j , He , GoodUp ); int down_he = how_many ( i , j , He , GoodDown ); if ( up_he > 0 ) W [ i ][ j ] -- ; if ( down_he > 0 ) W [ i ][ j ] -- ; } void block ( int i , int j ) { int a = how_many ( i , j , He , BadAdj ); if ( a > 0 ) W [ i ][ j ] += 2 ; } pii decide2 ( pii p ) { if ( p != make_pair ( - 1 , - 1 ) ) board [ p . first ][ p . second ] = He ; if ( cnt == 0 ) { ++ cnt ; int x = n / 2 , y = n / 2 ; if ( n % 2 == 0 ) -- x ; board [ x ][ y ] = Me ; return pii ( x , y ); } memset ( W , 0 , sizeof ( W )); for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { good ( i , j ); bad ( i , j ); block ( i , j ); } } int best = 0 ; pii best_pos = { 0 , 0 }; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( board [ i ][ j ] == 0 && W [ i ][ j ] > best ) { best = W [ i ][ j ]; best_pos = pii ( i , j ); } } } board [ best_pos . first ][ best_pos . second ] = Me ; ++ cnt ; return best_pos ; } pii decide ( pii p ) { if ( n == 5 ) return decide2 ( p ); if ( p != make_pair ( - 1 , - 1 ) ) board [ p . first ][ p . second ] = He ; if ( p . second > 0 ) W [ p . first ][ p . second - 1 ] += 1 ; plus_adj ( p . first , p . second , 1 , Block ); for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( board [ i ][ j ] == Me ) { if ( how_many ( i , j , Me , GoodUp ) == 0 ) plus_adj ( i , j , 2 , GoodUp ); if ( how_many ( i , j , Me , GoodDown ) == 0 ) plus_adj ( i , j , 2 , GoodDown ); } for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( board [ i ][ j ] == 0 && ( how_many ( i , j , He , GoodUp ) == 2 || how_many ( i , j , He , GoodDown ) == 2 ) ) W [ i ][ j ] = 0 ; int best = - 1 ; vector < pii > L ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( board [ i ][ j ] == 0 && W [ i ][ j ] > best ) { best = W [ i ][ j ]; L . clear (); L . push_back ( pii ( i , j )); } else if ( board [ i ][ j ] == 0 && W [ i ][ j ] == best ) { L . push_back ( pii ( i , j )); } } } pii best_pos = L [ rand () % L . size ()]; board [ best_pos . first ][ best_pos . second ] = Me ; memset ( W , 0 , sizeof ( W )); return best_pos ; }","title":"Code"},{"location":"courses/ada-fall-2019/hw4/loopy-tippy/","text":"Loopy Tippy \u00b6 Problem Description \u00b6 Yun-Nung (Vivian) Chen's website TA's Hint \u00b6 The constraints can be modeled as three parts: The number of edges Simple loops Connectivity n^4 n^4 variables: x_{i,j}^t x_{i,j}^t denotes whether (i, j) (i, j) is reachable at time t t . Online Resources \u00b6 Slitherlink Reloaded Code \u00b6 #include <bits/stdc++.h> #define IOS { ios::sync_with_stdio(false); cin.tie(nullptr); } #pragma GCC optimize(\"Ofast\", \"no-stack-protector\", \"unroll-loops\") #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,sse4.2,popcnt,abm,mmx,avx,tune=native\") #ifndef DIMACS #include <cryptominisat5/cryptominisat.h> #else #include <fstream> #include <vector> #endif namespace sat { #ifndef DIMACS CMSat :: SATSolver solver ; std :: vector < CMSat :: Lit > lit_buf ; void Init ( int n ) { solver . new_vars ( n + 1 ); } void AddClause ( std :: vector < int > v ) { lit_buf . clear (); lit_buf . reserve ( v . size ()); for ( int x : v ) lit_buf . emplace_back ( abs ( x ), x < 0 ); solver . add_clause ( lit_buf ); } bool Solve () { return solver . solve () == CMSat :: l_True ; } int GetResult ( int id ) { auto r = solver . get_model ()[ id ]; return r == CMSat :: l_True ? 1 : r == CMSat :: l_False ? - 1 : 0 ; } #else std :: vector < std :: vector < int >> clauses ; int n_vars ; void Init ( int n ) { n_vars = n ; } void AddClause ( std :: vector < int > v ) { clauses . emplace_back ( std :: move ( v )); } bool Solve () { std :: fstream fs ( \"out.dimacs\" , fs . trunc | fs . out ); fs << \"p cnf \" << n_vars << ' ' << clauses . size () << '\\n' ; for ( auto & v : clauses ) { for ( auto x : v ) fs << x << ' ' ; fs << \"0 \\n \" ; } fs . close (); exit ( 0 ); } int GetResult ( int id ) { return 0 ; } #endif // DIMACS } // namespace sat using namespace std ; using LL = long long ; using ULL = unsigned long long ; using pii = pair < int , int > ; constexpr int MAXR = 128 ; constexpr int MAXC = 128 ; int r , c , board [ MAXR ][ MAXC ]; bool is_wall [ MAXR + MAXC + 2 * MAXR * MAXC ]; inline int id_h ( int i , int j ) { return i * ( 2 * c + 1 ) + j + 1 ; } inline int id_v ( int i , int j ) { return c + i * ( 2 * c + 1 ) + j + 1 ; } void all_false ( vector < int >& S ) { for ( int v : S ) { vector < int > vv = { - v }; sat :: AddClause ( vv ); } } void exactly_one ( vector < int >& S ) { sat :: AddClause ( S ); int sz = S . size (); for ( int i = 0 ; i < sz ; i ++ ) for ( int j = i + 1 ; j < sz ; j ++ ) { vector < int > vv = { - S [ i ], - S [ j ]}; sat :: AddClause ( vv ); } } void exactly_one_false ( vector < int > & S ) { for ( int & v : S ) v = - v ; exactly_one ( S ); } void exactly_two ( vector < int > & S ) { for ( int i = 0 ; i < 4 ; i ++ ) { vector < int > vv ; for ( int j = 0 ; j < 4 ; j ++ ) if ( j != i ) vv . push_back ( S [ j ]); sat :: AddClause ( vv ); for ( int & v : vv ) v = - v ; sat :: AddClause ( vv ); } } void exactly_two_or_none ( vector < int > & S ) { if ( S . size () == 2 ) { vector < int > v1 = { - S [ 0 ], S [ 1 ]}, v2 = { S [ 0 ], - S [ 1 ]}; sat :: AddClause ( v1 ); sat :: AddClause ( v2 ); } else if ( S . size () == 3 ) { for ( int i = 0 ; i < 3 ; i ++ ) { S [ i ] = - S [ i ]; sat :: AddClause ( S ); S [ i ] = - S [ i ]; } for ( int & i : S ) i = - i ; sat :: AddClause ( S ); } else if ( S . size () == 4 ) { for ( int i = 0 ; i < 4 ; i ++ ) { S [ i ] = - S [ i ]; sat :: AddClause ( S ); S [ i ] = - S [ i ]; } for ( int i = 0 ; i < 4 ; i ++ ) { vector < int > vv ; for ( int j = 0 ; j < 4 ; j ++ ) if ( j != i ) vv . push_back ( - S [ j ]); sat :: AddClause ( vv ); } } } bool vis [ MAXR ][ MAXC ]; stack < pii > stk ; void floodfill () { while ( ! stk . empty () ) { pii v = stk . top (); stk . pop (); int i = v . first , j = v . second ; if ( vis [ i ][ j ] ) continue ; vis [ i ][ j ] = true ; if ( i > 0 && ! is_wall [ id_h ( i , j )] ) stk . push ( pii ( i - 1 , j )); if ( i < r - 1 && ! is_wall [ id_h ( i + 1 , j )] ) stk . push ( pii ( i + 1 , j )); if ( j > 0 && ! is_wall [ id_v ( i , j )] ) stk . push ( pii ( i , j - 1 )); if ( j < c - 1 && ! is_wall [ id_v ( i , j + 1 )] ) stk . push ( pii ( i , j + 1 )); } } pii first_loop ; bool valid () { for ( int i = 0 ; i < c ; i ++ ) if ( ! is_wall [ id_h ( 0 , i )] ) stk . push ( pii ( 0 , i )); for ( int i = 0 ; i < c ; i ++ ) if ( ! is_wall [ id_h ( r , i )] ) stk . push ( pii ( r - 1 , i )); for ( int i = 1 ; i < r - 1 ; i ++ ) if ( ! is_wall [ id_v ( i , 0 )] ) stk . push ( pii ( i , 0 )); for ( int i = 1 ; i < r - 1 ; i ++ ) if ( ! is_wall [ id_v ( i , c )] ) stk . push ( pii ( i , c - 1 )); bool f = true ; for ( int i = 0 ; i < r && f ; i ++ ) for ( int j = 0 ; j < c ; j ++ ) if ( is_wall [ id_v ( i , j )] ) { stk . push ( pii ( i , j )); first_loop = pii ( i , j ); f = false ; break ; } memset ( vis , 0 , sizeof ( vis )); floodfill (); for ( int i = 0 ; i < r ; i ++ ) for ( int j = 0 ; j < c ; j ++ ) if ( ! vis [ i ][ j ] ) return false ; return true ; } void get_loop ( int i , int j , vector < int >& L ) { stk . push ( pii ( i , j )); while ( ! stk . empty () ) { pii v = stk . top (); stk . pop (); int i = v . first , j = v . second ; if ( vis [ i ][ j ] ) continue ; vis [ i ][ j ] = true ; if ( i > 0 && ! is_wall [ id_h ( i , j )] ) stk . push ( pii ( i - 1 , j )); if ( i < r - 1 && ! is_wall [ id_h ( i + 1 , j )] ) stk . push ( pii ( i + 1 , j )); if ( j > 0 && ! is_wall [ id_v ( i , j )] ) stk . push ( pii ( i , j - 1 )); if ( j < c - 1 && ! is_wall [ id_v ( i , j + 1 )] ) stk . push ( pii ( i , j + 1 )); if ( is_wall [ id_h ( i , j )] ) L . push_back ( id_h ( i , j )); if ( is_wall [ id_h ( i + 1 , j )] ) L . push_back ( id_h ( i + 1 , j )); if ( is_wall [ id_v ( i , j )] ) L . push_back ( id_v ( i , j )); if ( is_wall [ id_v ( i , j + 1 )] ) L . push_back ( id_v ( i , j + 1 )); } } int main () { IOS ; cin >> r >> c ; for ( int i = 0 ; i < r ; i ++ ) { string s ; cin >> s ; for ( int j = 0 ; j < c ; j ++ ) board [ i ][ j ] = s [ j ] - '0' ; } int nd = 2 * r * c + r + c ; sat :: Init ( nd ); for ( int i = 0 ; i < r ; i ++ ) { for ( int j = 0 ; j < c ; j ++ ) { vector < int > S = { id_h ( i , j ), id_h ( i + 1 , j ), id_v ( i , j ), id_v ( i , j + 1 )}; switch ( board [ i ][ j ] ) { case 0 : all_false ( S ); break ; case 1 : exactly_one ( S ); break ; case 2 : exactly_two ( S ); break ; case 3 : exactly_one_false ( S ); break ; } } } for ( int i = 0 ; i <= r ; i ++ ) { for ( int j = 0 ; j <= c ; j ++ ) { vector < int > v ; if ( i < r ) v . push_back ( id_v ( i , j )); if ( i > 0 ) v . push_back ( id_v ( i - 1 , j )); if ( j < c ) v . push_back ( id_h ( i , j )); if ( j > 0 ) v . push_back ( id_h ( i , j - 1 )); exactly_two_or_none ( v ); } } while ( true ) { if ( ! sat :: Solve () ) { cerr << \"cannot solve \\n \" ; exit ( 128 ); } memset ( is_wall , 0 , sizeof ( is_wall )); for ( int i = 1 ; i <= nd ; i ++ ) is_wall [ i ] = ( sat :: GetResult ( i ) == 1 ); if ( valid () ) { break ; } else { for ( int i = 0 ; i < r ; i ++ ) { for ( int j = 0 ; j < c ; j ++ ) { if ( ! vis [ i ][ j ] ) { vector < int > v ; get_loop ( i , j , v ); for ( int & i : v ) i = - i ; sat :: AddClause ( v ); } } } memset ( vis , 0 , sizeof ( vis )); vector < int > v ; get_loop ( first_loop . first , first_loop . second , v ); for ( int & i : v ) i = - i ; sat :: AddClause ( v ); } } for ( int i = 1 ; i <= nd ; i ++ ) cout << is_wall [ i ]; cout << '\\n' ; #ifdef DEBUG for ( int i = 0 ; i < r ; i ++ ) { for ( int j = 0 ; j < c ; j ++ ) cout << \"+\" << ( is_wall [ id_h ( i , j )] ? \"-\" : \" \" ); cout << \"+ \\n \" ; for ( int j = 0 ; j < c ; j ++ ) cout << ( is_wall [ id_v ( i , j )] ? \"|\" : \" \" ) << ( char )( board [ i ][ j ] + '0' ); cout << ( is_wall [ id_v ( i , c )] ? \"| \\n \" : \" \\n \" ); } for ( int j = 0 ; j < c ; j ++ ) cout << \"+\" << ( is_wall [ id_h ( r , j )] ? \"-\" : \" \" ); cout << \"+ \\n \" ; #endif return EXIT_SUCCESS ; }","title":"Loopy Tippy"},{"location":"courses/ada-fall-2019/hw4/loopy-tippy/#loopy-tippy","text":"","title":"Loopy Tippy"},{"location":"courses/ada-fall-2019/hw4/loopy-tippy/#problem-description","text":"Yun-Nung (Vivian) Chen's website","title":"Problem Description"},{"location":"courses/ada-fall-2019/hw4/loopy-tippy/#tas-hint","text":"The constraints can be modeled as three parts: The number of edges Simple loops Connectivity n^4 n^4 variables: x_{i,j}^t x_{i,j}^t denotes whether (i, j) (i, j) is reachable at time t t .","title":"TA's Hint"},{"location":"courses/ada-fall-2019/hw4/loopy-tippy/#online-resources","text":"Slitherlink Reloaded","title":"Online Resources"},{"location":"courses/ada-fall-2019/hw4/loopy-tippy/#code","text":"#include <bits/stdc++.h> #define IOS { ios::sync_with_stdio(false); cin.tie(nullptr); } #pragma GCC optimize(\"Ofast\", \"no-stack-protector\", \"unroll-loops\") #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,sse4.2,popcnt,abm,mmx,avx,tune=native\") #ifndef DIMACS #include <cryptominisat5/cryptominisat.h> #else #include <fstream> #include <vector> #endif namespace sat { #ifndef DIMACS CMSat :: SATSolver solver ; std :: vector < CMSat :: Lit > lit_buf ; void Init ( int n ) { solver . new_vars ( n + 1 ); } void AddClause ( std :: vector < int > v ) { lit_buf . clear (); lit_buf . reserve ( v . size ()); for ( int x : v ) lit_buf . emplace_back ( abs ( x ), x < 0 ); solver . add_clause ( lit_buf ); } bool Solve () { return solver . solve () == CMSat :: l_True ; } int GetResult ( int id ) { auto r = solver . get_model ()[ id ]; return r == CMSat :: l_True ? 1 : r == CMSat :: l_False ? - 1 : 0 ; } #else std :: vector < std :: vector < int >> clauses ; int n_vars ; void Init ( int n ) { n_vars = n ; } void AddClause ( std :: vector < int > v ) { clauses . emplace_back ( std :: move ( v )); } bool Solve () { std :: fstream fs ( \"out.dimacs\" , fs . trunc | fs . out ); fs << \"p cnf \" << n_vars << ' ' << clauses . size () << '\\n' ; for ( auto & v : clauses ) { for ( auto x : v ) fs << x << ' ' ; fs << \"0 \\n \" ; } fs . close (); exit ( 0 ); } int GetResult ( int id ) { return 0 ; } #endif // DIMACS } // namespace sat using namespace std ; using LL = long long ; using ULL = unsigned long long ; using pii = pair < int , int > ; constexpr int MAXR = 128 ; constexpr int MAXC = 128 ; int r , c , board [ MAXR ][ MAXC ]; bool is_wall [ MAXR + MAXC + 2 * MAXR * MAXC ]; inline int id_h ( int i , int j ) { return i * ( 2 * c + 1 ) + j + 1 ; } inline int id_v ( int i , int j ) { return c + i * ( 2 * c + 1 ) + j + 1 ; } void all_false ( vector < int >& S ) { for ( int v : S ) { vector < int > vv = { - v }; sat :: AddClause ( vv ); } } void exactly_one ( vector < int >& S ) { sat :: AddClause ( S ); int sz = S . size (); for ( int i = 0 ; i < sz ; i ++ ) for ( int j = i + 1 ; j < sz ; j ++ ) { vector < int > vv = { - S [ i ], - S [ j ]}; sat :: AddClause ( vv ); } } void exactly_one_false ( vector < int > & S ) { for ( int & v : S ) v = - v ; exactly_one ( S ); } void exactly_two ( vector < int > & S ) { for ( int i = 0 ; i < 4 ; i ++ ) { vector < int > vv ; for ( int j = 0 ; j < 4 ; j ++ ) if ( j != i ) vv . push_back ( S [ j ]); sat :: AddClause ( vv ); for ( int & v : vv ) v = - v ; sat :: AddClause ( vv ); } } void exactly_two_or_none ( vector < int > & S ) { if ( S . size () == 2 ) { vector < int > v1 = { - S [ 0 ], S [ 1 ]}, v2 = { S [ 0 ], - S [ 1 ]}; sat :: AddClause ( v1 ); sat :: AddClause ( v2 ); } else if ( S . size () == 3 ) { for ( int i = 0 ; i < 3 ; i ++ ) { S [ i ] = - S [ i ]; sat :: AddClause ( S ); S [ i ] = - S [ i ]; } for ( int & i : S ) i = - i ; sat :: AddClause ( S ); } else if ( S . size () == 4 ) { for ( int i = 0 ; i < 4 ; i ++ ) { S [ i ] = - S [ i ]; sat :: AddClause ( S ); S [ i ] = - S [ i ]; } for ( int i = 0 ; i < 4 ; i ++ ) { vector < int > vv ; for ( int j = 0 ; j < 4 ; j ++ ) if ( j != i ) vv . push_back ( - S [ j ]); sat :: AddClause ( vv ); } } } bool vis [ MAXR ][ MAXC ]; stack < pii > stk ; void floodfill () { while ( ! stk . empty () ) { pii v = stk . top (); stk . pop (); int i = v . first , j = v . second ; if ( vis [ i ][ j ] ) continue ; vis [ i ][ j ] = true ; if ( i > 0 && ! is_wall [ id_h ( i , j )] ) stk . push ( pii ( i - 1 , j )); if ( i < r - 1 && ! is_wall [ id_h ( i + 1 , j )] ) stk . push ( pii ( i + 1 , j )); if ( j > 0 && ! is_wall [ id_v ( i , j )] ) stk . push ( pii ( i , j - 1 )); if ( j < c - 1 && ! is_wall [ id_v ( i , j + 1 )] ) stk . push ( pii ( i , j + 1 )); } } pii first_loop ; bool valid () { for ( int i = 0 ; i < c ; i ++ ) if ( ! is_wall [ id_h ( 0 , i )] ) stk . push ( pii ( 0 , i )); for ( int i = 0 ; i < c ; i ++ ) if ( ! is_wall [ id_h ( r , i )] ) stk . push ( pii ( r - 1 , i )); for ( int i = 1 ; i < r - 1 ; i ++ ) if ( ! is_wall [ id_v ( i , 0 )] ) stk . push ( pii ( i , 0 )); for ( int i = 1 ; i < r - 1 ; i ++ ) if ( ! is_wall [ id_v ( i , c )] ) stk . push ( pii ( i , c - 1 )); bool f = true ; for ( int i = 0 ; i < r && f ; i ++ ) for ( int j = 0 ; j < c ; j ++ ) if ( is_wall [ id_v ( i , j )] ) { stk . push ( pii ( i , j )); first_loop = pii ( i , j ); f = false ; break ; } memset ( vis , 0 , sizeof ( vis )); floodfill (); for ( int i = 0 ; i < r ; i ++ ) for ( int j = 0 ; j < c ; j ++ ) if ( ! vis [ i ][ j ] ) return false ; return true ; } void get_loop ( int i , int j , vector < int >& L ) { stk . push ( pii ( i , j )); while ( ! stk . empty () ) { pii v = stk . top (); stk . pop (); int i = v . first , j = v . second ; if ( vis [ i ][ j ] ) continue ; vis [ i ][ j ] = true ; if ( i > 0 && ! is_wall [ id_h ( i , j )] ) stk . push ( pii ( i - 1 , j )); if ( i < r - 1 && ! is_wall [ id_h ( i + 1 , j )] ) stk . push ( pii ( i + 1 , j )); if ( j > 0 && ! is_wall [ id_v ( i , j )] ) stk . push ( pii ( i , j - 1 )); if ( j < c - 1 && ! is_wall [ id_v ( i , j + 1 )] ) stk . push ( pii ( i , j + 1 )); if ( is_wall [ id_h ( i , j )] ) L . push_back ( id_h ( i , j )); if ( is_wall [ id_h ( i + 1 , j )] ) L . push_back ( id_h ( i + 1 , j )); if ( is_wall [ id_v ( i , j )] ) L . push_back ( id_v ( i , j )); if ( is_wall [ id_v ( i , j + 1 )] ) L . push_back ( id_v ( i , j + 1 )); } } int main () { IOS ; cin >> r >> c ; for ( int i = 0 ; i < r ; i ++ ) { string s ; cin >> s ; for ( int j = 0 ; j < c ; j ++ ) board [ i ][ j ] = s [ j ] - '0' ; } int nd = 2 * r * c + r + c ; sat :: Init ( nd ); for ( int i = 0 ; i < r ; i ++ ) { for ( int j = 0 ; j < c ; j ++ ) { vector < int > S = { id_h ( i , j ), id_h ( i + 1 , j ), id_v ( i , j ), id_v ( i , j + 1 )}; switch ( board [ i ][ j ] ) { case 0 : all_false ( S ); break ; case 1 : exactly_one ( S ); break ; case 2 : exactly_two ( S ); break ; case 3 : exactly_one_false ( S ); break ; } } } for ( int i = 0 ; i <= r ; i ++ ) { for ( int j = 0 ; j <= c ; j ++ ) { vector < int > v ; if ( i < r ) v . push_back ( id_v ( i , j )); if ( i > 0 ) v . push_back ( id_v ( i - 1 , j )); if ( j < c ) v . push_back ( id_h ( i , j )); if ( j > 0 ) v . push_back ( id_h ( i , j - 1 )); exactly_two_or_none ( v ); } } while ( true ) { if ( ! sat :: Solve () ) { cerr << \"cannot solve \\n \" ; exit ( 128 ); } memset ( is_wall , 0 , sizeof ( is_wall )); for ( int i = 1 ; i <= nd ; i ++ ) is_wall [ i ] = ( sat :: GetResult ( i ) == 1 ); if ( valid () ) { break ; } else { for ( int i = 0 ; i < r ; i ++ ) { for ( int j = 0 ; j < c ; j ++ ) { if ( ! vis [ i ][ j ] ) { vector < int > v ; get_loop ( i , j , v ); for ( int & i : v ) i = - i ; sat :: AddClause ( v ); } } } memset ( vis , 0 , sizeof ( vis )); vector < int > v ; get_loop ( first_loop . first , first_loop . second , v ); for ( int & i : v ) i = - i ; sat :: AddClause ( v ); } } for ( int i = 1 ; i <= nd ; i ++ ) cout << is_wall [ i ]; cout << '\\n' ; #ifdef DEBUG for ( int i = 0 ; i < r ; i ++ ) { for ( int j = 0 ; j < c ; j ++ ) cout << \"+\" << ( is_wall [ id_h ( i , j )] ? \"-\" : \" \" ); cout << \"+ \\n \" ; for ( int j = 0 ; j < c ; j ++ ) cout << ( is_wall [ id_v ( i , j )] ? \"|\" : \" \" ) << ( char )( board [ i ][ j ] + '0' ); cout << ( is_wall [ id_v ( i , c )] ? \"| \\n \" : \" \\n \" ); } for ( int j = 0 ; j < c ; j ++ ) cout << \"+\" << ( is_wall [ id_h ( r , j )] ? \"-\" : \" \" ); cout << \"+ \\n \" ; #endif return EXIT_SUCCESS ; }","title":"Code"},{"location":"courses/ada-fall-2019/hw4/reachability-coefficient/","text":"Reachability Coefficient \u00b6 Problem Description \u00b6 Yun-Nung (Vivian) Chen's website TA's Hint \u00b6 f f is known as the \u201cJaccard similarity\u201d Concept \u00b6 Min Hash (single hash function variant) Code \u00b6 #include <bits/stdc++.h> #define IOS { ios::sync_with_stdio(false); cin.tie(nullptr); } #pragma GCC optimize(\"Ofast\", \"no-stack-protector\", \"unroll-loops\") #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,sse4.2,popcnt,abm,mmx,avx,tune=native\") using namespace std ; using LL = long long ; using ULL = unsigned long long ; using pii = pair < int , int > ; inline int read_int ( int & ); inline void write_int ( LL ); constexpr int MAXN = 2e5 + 5 ; constexpr int MOD = 1e9 + 7 ; constexpr int K = 300 ; constexpr int INF = 1e9 + 7 ; constexpr int SEED = 8787 ; int N , M , Q ; vector < int > G [ MAXN ]; bool vis [ MAXN ]; int H [ MAXN ]; int hk [ MAXN ][ K + 5 ], tmp [ 2 * K + 5 ]; int unite ( int * a , int * b , int * dst ) { int * a_end = a ; while ( * a_end != INF ) ++ a_end ; int * b_end = b ; while ( * b_end != INF ) ++ b_end ; ++ a_end ; // preserve one INF int sz = set_union ( a , a_end , b , b_end , tmp ) - tmp ; memcpy ( dst , tmp , sizeof ( int ) * K ); dst [ K ] = INF ; return min ( sz - 1 , K ); } int intersect ( int * a , int * b , int * dst ) { int * a_end = a ; while ( * a_end != INF ) ++ a_end ; int * b_end = b ; while ( * b_end != INF ) ++ b_end ; ++ a_end ; ++ b_end ; int sz = set_intersection ( a , a_end , b , b_end , tmp ) - tmp ; memcpy ( dst , tmp , sizeof ( int ) * K ); return sz - 1 ; } void dfs ( int v ) { vis [ v ] = true ; hk [ v ][ 0 ] = H [ v ], hk [ v ][ 1 ] = INF ; for ( int u : G [ v ] ) { if ( ! vis [ u ] ) dfs ( u ); unite ( hk [ v ], hk [ u ], hk [ v ]); } } int main () { srand ( SEED ); read_int ( N ); read_int ( M ); read_int ( Q ); for ( int i = 0 ; i < M ; i ++ ) { int from , to ; read_int ( from ); read_int ( to ); G [ from ]. push_back ( to ); } for ( int i = 1 ; i <= N ; i ++ ) H [ i ] = i ; random_shuffle ( H + 1 , H + N + 1 ); for ( int i = 1 ; i <= N ; i ++ ) if ( ! vis [ i ] ) dfs ( i ); for ( int q = 0 ; q < Q ; q ++ ) { int x , y ; read_int ( x ); read_int ( y ); int Y [ K + 5 ]; int S = unite ( hk [ x ], hk [ y ], Y ); intersect ( hk [ x ], Y , Y ); int sz = intersect ( hk [ y ], hk [ x ], Y ); double ans = ( double ) sz / S ; printf ( \"%lf \\n \" , ans ); } return EXIT_SUCCESS ; } // input optimize inline int read_char () { constexpr int N = 1 << 20 ; static char buf [ N ]; static char * p = buf , * end = buf ; if ( p == end ) { if ( ( end = buf + fread_unlocked ( buf , 1 , N , stdin )) == buf ) return EOF ; p = buf ; } return * p ++ ; } inline int read_int ( int & x ) { static char c , neg ; while ( ( c = read_char ()) < '-' ) if ( c == EOF ) return 0 ; neg = ( c == '-' ) ? - 1 : 1 ; x = ( neg == 1 ) ? c - '0' : 0 ; while ( ( c = read_char ()) >= '0' ) x = ( x << 3 ) + ( x << 1 ) + ( c - '0' ); x *= neg ; return 1 ; } // output optimize #define _pc putchar_unlocked char _buf [ 128 ]; inline void write_int ( LL x ) { if ( ! x ) { _pc ( '0' ); _pc ( '\\n' ); return ; } int t = 0 ; while ( x ) { _buf [ t ++ ] = x % 10 + '0' ; x /= 10 ; } while ( t -- ) _pc ( _buf [ t ]); _pc ( '\\n' ); } #undef _pc","title":"Reachability Coefficient"},{"location":"courses/ada-fall-2019/hw4/reachability-coefficient/#reachability-coefficient","text":"","title":"Reachability Coefficient"},{"location":"courses/ada-fall-2019/hw4/reachability-coefficient/#problem-description","text":"Yun-Nung (Vivian) Chen's website","title":"Problem Description"},{"location":"courses/ada-fall-2019/hw4/reachability-coefficient/#tas-hint","text":"f f is known as the \u201cJaccard similarity\u201d","title":"TA's Hint"},{"location":"courses/ada-fall-2019/hw4/reachability-coefficient/#concept","text":"Min Hash (single hash function variant)","title":"Concept"},{"location":"courses/ada-fall-2019/hw4/reachability-coefficient/#code","text":"#include <bits/stdc++.h> #define IOS { ios::sync_with_stdio(false); cin.tie(nullptr); } #pragma GCC optimize(\"Ofast\", \"no-stack-protector\", \"unroll-loops\") #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,sse4.2,popcnt,abm,mmx,avx,tune=native\") using namespace std ; using LL = long long ; using ULL = unsigned long long ; using pii = pair < int , int > ; inline int read_int ( int & ); inline void write_int ( LL ); constexpr int MAXN = 2e5 + 5 ; constexpr int MOD = 1e9 + 7 ; constexpr int K = 300 ; constexpr int INF = 1e9 + 7 ; constexpr int SEED = 8787 ; int N , M , Q ; vector < int > G [ MAXN ]; bool vis [ MAXN ]; int H [ MAXN ]; int hk [ MAXN ][ K + 5 ], tmp [ 2 * K + 5 ]; int unite ( int * a , int * b , int * dst ) { int * a_end = a ; while ( * a_end != INF ) ++ a_end ; int * b_end = b ; while ( * b_end != INF ) ++ b_end ; ++ a_end ; // preserve one INF int sz = set_union ( a , a_end , b , b_end , tmp ) - tmp ; memcpy ( dst , tmp , sizeof ( int ) * K ); dst [ K ] = INF ; return min ( sz - 1 , K ); } int intersect ( int * a , int * b , int * dst ) { int * a_end = a ; while ( * a_end != INF ) ++ a_end ; int * b_end = b ; while ( * b_end != INF ) ++ b_end ; ++ a_end ; ++ b_end ; int sz = set_intersection ( a , a_end , b , b_end , tmp ) - tmp ; memcpy ( dst , tmp , sizeof ( int ) * K ); return sz - 1 ; } void dfs ( int v ) { vis [ v ] = true ; hk [ v ][ 0 ] = H [ v ], hk [ v ][ 1 ] = INF ; for ( int u : G [ v ] ) { if ( ! vis [ u ] ) dfs ( u ); unite ( hk [ v ], hk [ u ], hk [ v ]); } } int main () { srand ( SEED ); read_int ( N ); read_int ( M ); read_int ( Q ); for ( int i = 0 ; i < M ; i ++ ) { int from , to ; read_int ( from ); read_int ( to ); G [ from ]. push_back ( to ); } for ( int i = 1 ; i <= N ; i ++ ) H [ i ] = i ; random_shuffle ( H + 1 , H + N + 1 ); for ( int i = 1 ; i <= N ; i ++ ) if ( ! vis [ i ] ) dfs ( i ); for ( int q = 0 ; q < Q ; q ++ ) { int x , y ; read_int ( x ); read_int ( y ); int Y [ K + 5 ]; int S = unite ( hk [ x ], hk [ y ], Y ); intersect ( hk [ x ], Y , Y ); int sz = intersect ( hk [ y ], hk [ x ], Y ); double ans = ( double ) sz / S ; printf ( \"%lf \\n \" , ans ); } return EXIT_SUCCESS ; } // input optimize inline int read_char () { constexpr int N = 1 << 20 ; static char buf [ N ]; static char * p = buf , * end = buf ; if ( p == end ) { if ( ( end = buf + fread_unlocked ( buf , 1 , N , stdin )) == buf ) return EOF ; p = buf ; } return * p ++ ; } inline int read_int ( int & x ) { static char c , neg ; while ( ( c = read_char ()) < '-' ) if ( c == EOF ) return 0 ; neg = ( c == '-' ) ? - 1 : 1 ; x = ( neg == 1 ) ? c - '0' : 0 ; while ( ( c = read_char ()) >= '0' ) x = ( x << 3 ) + ( x << 1 ) + ( c - '0' ); x *= neg ; return 1 ; } // output optimize #define _pc putchar_unlocked char _buf [ 128 ]; inline void write_int ( LL x ) { if ( ! x ) { _pc ( '0' ); _pc ( '\\n' ); return ; } int t = 0 ; while ( x ) { _buf [ t ++ ] = x % 10 + '0' ; x /= 10 ; } while ( t -- ) _pc ( _buf [ t ]); _pc ( '\\n' ); } #undef _pc","title":"Code"},{"location":"courses/ada-fall-2019/hw4/yet-another-permutation-problem/","text":"Reachability Coefficient \u00b6 Problem Description \u00b6 Yun-Nung (Vivian) Chen's website TA's Hint \u00b6 The problem is NP-Complete. Apply fast algorithm to solve it. Concept \u00b6 Reduce to Maximum Clique Problem (consider the matrix an \"adjancy matrix\") MaxCliqueDyn Algorithm (original paper was published in 2007) Code \u00b6 #include <bits/stdc++.h> #define IOS { ios::sync_with_stdio(false); cin.tie(nullptr); } #pragma GCC optimize(\"Ofast\", \"no-stack-protector\", \"unroll-loops\") #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,sse4.2,popcnt,abm,mmx,avx,tune=native\") using namespace std ; using ll = long long ; using ULL = unsigned long long ; using pii = pair < int , int > ; struct Vertex { int id , deg ; }; constexpr int MAXN = 120 ; using bst = bitset < MAXN > ; int N ; int A [ MAXN ][ MAXN ]; bool G [ MAXN ][ MAXN ]; vector < int > sol , Q ; vector < int > C [ MAXN ]; void add_edge ( int u , int v ) { G [ u ][ v ] = G [ v ][ u ] = 1 ; } bool test ( const int e , const vector < int >& S ) { for ( int i : S ) if ( G [ i ][ e ] ) return true ; return false ; } void color_sort ( vector < Vertex >& R ) { int max_no = 1 , j = 0 ; int k_min = sol . size () - Q . size () + 1 ; C [ 1 ]. clear (); C [ 2 ]. clear (); for ( int i = 0 ; i < R . size (); i ++ ) { int p = R [ i ]. id ; int k = 1 ; while ( test ( p , C [ k ]) ) ++ k ; if ( k > max_no ) { max_no = k ; C [ max_no + 1 ]. clear (); } C [ k ]. push_back ( p ); if ( k < k_min ) { R [ j ]. id = p ; ++ j ; } } if ( j > 0 ) R [ j - 1 ]. deg = 0 ; if ( k_min <= 0 ) k_min = 1 ; for ( int k = k_min ; k <= max_no ; ++ k ) { int sz = C [ k ]. size (); for ( int i = 0 ; i < sz ; i ++ ) { R [ j ]. id = C [ k ][ i ]; R [ j ]. deg = k ; ++ j ; } } } bool deg_cmp ( const Vertex u , const Vertex v ) { return u . deg > v . deg ; } void calc_deg ( vector < Vertex >& V ) { for ( Vertex & v : V ) { v . deg = 0 ; for ( int j = 0 ; j < N ; j ++ ) v . deg += ( int ) G [ v . id ][ j ]; } } void degree_sort ( vector < Vertex >& R ) { calc_deg ( R ); sort ( R . begin (), R . end (), deg_cmp ); } int S [ MAXN ], S_old [ MAXN ], ALLSTEP ; const double T_limit = 0.025 ; void expand_dyn ( vector < Vertex >& R , int level ) { S [ level ] = S [ level ] + S [ level - 1 ] - S_old [ level ]; S_old [ level ] = S [ level - 1 ]; while ( R . size () ) { if ( Q . size () + R . back (). deg <= sol . size () ) return ; int p = R . back (). id ; R . pop_back (); Q . push_back ( p ); vector < Vertex > Rp ; for ( Vertex v : R ) if ( G [ p ][ v . id ] ) Rp . push_back ( v ); if ( Rp . size () ) { if ( ( double ) S [ level ] / ++ ALLSTEP < T_limit ) degree_sort ( Rp ); color_sort ( Rp ); ++ S [ level ]; expand_dyn ( Rp , level + 1 ); } else if ( Q . size () > sol . size () ) { sol = vector < int > ( Q ); } Q . pop_back (); } } void init_V ( vector < Vertex >& V ) { calc_deg ( V ); sort ( V . begin (), V . end (), deg_cmp ); int mx_deg = V [ 0 ]. deg ; for ( int i = 0 ; i < mx_deg ; i ++ ) V [ i ]. deg = i + 1 ; for ( int i = mx_deg ; i < N ; i ++ ) V [ i ]. deg = mx_deg + 1 ; } void MCQdyn () { ALLSTEP = 0 ; vector < Vertex > V ; for ( int i = 0 ; i < N ; i ++ ) V . push_back ({ i , 0 }); init_V ( V ); memset ( S , 0 , sizeof ( S )); memset ( S_old , 0 , sizeof ( S_old )); expand_dyn ( V , 1 ); } int main () { IOS ; cin >> N ; for ( int i = 0 ; i < N ; i ++ ) { string s ; cin >> s ; for ( int j = 0 ; j < N ; j ++ ) { A [ i ][ j ] = s [ j ] - '0' ; } } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( A [ i ][ j ] && A [ j ][ i ] && A [ i ][ i ] && A [ j ][ j ] ) add_edge ( i , j ); } } MCQdyn (); int ans = sol . size (); bool used [ MAXN ] = { 0 }; for ( int i = 0 ; i < sol . size (); i ++ ) { used [ sol [ i ]] = true ; sol [ i ] ++ ; } for ( int i = 0 ; i < N ; i ++ ) if ( ! used [ i ] ) sol . push_back ( i + 1 ); for ( int i = 0 ; i < sol . size (); i ++ ) cout << sol [ i ] << \" \\n \" [ i == sol . size () - 1 ]; #ifdef DEBUG cout << \"max clique size = \" << ans << '\\n' ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) cout << A [ sol [ i ] - 1 ][ sol [ j ] - 1 ]; cout << '\\n' ; } #endif return EXIT_SUCCESS ; }","title":"Reachability Coefficient"},{"location":"courses/ada-fall-2019/hw4/yet-another-permutation-problem/#reachability-coefficient","text":"","title":"Reachability Coefficient"},{"location":"courses/ada-fall-2019/hw4/yet-another-permutation-problem/#problem-description","text":"Yun-Nung (Vivian) Chen's website","title":"Problem Description"},{"location":"courses/ada-fall-2019/hw4/yet-another-permutation-problem/#tas-hint","text":"The problem is NP-Complete. Apply fast algorithm to solve it.","title":"TA's Hint"},{"location":"courses/ada-fall-2019/hw4/yet-another-permutation-problem/#concept","text":"Reduce to Maximum Clique Problem (consider the matrix an \"adjancy matrix\") MaxCliqueDyn Algorithm (original paper was published in 2007)","title":"Concept"},{"location":"courses/ada-fall-2019/hw4/yet-another-permutation-problem/#code","text":"#include <bits/stdc++.h> #define IOS { ios::sync_with_stdio(false); cin.tie(nullptr); } #pragma GCC optimize(\"Ofast\", \"no-stack-protector\", \"unroll-loops\") #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,sse4.2,popcnt,abm,mmx,avx,tune=native\") using namespace std ; using ll = long long ; using ULL = unsigned long long ; using pii = pair < int , int > ; struct Vertex { int id , deg ; }; constexpr int MAXN = 120 ; using bst = bitset < MAXN > ; int N ; int A [ MAXN ][ MAXN ]; bool G [ MAXN ][ MAXN ]; vector < int > sol , Q ; vector < int > C [ MAXN ]; void add_edge ( int u , int v ) { G [ u ][ v ] = G [ v ][ u ] = 1 ; } bool test ( const int e , const vector < int >& S ) { for ( int i : S ) if ( G [ i ][ e ] ) return true ; return false ; } void color_sort ( vector < Vertex >& R ) { int max_no = 1 , j = 0 ; int k_min = sol . size () - Q . size () + 1 ; C [ 1 ]. clear (); C [ 2 ]. clear (); for ( int i = 0 ; i < R . size (); i ++ ) { int p = R [ i ]. id ; int k = 1 ; while ( test ( p , C [ k ]) ) ++ k ; if ( k > max_no ) { max_no = k ; C [ max_no + 1 ]. clear (); } C [ k ]. push_back ( p ); if ( k < k_min ) { R [ j ]. id = p ; ++ j ; } } if ( j > 0 ) R [ j - 1 ]. deg = 0 ; if ( k_min <= 0 ) k_min = 1 ; for ( int k = k_min ; k <= max_no ; ++ k ) { int sz = C [ k ]. size (); for ( int i = 0 ; i < sz ; i ++ ) { R [ j ]. id = C [ k ][ i ]; R [ j ]. deg = k ; ++ j ; } } } bool deg_cmp ( const Vertex u , const Vertex v ) { return u . deg > v . deg ; } void calc_deg ( vector < Vertex >& V ) { for ( Vertex & v : V ) { v . deg = 0 ; for ( int j = 0 ; j < N ; j ++ ) v . deg += ( int ) G [ v . id ][ j ]; } } void degree_sort ( vector < Vertex >& R ) { calc_deg ( R ); sort ( R . begin (), R . end (), deg_cmp ); } int S [ MAXN ], S_old [ MAXN ], ALLSTEP ; const double T_limit = 0.025 ; void expand_dyn ( vector < Vertex >& R , int level ) { S [ level ] = S [ level ] + S [ level - 1 ] - S_old [ level ]; S_old [ level ] = S [ level - 1 ]; while ( R . size () ) { if ( Q . size () + R . back (). deg <= sol . size () ) return ; int p = R . back (). id ; R . pop_back (); Q . push_back ( p ); vector < Vertex > Rp ; for ( Vertex v : R ) if ( G [ p ][ v . id ] ) Rp . push_back ( v ); if ( Rp . size () ) { if ( ( double ) S [ level ] / ++ ALLSTEP < T_limit ) degree_sort ( Rp ); color_sort ( Rp ); ++ S [ level ]; expand_dyn ( Rp , level + 1 ); } else if ( Q . size () > sol . size () ) { sol = vector < int > ( Q ); } Q . pop_back (); } } void init_V ( vector < Vertex >& V ) { calc_deg ( V ); sort ( V . begin (), V . end (), deg_cmp ); int mx_deg = V [ 0 ]. deg ; for ( int i = 0 ; i < mx_deg ; i ++ ) V [ i ]. deg = i + 1 ; for ( int i = mx_deg ; i < N ; i ++ ) V [ i ]. deg = mx_deg + 1 ; } void MCQdyn () { ALLSTEP = 0 ; vector < Vertex > V ; for ( int i = 0 ; i < N ; i ++ ) V . push_back ({ i , 0 }); init_V ( V ); memset ( S , 0 , sizeof ( S )); memset ( S_old , 0 , sizeof ( S_old )); expand_dyn ( V , 1 ); } int main () { IOS ; cin >> N ; for ( int i = 0 ; i < N ; i ++ ) { string s ; cin >> s ; for ( int j = 0 ; j < N ; j ++ ) { A [ i ][ j ] = s [ j ] - '0' ; } } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( A [ i ][ j ] && A [ j ][ i ] && A [ i ][ i ] && A [ j ][ j ] ) add_edge ( i , j ); } } MCQdyn (); int ans = sol . size (); bool used [ MAXN ] = { 0 }; for ( int i = 0 ; i < sol . size (); i ++ ) { used [ sol [ i ]] = true ; sol [ i ] ++ ; } for ( int i = 0 ; i < N ; i ++ ) if ( ! used [ i ] ) sol . push_back ( i + 1 ); for ( int i = 0 ; i < sol . size (); i ++ ) cout << sol [ i ] << \" \\n \" [ i == sol . size () - 1 ]; #ifdef DEBUG cout << \"max clique size = \" << ans << '\\n' ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) cout << A [ sol [ i ] - 1 ][ sol [ j ] - 1 ]; cout << '\\n' ; } #endif return EXIT_SUCCESS ; }","title":"Code"},{"location":"courses/sp-fall-2019/","text":"System Programming \u00b6 Instructor: Pu-Jen Cheng \u912d\u535c\u58ec Programming Assignments \u00b6 Hand-written Assignments \u00b6","title":"System Programming"},{"location":"courses/sp-fall-2019/#system-programming","text":"Instructor: Pu-Jen Cheng \u912d\u535c\u58ec","title":"System Programming"},{"location":"courses/sp-fall-2019/#programming-assignments","text":"","title":"Programming Assignments"},{"location":"courses/sp-fall-2019/#hand-written-assignments","text":"","title":"Hand-written Assignments"},{"location":"misc/","text":"Miscellaneous \u00b6 Kubuntu installation note","title":"Miscellaneous"},{"location":"misc/#miscellaneous","text":"Kubuntu installation note","title":"Miscellaneous"},{"location":"misc/kubuntu-installation-note/","text":"Kubuntu Installation Note \u00b6 Because I frequently mess up my operating system, plus I am so bad at debugging Linux issues, I usually just resort to reinstallation . So to minimize the time wasted, I make this note.... set terminal shortcut \u00b6 System Settings -> Shortcuts -> custom shortcut -> edit -> new .... action is \"konsole\" (lowercase) install chrome \u00b6 Just do it Set Chrome as default browser \u00b6 update : the easy way: create a temporary html file, right click -> file extension setting -> change the priority Beside the one in System Setting, run: xdg-mime default google-chrome.desktop text/html Check ~/.config/mimeapps.list install packages \u00b6 vim wget curl build-essential git zsh exfat-fuse exfat-utils tmux python3-pip sudo apt install vim wget curl build-essential git zsh exfat-fuse exfat-utils tmux python3-pip dotfiles \u00b6 .profile .tmux.conf .vimrc generate ssh key and deploy \u00b6 ssh-keygen && ssh-copy-id b07902075@linux1.csie.org add ssh key to github clone repo \u00b6 Just do it install vscode \u00b6 extensions: material theme(dark), git lens install chinese pinyin input method (fcitx + google-pinyin) \u00b6 Install required packages sudo apt install fcitx-bin fcitx-config-gtk2 fcitx-frontend-qt4 fcitx-frontend-qt5 fcitx-googlepinyin fcitx-imlist fcitx-module-dbus Edit /etc/enviroment GTK_IM_MODULE = fcitx QT_IM_MODULE = fcitx XMODIFIERS = \"@im=fcitx\" Edit ~/.xprofile export GTK_IM_MODULE = fcitx export QT_IM_MODULE = fcitx export XMODIFIERS = \"@im=fcitx\" In System Settings -> Regional Settings -> Language change some setting Run im-config In System Settings , add fcitx to start-up routine Reboot In fcitx's configuration panel, add google-pinyin If you cannot toggle to traditional chinese, try ctrl+shift+F If there is error when starting fcitx, it is possibly an ibus related issue If fcitx still doesn't work, try run fcitx-diagnose install mkdocs for this website \u00b6 pip install mkdocs mkdocs-material mkdocs-macros-plugin pymdown-extensions install oh-my-zsh \u00b6 go to official page on github and follow its instructions configure themes \u00b6 Breeze, Breeze, Breeze... google cursor","title":"Kubuntu Installation Note"},{"location":"misc/kubuntu-installation-note/#kubuntu-installation-note","text":"Because I frequently mess up my operating system, plus I am so bad at debugging Linux issues, I usually just resort to reinstallation . So to minimize the time wasted, I make this note....","title":"Kubuntu Installation Note"},{"location":"misc/kubuntu-installation-note/#set-terminal-shortcut","text":"System Settings -> Shortcuts -> custom shortcut -> edit -> new .... action is \"konsole\" (lowercase)","title":"set terminal shortcut"},{"location":"misc/kubuntu-installation-note/#install-chrome","text":"Just do it","title":"install chrome"},{"location":"misc/kubuntu-installation-note/#set-chrome-as-default-browser","text":"update : the easy way: create a temporary html file, right click -> file extension setting -> change the priority Beside the one in System Setting, run: xdg-mime default google-chrome.desktop text/html Check ~/.config/mimeapps.list","title":"Set Chrome as default browser"},{"location":"misc/kubuntu-installation-note/#install-packages","text":"vim wget curl build-essential git zsh exfat-fuse exfat-utils tmux python3-pip sudo apt install vim wget curl build-essential git zsh exfat-fuse exfat-utils tmux python3-pip","title":"install packages"},{"location":"misc/kubuntu-installation-note/#dotfiles","text":".profile .tmux.conf .vimrc","title":"dotfiles"},{"location":"misc/kubuntu-installation-note/#generate-ssh-key-and-deploy","text":"ssh-keygen && ssh-copy-id b07902075@linux1.csie.org add ssh key to github","title":"generate ssh key and deploy"},{"location":"misc/kubuntu-installation-note/#clone-repo","text":"Just do it","title":"clone repo"},{"location":"misc/kubuntu-installation-note/#install-vscode","text":"extensions: material theme(dark), git lens","title":"install vscode"},{"location":"misc/kubuntu-installation-note/#install-chinese-pinyin-input-method-fcitx-google-pinyin","text":"Install required packages sudo apt install fcitx-bin fcitx-config-gtk2 fcitx-frontend-qt4 fcitx-frontend-qt5 fcitx-googlepinyin fcitx-imlist fcitx-module-dbus Edit /etc/enviroment GTK_IM_MODULE = fcitx QT_IM_MODULE = fcitx XMODIFIERS = \"@im=fcitx\" Edit ~/.xprofile export GTK_IM_MODULE = fcitx export QT_IM_MODULE = fcitx export XMODIFIERS = \"@im=fcitx\" In System Settings -> Regional Settings -> Language change some setting Run im-config In System Settings , add fcitx to start-up routine Reboot In fcitx's configuration panel, add google-pinyin If you cannot toggle to traditional chinese, try ctrl+shift+F If there is error when starting fcitx, it is possibly an ibus related issue If fcitx still doesn't work, try run fcitx-diagnose","title":"install chinese pinyin input method (fcitx + google-pinyin)"},{"location":"misc/kubuntu-installation-note/#install-mkdocs-for-this-website","text":"pip install mkdocs mkdocs-material mkdocs-macros-plugin pymdown-extensions","title":"install mkdocs for this website"},{"location":"misc/kubuntu-installation-note/#install-oh-my-zsh","text":"go to official page on github and follow its instructions","title":"install oh-my-zsh"},{"location":"misc/kubuntu-installation-note/#configure-themes","text":"Breeze, Breeze, Breeze... google cursor","title":"configure themes"}]}