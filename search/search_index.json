{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Computer Science Note \u00b6 The documentation in this site is for: organize my knowledge better create a better view of what I have learned Courses \u00b6 This area mostly contains homework assignments, sometimes with some class notes. Algorithms \u00b6 My own implementation of some algorithms, mainly in C++. Miscellaneous \u00b6 Things that are hard to categorized, like Latex, Linux....","title":"Home"},{"location":"#computer-science-note","text":"The documentation in this site is for: organize my knowledge better create a better view of what I have learned","title":"Computer Science Note"},{"location":"#courses","text":"This area mostly contains homework assignments, sometimes with some class notes.","title":"Courses"},{"location":"#algorithms","text":"My own implementation of some algorithms, mainly in C++.","title":"Algorithms"},{"location":"#miscellaneous","text":"Things that are hard to categorized, like Latex, Linux....","title":"Miscellaneous"},{"location":"about/","text":"Author \u00b6 Department of Computer Science and Information Engineering in National Taiwan University That's all(?)","title":"About"},{"location":"about/#author","text":"Department of Computer Science and Information Engineering in National Taiwan University That's all(?)","title":"Author"},{"location":"algorithms/","text":"Algorithms \u00b6 Data Structures \u00b6 Segment Tree Graph \u00b6 Depth First Search","title":"Algorithms"},{"location":"algorithms/#algorithms","text":"","title":"Algorithms"},{"location":"algorithms/#data-structures","text":"Segment Tree","title":"Data Structures"},{"location":"algorithms/#graph","text":"Depth First Search","title":"Graph"},{"location":"algorithms/dfs/","text":"Depth First Search \u00b6 Basic DFS \u00b6 constexpr int MAXN = 1e3 + 5 ; int N ; vector < int > G [ MAXN ]; int color [ MAXN ], tin [ MAXN ], tout [ MAXN ], timer ; const int WHITE = 0 , GREY = 1 , BLACK = 2 ; void is_back_edge ( int from , int to ) {} void is_cross_edge ( int from , int to ) {} bool is_ancestor ( int anc , int des ) { return tin [ anc ] < tin [ des ] && tout [ anc ] > tout [ des ]; } void dfs_util ( int v ) { color [ v ] = GREY ; tin [ v ] = timer ++ ; for ( int u : G [ v ] ) { if ( color [ u ] == WHITE ) dfs_util ( u ); else if ( color [ u ] == GREY ) is_back_edge ( v , u ); else if ( color [ u ] == BLACK ) is_cross_edge ( v , u ); } color [ v ] = BLACK ; tout [ v ] = timer ++ ; } void dfs () { fill ( color , color + N , WHITE ); timer = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( color [ i ] == WHITE ) dfs_util ( i ); } Topological Sort \u00b6 Find bridge \u00b6","title":"Depth First Search"},{"location":"algorithms/dfs/#depth-first-search","text":"","title":"Depth First Search"},{"location":"algorithms/dfs/#basic-dfs","text":"constexpr int MAXN = 1e3 + 5 ; int N ; vector < int > G [ MAXN ]; int color [ MAXN ], tin [ MAXN ], tout [ MAXN ], timer ; const int WHITE = 0 , GREY = 1 , BLACK = 2 ; void is_back_edge ( int from , int to ) {} void is_cross_edge ( int from , int to ) {} bool is_ancestor ( int anc , int des ) { return tin [ anc ] < tin [ des ] && tout [ anc ] > tout [ des ]; } void dfs_util ( int v ) { color [ v ] = GREY ; tin [ v ] = timer ++ ; for ( int u : G [ v ] ) { if ( color [ u ] == WHITE ) dfs_util ( u ); else if ( color [ u ] == GREY ) is_back_edge ( v , u ); else if ( color [ u ] == BLACK ) is_cross_edge ( v , u ); } color [ v ] = BLACK ; tout [ v ] = timer ++ ; } void dfs () { fill ( color , color + N , WHITE ); timer = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( color [ i ] == WHITE ) dfs_util ( i ); }","title":"Basic DFS"},{"location":"algorithms/dfs/#topological-sort","text":"","title":"Topological Sort"},{"location":"algorithms/dfs/#find-bridge","text":"","title":"Find bridge"},{"location":"algorithms/segment-tree/","text":"Implementation \u00b6 struct SegTree { constexpr static int MAXN = 1e5 + 5 ; int N ; int A [ MAXN ]; int T [ 4 * MAXN ], tag [ 4 * MAXN ]; void init ( int _N ) { N = _N ; } int lch ( int v ) { return v << 1 ; } int rch ( int v ) { return ( v << 1 ) | 1 ; } int combine ( int a , int b ) { return a + b ; } void pull ( int v ) { T [ v ] = combine ( T [ lch ( v )], T [ rch ( v )]); } void push ( int v , int l , int r ) { if ( tag [ v ] ) { int m = ( l + r ) >> 1 , lc = lch ( v ), rc = rch ( v ); T [ lc ] += ( m - l + 1 ) * tag [ v ]; T [ rc ] += ( r - m ) * tag [ v ]; tag [ lc ] += tag [ v ]; tag [ rc ] += tag [ v ]; tag [ v ] = 0 ; } } void build ( int v , int tl , int tr ) { if ( tl == tr ) { T [ v ] = A [ tl ]; } else { int tm = ( tl + tr ) >> 1 ; build ( lch ( v ), tl , tm ); build ( rch ( v ), tm + 1 , tr ); pull ( v ); } } int qry ( int v , int tl , int tr , int l , int r ) { if ( l > tr || r < tl ) return 0 ; if ( l <= tl && r >= tr ) return T [ v ]; int tm = ( tl + tr ) >> 1 ; push ( v , tl , tr ); return combine ( qry ( lch ( v ), tl , tm , l , r ), qry ( rch ( v ), tm + 1 , tr , l , r )); } void upd ( int v , int tl , int tr , int l , int r , int add ) { if ( l > tr || r < tl ) return ; if ( l <= tl && r >= tr ) { tag [ v ] += add ; T [ v ] += add * ( r - l + 1 ); return ; } int tm = ( tl + tr ) >> 1 ; push ( v , tl , tr ); upd ( lch ( v ), tl , tm , l , r , add ); upd ( rch ( v ), tm + 1 , tr , l , r , add ); pull ( v ); } } seg ;","title":"Segment tree"},{"location":"algorithms/segment-tree/#implementation","text":"struct SegTree { constexpr static int MAXN = 1e5 + 5 ; int N ; int A [ MAXN ]; int T [ 4 * MAXN ], tag [ 4 * MAXN ]; void init ( int _N ) { N = _N ; } int lch ( int v ) { return v << 1 ; } int rch ( int v ) { return ( v << 1 ) | 1 ; } int combine ( int a , int b ) { return a + b ; } void pull ( int v ) { T [ v ] = combine ( T [ lch ( v )], T [ rch ( v )]); } void push ( int v , int l , int r ) { if ( tag [ v ] ) { int m = ( l + r ) >> 1 , lc = lch ( v ), rc = rch ( v ); T [ lc ] += ( m - l + 1 ) * tag [ v ]; T [ rc ] += ( r - m ) * tag [ v ]; tag [ lc ] += tag [ v ]; tag [ rc ] += tag [ v ]; tag [ v ] = 0 ; } } void build ( int v , int tl , int tr ) { if ( tl == tr ) { T [ v ] = A [ tl ]; } else { int tm = ( tl + tr ) >> 1 ; build ( lch ( v ), tl , tm ); build ( rch ( v ), tm + 1 , tr ); pull ( v ); } } int qry ( int v , int tl , int tr , int l , int r ) { if ( l > tr || r < tl ) return 0 ; if ( l <= tl && r >= tr ) return T [ v ]; int tm = ( tl + tr ) >> 1 ; push ( v , tl , tr ); return combine ( qry ( lch ( v ), tl , tm , l , r ), qry ( rch ( v ), tm + 1 , tr , l , r )); } void upd ( int v , int tl , int tr , int l , int r , int add ) { if ( l > tr || r < tl ) return ; if ( l <= tl && r >= tr ) { tag [ v ] += add ; T [ v ] += add * ( r - l + 1 ); return ; } int tm = ( tl + tr ) >> 1 ; push ( v , tl , tr ); upd ( lch ( v ), tl , tm , l , r , add ); upd ( rch ( v ), tm + 1 , tr , l , r , add ); pull ( v ); } } seg ;","title":"Implementation"},{"location":"courses/","text":"Courses \u00b6 Fall, 2019 \u00b6 Algorithm Design and Analysis System Programming Spring, 2019 \u00b6 Network Administration and System Administration","title":"Courses"},{"location":"courses/#courses","text":"","title":"Courses"},{"location":"courses/#fall-2019","text":"Algorithm Design and Analysis System Programming","title":"Fall, 2019"},{"location":"courses/#spring-2019","text":"Network Administration and System Administration","title":"Spring, 2019"},{"location":"courses/ada-fall-2019/","text":"Algorithm Design and Analysis \u00b6 Instructor: Hsu-Chun Hsiao \u856d\u65ed\u541b Homework 1 \u00b6 Topics: Divide & Conquer, Dynamic Programming Programming Part: ADA Meetup Maximum Subarray Revisited Good Subpermutations Different Strings Hand-written Part: PDF file Homework 2 \u00b6 Topics: Dynamic Programming, Greedy Algorithm Programming Part: Line of Battle Chunithm Pokemon GO Weigh Anchor Hand-written Part: PDF file Homework 3 \u00b6 Topics: Graph Programming Part: Idol Master! Traveling Pony Problem Magic Song Hand-written Part: PDF file Homework 4 \u00b6 Topics: NP-Completeness Programming Part: Loopy Tippy Reachability Coefficient Yet Another Permutation Problem Hex Hand-written Part: PDF file","title":"Algorithm Design and Analysis"},{"location":"courses/ada-fall-2019/#algorithm-design-and-analysis","text":"Instructor: Hsu-Chun Hsiao \u856d\u65ed\u541b","title":"Algorithm Design and Analysis"},{"location":"courses/ada-fall-2019/#homework-1","text":"Topics: Divide & Conquer, Dynamic Programming Programming Part: ADA Meetup Maximum Subarray Revisited Good Subpermutations Different Strings Hand-written Part: PDF file","title":"Homework 1"},{"location":"courses/ada-fall-2019/#homework-2","text":"Topics: Dynamic Programming, Greedy Algorithm Programming Part: Line of Battle Chunithm Pokemon GO Weigh Anchor Hand-written Part: PDF file","title":"Homework 2"},{"location":"courses/ada-fall-2019/#homework-3","text":"Topics: Graph Programming Part: Idol Master! Traveling Pony Problem Magic Song Hand-written Part: PDF file","title":"Homework 3"},{"location":"courses/ada-fall-2019/#homework-4","text":"Topics: NP-Completeness Programming Part: Loopy Tippy Reachability Coefficient Yet Another Permutation Problem Hex Hand-written Part: PDF file","title":"Homework 4"},{"location":"courses/ada-fall-2019/hw1/ada-meetup/","text":"ADA Meetup \u00b6 Problem Description \u00b6 Yun-Nung (Vivian) Chen's website Concept \u00b6 \u96e2\u6563\u5316 BIT Code \u00b6 #include <bits/stdc++.h> #define IOS {ios::sync_with_stdio(false);cin.tie(nullptr);} #pragma GCC optimize(\"Ofast\", \"no-stack-protector\", \"unroll-loops\") #pragma GCC optimize(\"no-stack-protector\") #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,sse4.2,popcnt,abm,mmx,avx,tune=native\") #pragma GCC diagnostic ignored \"-W\" using namespace std ; using LL = int64_t ; using ULL = uint64_t ; using LD = long double ; // input optimize inline int read_char () { constexpr int N = 1 << 20 ; static char buf [ N ]; static char * p = buf , * end = buf ; if ( p == end ) { if ( ( end = buf + fread ( buf , 1 , N , stdin )) == buf ) return EOF ; p = buf ; } return * p ++ ; } inline int read_int ( int & x ) { static char c , neg ; while ( ( c = read_char ()) < '-' ) if ( c == EOF ) return 0 ; neg = ( c == '-' ) ? - 1 : 1 ; x = ( neg == 1 ) ? c - '0' : 0 ; while ( ( c = read_char ()) >= '0' ) x = ( x << 3 ) + ( x << 1 ) + ( c - '0' ); x *= neg ; return 1 ; } const int MAXN = 1e6 + 5 ; int N ; int P [ MAXN ], F [ MAXN ], * ptr [ MAXN ], mp [ MAXN ]; bool cmp ( int * a , int * b ) { return * a < * b ; } int bit [ MAXN ]; inline int lowbit ( int x ) { return x & - x ; } int sum ( int idx ) { int ret = 0 ; for ( ; idx > 0 ; idx -= lowbit ( idx ) ) ret += bit [ idx ]; return ret ; } inline int sum ( int L , int R ) { if ( L < 1 ) L = 1 ; return sum ( R ) - sum ( L - 1 ); } void add ( int idx , int delta , int n ) { for ( ; idx <= n ; idx += lowbit ( idx ) ) bit [ idx ] += delta ; } int main () { read_int ( N ); for ( int i = 1 ; i <= N ; i ++ ) read_int ( P [ i ]); for ( int i = 1 ; i <= N ; i ++ ) read_int ( F [ i ]); for ( int i = 1 ; i <= N ; i ++ ) ptr [ i ] = & P [ i ]; sort ( ptr + 1 , ptr + N + 1 , cmp ); int n = 0 ; for ( int i = 1 ; i <= N ; ) { int v = * ptr [ i ]; ++ n ; for ( ; i <= N && * ptr [ i ] == v ; i ++ ) mp [ ptr [ i ] - P ] = n ; } long long ans = 0 ; add ( mp [ 1 ], 1 , n ); for ( int i = 2 ; i <= N ; i ++ ) { int lb = P [ i ] - F [ i ], ub = P [ i ] + F [ i ]; auto ll = lower_bound ( ptr + 1 , ptr + 1 + N , & lb , cmp ); auto rr = upper_bound ( ptr + 1 , ptr + 1 + N , & ub , cmp ) - 1 ; lb = mp [ * ll - P ]; ub = mp [ * rr - P ]; ans += sum ( lb , ub ); add ( mp [ i ], 1 , n ); } printf ( \"%lld \\n \" , ans ); return 0 ; } Tricks \u00b6 Just use GNU policy based data structures","title":"ADA Meetup"},{"location":"courses/ada-fall-2019/hw1/ada-meetup/#ada-meetup","text":"","title":"ADA Meetup"},{"location":"courses/ada-fall-2019/hw1/ada-meetup/#problem-description","text":"Yun-Nung (Vivian) Chen's website","title":"Problem Description"},{"location":"courses/ada-fall-2019/hw1/ada-meetup/#concept","text":"\u96e2\u6563\u5316 BIT","title":"Concept"},{"location":"courses/ada-fall-2019/hw1/ada-meetup/#code","text":"#include <bits/stdc++.h> #define IOS {ios::sync_with_stdio(false);cin.tie(nullptr);} #pragma GCC optimize(\"Ofast\", \"no-stack-protector\", \"unroll-loops\") #pragma GCC optimize(\"no-stack-protector\") #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,sse4.2,popcnt,abm,mmx,avx,tune=native\") #pragma GCC diagnostic ignored \"-W\" using namespace std ; using LL = int64_t ; using ULL = uint64_t ; using LD = long double ; // input optimize inline int read_char () { constexpr int N = 1 << 20 ; static char buf [ N ]; static char * p = buf , * end = buf ; if ( p == end ) { if ( ( end = buf + fread ( buf , 1 , N , stdin )) == buf ) return EOF ; p = buf ; } return * p ++ ; } inline int read_int ( int & x ) { static char c , neg ; while ( ( c = read_char ()) < '-' ) if ( c == EOF ) return 0 ; neg = ( c == '-' ) ? - 1 : 1 ; x = ( neg == 1 ) ? c - '0' : 0 ; while ( ( c = read_char ()) >= '0' ) x = ( x << 3 ) + ( x << 1 ) + ( c - '0' ); x *= neg ; return 1 ; } const int MAXN = 1e6 + 5 ; int N ; int P [ MAXN ], F [ MAXN ], * ptr [ MAXN ], mp [ MAXN ]; bool cmp ( int * a , int * b ) { return * a < * b ; } int bit [ MAXN ]; inline int lowbit ( int x ) { return x & - x ; } int sum ( int idx ) { int ret = 0 ; for ( ; idx > 0 ; idx -= lowbit ( idx ) ) ret += bit [ idx ]; return ret ; } inline int sum ( int L , int R ) { if ( L < 1 ) L = 1 ; return sum ( R ) - sum ( L - 1 ); } void add ( int idx , int delta , int n ) { for ( ; idx <= n ; idx += lowbit ( idx ) ) bit [ idx ] += delta ; } int main () { read_int ( N ); for ( int i = 1 ; i <= N ; i ++ ) read_int ( P [ i ]); for ( int i = 1 ; i <= N ; i ++ ) read_int ( F [ i ]); for ( int i = 1 ; i <= N ; i ++ ) ptr [ i ] = & P [ i ]; sort ( ptr + 1 , ptr + N + 1 , cmp ); int n = 0 ; for ( int i = 1 ; i <= N ; ) { int v = * ptr [ i ]; ++ n ; for ( ; i <= N && * ptr [ i ] == v ; i ++ ) mp [ ptr [ i ] - P ] = n ; } long long ans = 0 ; add ( mp [ 1 ], 1 , n ); for ( int i = 2 ; i <= N ; i ++ ) { int lb = P [ i ] - F [ i ], ub = P [ i ] + F [ i ]; auto ll = lower_bound ( ptr + 1 , ptr + 1 + N , & lb , cmp ); auto rr = upper_bound ( ptr + 1 , ptr + 1 + N , & ub , cmp ) - 1 ; lb = mp [ * ll - P ]; ub = mp [ * rr - P ]; ans += sum ( lb , ub ); add ( mp [ i ], 1 , n ); } printf ( \"%lld \\n \" , ans ); return 0 ; }","title":"Code"},{"location":"courses/ada-fall-2019/hw1/ada-meetup/#tricks","text":"Just use GNU policy based data structures","title":"Tricks"},{"location":"courses/ada-fall-2019/hw1/different-strings/","text":"Maximum Subarray Revisited \u00b6 Problem Description \u00b6 Yun-Nung (Vivian) Chen's website Concept \u00b6 Reversed Edit Distance Problem Code \u00b6 #include <bits/stdc++.h> #define IOS {ios::sync_with_stdio(false);cin.tie(nullptr);} #define gc getchar_unlocked() #pragma GCC optimize(\"Ofast\", \"no-stack-protector\", \"unroll-loops\") #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,sse4.2,popcnt,abm,mmx,avx,tune=native\") using namespace std ; const int MAXL = 2001 ; int na , nb ; char Sa [ MAXL ], Sb [ MAXL ]; int dp [ MAXL ][ MAXL ]; inline int min ( int a , int b ) { return a < b ? a : b ; } int main () { while ( ( Sa [ na ] = gc ) != '\\n' ) ++ na ; while ( ( Sb [ nb ] = gc ) >= 'A' ) ++ nb ; for ( int a = na - 1 ; a >= 0 ; -- a ) { for ( int b = nb - 1 ; b >= 0 ; -- b ) { if ( Sa [ a ] == Sb [ b ] ) dp [ a ][ b ] = 1 + min ( dp [ a + 1 ][ b + 1 ], min ( dp [ a ][ b + 1 ], dp [ a + 1 ][ b ])); else dp [ a ][ b ] = dp [ a + 1 ][ b + 1 ]; } } cout << dp [ 0 ][ 0 ]; return 0 ; }","title":"Maximum Subarray Revisited"},{"location":"courses/ada-fall-2019/hw1/different-strings/#maximum-subarray-revisited","text":"","title":"Maximum Subarray Revisited"},{"location":"courses/ada-fall-2019/hw1/different-strings/#problem-description","text":"Yun-Nung (Vivian) Chen's website","title":"Problem Description"},{"location":"courses/ada-fall-2019/hw1/different-strings/#concept","text":"Reversed Edit Distance Problem","title":"Concept"},{"location":"courses/ada-fall-2019/hw1/different-strings/#code","text":"#include <bits/stdc++.h> #define IOS {ios::sync_with_stdio(false);cin.tie(nullptr);} #define gc getchar_unlocked() #pragma GCC optimize(\"Ofast\", \"no-stack-protector\", \"unroll-loops\") #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,sse4.2,popcnt,abm,mmx,avx,tune=native\") using namespace std ; const int MAXL = 2001 ; int na , nb ; char Sa [ MAXL ], Sb [ MAXL ]; int dp [ MAXL ][ MAXL ]; inline int min ( int a , int b ) { return a < b ? a : b ; } int main () { while ( ( Sa [ na ] = gc ) != '\\n' ) ++ na ; while ( ( Sb [ nb ] = gc ) >= 'A' ) ++ nb ; for ( int a = na - 1 ; a >= 0 ; -- a ) { for ( int b = nb - 1 ; b >= 0 ; -- b ) { if ( Sa [ a ] == Sb [ b ] ) dp [ a ][ b ] = 1 + min ( dp [ a + 1 ][ b + 1 ], min ( dp [ a ][ b + 1 ], dp [ a + 1 ][ b ])); else dp [ a ][ b ] = dp [ a + 1 ][ b + 1 ]; } } cout << dp [ 0 ][ 0 ]; return 0 ; }","title":"Code"},{"location":"courses/ada-fall-2019/hw1/good-subpermutations/","text":"Maximum Subarray Revisited \u00b6 Problem Description \u00b6 Yun-Nung (Vivian) Chen's website Concept \u00b6 This problem is so difficult...... Code \u00b6 #include <bits/stdc++.h> #define IOS {ios::sync_with_stdio(false);cin.tie(nullptr);} #pragma GCC optimize(\"Ofast\", \"no-stack-protector\", \"unroll-loops\") #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,sse4.2,popcnt,abm,mmx,avx,tune=native\") using namespace std ; using LL = long long ; inline int read_char (); inline int read_int ( int & ); const int MAXN = 5e5 + 5 , NN = 1e6 + 5 ; const int T = 40 ; int N , A [ MAXN ], Mx [ MAXN ], Mn [ MAXN ]; int cnt [ NN ], cnt2 [ NN ]; LL Ans ; void solve ( int L , int R ) { if ( L == R ) return void ( ++ Ans ); if ( R - L <= T ) { for ( int l = L ; l <= R ; l ++ ) { int mx = A [ l ], mn = A [ l ]; for ( int r = l ; r <= R ; r ++ ) { mx = max ( mx , A [ r ]); mn = min ( mn , A [ r ]); Ans += ( mx - mn == r - l ); } } return ; } // D & C int m = ( L + R ) >> 1 ; solve ( L , m ); solve ( m + 1 , R ); // preprocess Mx [ m ] = Mn [ m ] = A [ m ]; for ( int i = m - 1 ; i >= L ; i -- ) Mx [ i ] = max ( Mx [ i + 1 ], A [ i ]), Mn [ i ] = min ( Mn [ i + 1 ], A [ i ]); Mx [ m + 1 ] = Mn [ m + 1 ] = A [ m + 1 ]; cnt [ Mn [ m + 1 ] + m + 1 ] = cnt2 [ Mx [ m + 1 ] - m - 1 + N ] = 0 ; for ( int i = m + 2 ; i <= R ; i ++ ) { Mx [ i ] = max ( Mx [ i - 1 ], A [ i ]), Mn [ i ] = min ( Mn [ i - 1 ], A [ i ]); cnt [ Mn [ i ] + i ] = cnt2 [ Mx [ i ] - i + N ] = 0 ; } // cross subarray int pmx = m , pmn = m ; for ( int r = m + 1 ; r <= R ; r ++ ) { int mx_r = Mx [ r ], mn_r = Mn [ r ]; for ( ; pmx >= L && Mx [ pmx ] < mx_r ; pmx -- ) { -- cnt [ Mx [ pmx ] + pmx ]; ++ cnt2 [ Mn [ pmx ] - pmx + N ]; } for ( ; pmn >= L && Mn [ pmn ] > mn_r ; pmn -- ) { ++ cnt [ Mx [ pmn ] + pmn ]; -- cnt2 [ Mn [ pmn ] - pmn + N ]; } if ( pmn < pmx ) Ans += cnt [ mn_r + r ]; else Ans += cnt2 [ mx_r - r + N ]; int idx = r - ( mx_r - mn_r ); Ans += ( idx <= m && idx > max ( pmx , pmn ) ); } for ( int l = m ; l >= L ; l -- ) { int idx = l + ( Mx [ l ] - Mn [ l ]); Ans += ( idx <= R && idx >= m + 1 && Mx [ idx ] < Mx [ l ] && Mn [ idx ] > Mn [ l ] ); } } int main () { IOS ; read_int ( N ); for ( int i = 1 ; i <= N ; i ++ ) read_int ( A [ i ]); solve ( 1 , N ); printf ( \"%lld \\n \" , Ans ); return 0 ; } // input optimize inline int read_char () { constexpr int N = 1 << 20 ; static char buf [ N ]; static char * p = buf , * end = buf ; if ( p == end ) { if ( ( end = buf + fread_unlocked ( buf , 1 , N , stdin )) == buf ) return EOF ; p = buf ; } return * p ++ ; } inline int read_int ( int & x ) { static char c , neg ; while ( ( c = read_char ()) < '-' ) if ( c == EOF ) return 0 ; neg = ( c == '-' ) ? - 1 : 1 ; x = ( neg == 1 ) ? c - '0' : 0 ; while ( ( c = read_char ()) >= '0' ) x = ( x << 3 ) + ( x << 1 ) + ( c - '0' ); x *= neg ; return 1 ; }","title":"Maximum Subarray Revisited"},{"location":"courses/ada-fall-2019/hw1/good-subpermutations/#maximum-subarray-revisited","text":"","title":"Maximum Subarray Revisited"},{"location":"courses/ada-fall-2019/hw1/good-subpermutations/#problem-description","text":"Yun-Nung (Vivian) Chen's website","title":"Problem Description"},{"location":"courses/ada-fall-2019/hw1/good-subpermutations/#concept","text":"This problem is so difficult......","title":"Concept"},{"location":"courses/ada-fall-2019/hw1/good-subpermutations/#code","text":"#include <bits/stdc++.h> #define IOS {ios::sync_with_stdio(false);cin.tie(nullptr);} #pragma GCC optimize(\"Ofast\", \"no-stack-protector\", \"unroll-loops\") #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,sse4.2,popcnt,abm,mmx,avx,tune=native\") using namespace std ; using LL = long long ; inline int read_char (); inline int read_int ( int & ); const int MAXN = 5e5 + 5 , NN = 1e6 + 5 ; const int T = 40 ; int N , A [ MAXN ], Mx [ MAXN ], Mn [ MAXN ]; int cnt [ NN ], cnt2 [ NN ]; LL Ans ; void solve ( int L , int R ) { if ( L == R ) return void ( ++ Ans ); if ( R - L <= T ) { for ( int l = L ; l <= R ; l ++ ) { int mx = A [ l ], mn = A [ l ]; for ( int r = l ; r <= R ; r ++ ) { mx = max ( mx , A [ r ]); mn = min ( mn , A [ r ]); Ans += ( mx - mn == r - l ); } } return ; } // D & C int m = ( L + R ) >> 1 ; solve ( L , m ); solve ( m + 1 , R ); // preprocess Mx [ m ] = Mn [ m ] = A [ m ]; for ( int i = m - 1 ; i >= L ; i -- ) Mx [ i ] = max ( Mx [ i + 1 ], A [ i ]), Mn [ i ] = min ( Mn [ i + 1 ], A [ i ]); Mx [ m + 1 ] = Mn [ m + 1 ] = A [ m + 1 ]; cnt [ Mn [ m + 1 ] + m + 1 ] = cnt2 [ Mx [ m + 1 ] - m - 1 + N ] = 0 ; for ( int i = m + 2 ; i <= R ; i ++ ) { Mx [ i ] = max ( Mx [ i - 1 ], A [ i ]), Mn [ i ] = min ( Mn [ i - 1 ], A [ i ]); cnt [ Mn [ i ] + i ] = cnt2 [ Mx [ i ] - i + N ] = 0 ; } // cross subarray int pmx = m , pmn = m ; for ( int r = m + 1 ; r <= R ; r ++ ) { int mx_r = Mx [ r ], mn_r = Mn [ r ]; for ( ; pmx >= L && Mx [ pmx ] < mx_r ; pmx -- ) { -- cnt [ Mx [ pmx ] + pmx ]; ++ cnt2 [ Mn [ pmx ] - pmx + N ]; } for ( ; pmn >= L && Mn [ pmn ] > mn_r ; pmn -- ) { ++ cnt [ Mx [ pmn ] + pmn ]; -- cnt2 [ Mn [ pmn ] - pmn + N ]; } if ( pmn < pmx ) Ans += cnt [ mn_r + r ]; else Ans += cnt2 [ mx_r - r + N ]; int idx = r - ( mx_r - mn_r ); Ans += ( idx <= m && idx > max ( pmx , pmn ) ); } for ( int l = m ; l >= L ; l -- ) { int idx = l + ( Mx [ l ] - Mn [ l ]); Ans += ( idx <= R && idx >= m + 1 && Mx [ idx ] < Mx [ l ] && Mn [ idx ] > Mn [ l ] ); } } int main () { IOS ; read_int ( N ); for ( int i = 1 ; i <= N ; i ++ ) read_int ( A [ i ]); solve ( 1 , N ); printf ( \"%lld \\n \" , Ans ); return 0 ; } // input optimize inline int read_char () { constexpr int N = 1 << 20 ; static char buf [ N ]; static char * p = buf , * end = buf ; if ( p == end ) { if ( ( end = buf + fread_unlocked ( buf , 1 , N , stdin )) == buf ) return EOF ; p = buf ; } return * p ++ ; } inline int read_int ( int & x ) { static char c , neg ; while ( ( c = read_char ()) < '-' ) if ( c == EOF ) return 0 ; neg = ( c == '-' ) ? - 1 : 1 ; x = ( neg == 1 ) ? c - '0' : 0 ; while ( ( c = read_char ()) >= '0' ) x = ( x << 3 ) + ( x << 1 ) + ( c - '0' ); x *= neg ; return 1 ; }","title":"Code"},{"location":"courses/ada-fall-2019/hw1/maximum-subarray-revisited/","text":"Maximum Subarray Revisited \u00b6 Problem Description \u00b6 Yun-Nung (Vivian) Chen's website Concept \u00b6 Store the process of divide and conquer (just as segment tree ) In each node representing [L, R] [L, R] , store 4 things: lmx = \\max\\limits_{L \\leq r \\leq R} \\sum_{i=L}^{r} A_i = \\max\\limits_{L \\leq r \\leq R} \\sum_{i=L}^{r} A_i rmx = \\max\\limits_{L \\leq \\ell \\leq R} \\sum_{i = \\ell}^{R} A_i = \\max\\limits_{L \\leq \\ell \\leq R} \\sum_{i = \\ell}^{R} A_i ans = \\max\\limits_{L \\leq \\ell \\leq r \\leq R} \\sum_{i = \\ell}^{r} A_i = \\max\\limits_{L \\leq \\ell \\leq r \\leq R} \\sum_{i = \\ell}^{r} A_i sum = \\sum_{i=L}^{R} A_i = \\sum_{i=L}^{R} A_i The \"merge\" step is as the code. Code \u00b6 #include <bits/stdc++.h> #define IOS {ios::sync_with_stdio(false);cin.tie(nullptr);} using namespace std ; using LL = int64_t ; using ULL = uint64_t ; using LD = long double ; inline int read_char (); inline int read_int ( int & ); inline void write_int ( LL ); constexpr int MAXN = 5e5 + 5 ; struct Item { LL lmx , rmx , sum , ans ; }; int N , A [ MAXN ]; Item seg [ 4 * MAXN ]; inline int lch ( int v ) { return ( v << 1 ); } inline int rch ( int v ) { return ( v << 1 ) | 1 ; } inline void combine ( Item & v , Item & a , Item & b ) { v . sum = a . sum + b . sum ; v . lmx = max ( a . lmx , a . sum + b . lmx ); v . rmx = max ( b . rmx , b . sum + a . rmx ); v . ans = max ( a . rmx + b . lmx , max ( a . ans , b . ans )); } void build ( int v , int tl , int tr ) { if ( tl == tr ) { seg [ v ] = { A [ tl ], A [ tl ], A [ tl ], A [ tl ]}; } else { int tm = ( tl + tr ) >> 1 ; build ( lch ( v ), tl , tm ); build ( rch ( v ), tm + 1 , tr ); combine ( seg [ v ], seg [ lch ( v )], seg [ rch ( v )]); } } void pt_upd ( int v , int tl , int tr , int pos , int new_v ) { if ( tl == tr ) { seg [ v ] = { new_v , new_v , new_v , new_v }; } else { int tm = ( tl + tr ) >> 1 ; if ( pos <= tm ) pt_upd ( lch ( v ), tl , tm , pos , new_v ); else pt_upd ( rch ( v ), tm + 1 , tr , pos , new_v ); combine ( seg [ v ], seg [ lch ( v )], seg [ rch ( v )]); } } inline LL qry () { return seg [ 1 ]. ans < 0 ? 0 : seg [ 1 ]. ans ; } int main () { int Q ; read_int ( N ); read_int ( Q ); for ( int i = 1 ; i <= N ; i ++ ) read_int ( A [ i ]); build ( 1 , 1 , N ); write_int ( qry ()); while ( Q -- ) { int pos , v ; read_int ( pos ); read_int ( v ); pt_upd ( 1 , 1 , N , pos , v ); write_int ( qry ()); } return 0 ; } // input optimize inline int read_char () { constexpr int N = 1 << 20 ; static char buf [ N ]; static char * p = buf , * end = buf ; if ( p == end ) { if ( ( end = buf + fread ( buf , 1 , N , stdin )) == buf ) return EOF ; p = buf ; } return * p ++ ; } inline int read_int ( int & x ) { static char c , neg ; while ( ( c = read_char ()) < '-' ) if ( c == EOF ) return 0 ; neg = ( c == '-' ) ? - 1 : 1 ; x = ( neg == 1 ) ? c - '0' : 0 ; while ( ( c = read_char ()) >= '0' ) x = ( x << 3 ) + ( x << 1 ) + ( c - '0' ); x *= neg ; return 1 ; } // output optimize #define _pc putchar_unlocked char _buf [ 128 ]; inline void write_int ( LL x ) { if ( ! x ) { _pc ( '0' ); _pc ( '\\n' ); return ; } int t = 0 ; while ( x ) { _buf [ t ++ ] = x % 10 + '0' ; x /= 10 ; } while ( t -- ) _pc ( _buf [ t ]); _pc ( '\\n' ); } #undef _pc","title":"Maximum Subarray Revisited"},{"location":"courses/ada-fall-2019/hw1/maximum-subarray-revisited/#maximum-subarray-revisited","text":"","title":"Maximum Subarray Revisited"},{"location":"courses/ada-fall-2019/hw1/maximum-subarray-revisited/#problem-description","text":"Yun-Nung (Vivian) Chen's website","title":"Problem Description"},{"location":"courses/ada-fall-2019/hw1/maximum-subarray-revisited/#concept","text":"Store the process of divide and conquer (just as segment tree ) In each node representing [L, R] [L, R] , store 4 things: lmx = \\max\\limits_{L \\leq r \\leq R} \\sum_{i=L}^{r} A_i = \\max\\limits_{L \\leq r \\leq R} \\sum_{i=L}^{r} A_i rmx = \\max\\limits_{L \\leq \\ell \\leq R} \\sum_{i = \\ell}^{R} A_i = \\max\\limits_{L \\leq \\ell \\leq R} \\sum_{i = \\ell}^{R} A_i ans = \\max\\limits_{L \\leq \\ell \\leq r \\leq R} \\sum_{i = \\ell}^{r} A_i = \\max\\limits_{L \\leq \\ell \\leq r \\leq R} \\sum_{i = \\ell}^{r} A_i sum = \\sum_{i=L}^{R} A_i = \\sum_{i=L}^{R} A_i The \"merge\" step is as the code.","title":"Concept"},{"location":"courses/ada-fall-2019/hw1/maximum-subarray-revisited/#code","text":"#include <bits/stdc++.h> #define IOS {ios::sync_with_stdio(false);cin.tie(nullptr);} using namespace std ; using LL = int64_t ; using ULL = uint64_t ; using LD = long double ; inline int read_char (); inline int read_int ( int & ); inline void write_int ( LL ); constexpr int MAXN = 5e5 + 5 ; struct Item { LL lmx , rmx , sum , ans ; }; int N , A [ MAXN ]; Item seg [ 4 * MAXN ]; inline int lch ( int v ) { return ( v << 1 ); } inline int rch ( int v ) { return ( v << 1 ) | 1 ; } inline void combine ( Item & v , Item & a , Item & b ) { v . sum = a . sum + b . sum ; v . lmx = max ( a . lmx , a . sum + b . lmx ); v . rmx = max ( b . rmx , b . sum + a . rmx ); v . ans = max ( a . rmx + b . lmx , max ( a . ans , b . ans )); } void build ( int v , int tl , int tr ) { if ( tl == tr ) { seg [ v ] = { A [ tl ], A [ tl ], A [ tl ], A [ tl ]}; } else { int tm = ( tl + tr ) >> 1 ; build ( lch ( v ), tl , tm ); build ( rch ( v ), tm + 1 , tr ); combine ( seg [ v ], seg [ lch ( v )], seg [ rch ( v )]); } } void pt_upd ( int v , int tl , int tr , int pos , int new_v ) { if ( tl == tr ) { seg [ v ] = { new_v , new_v , new_v , new_v }; } else { int tm = ( tl + tr ) >> 1 ; if ( pos <= tm ) pt_upd ( lch ( v ), tl , tm , pos , new_v ); else pt_upd ( rch ( v ), tm + 1 , tr , pos , new_v ); combine ( seg [ v ], seg [ lch ( v )], seg [ rch ( v )]); } } inline LL qry () { return seg [ 1 ]. ans < 0 ? 0 : seg [ 1 ]. ans ; } int main () { int Q ; read_int ( N ); read_int ( Q ); for ( int i = 1 ; i <= N ; i ++ ) read_int ( A [ i ]); build ( 1 , 1 , N ); write_int ( qry ()); while ( Q -- ) { int pos , v ; read_int ( pos ); read_int ( v ); pt_upd ( 1 , 1 , N , pos , v ); write_int ( qry ()); } return 0 ; } // input optimize inline int read_char () { constexpr int N = 1 << 20 ; static char buf [ N ]; static char * p = buf , * end = buf ; if ( p == end ) { if ( ( end = buf + fread ( buf , 1 , N , stdin )) == buf ) return EOF ; p = buf ; } return * p ++ ; } inline int read_int ( int & x ) { static char c , neg ; while ( ( c = read_char ()) < '-' ) if ( c == EOF ) return 0 ; neg = ( c == '-' ) ? - 1 : 1 ; x = ( neg == 1 ) ? c - '0' : 0 ; while ( ( c = read_char ()) >= '0' ) x = ( x << 3 ) + ( x << 1 ) + ( c - '0' ); x *= neg ; return 1 ; } // output optimize #define _pc putchar_unlocked char _buf [ 128 ]; inline void write_int ( LL x ) { if ( ! x ) { _pc ( '0' ); _pc ( '\\n' ); return ; } int t = 0 ; while ( x ) { _buf [ t ++ ] = x % 10 + '0' ; x /= 10 ; } while ( t -- ) _pc ( _buf [ t ]); _pc ( '\\n' ); } #undef _pc","title":"Code"},{"location":"courses/ada-fall-2019/hw2/chunithm/","text":"Chunithm \u00b6 Problem Description \u00b6 Yun-Nung (Vivian) Chen's website Concept \u00b6 \u55ae\u8abf\u968a\u5217\u512a\u5316 Code \u00b6 #include <bits/stdc++.h> #define IOS {ios::sync_with_stdio(false);cin.tie(nullptr);} using namespace std ; using LL = long long ; using ULL = unsigned long long ; inline int read_int ( int & x ); constexpr int MAXN = 1e5 + 5 ; constexpr int MAXM = 300 + 5 ; // dp[i][j] = min(dp[i-1][k] + cost(k, j) + cost(note[i-1], note[i]), dp[i-1][k] + cost(k, note[i]) + cost(note[i-1], j)) for all 0 <= k < M int N , M , K ; int note [ MAXN ]; int _dp [ 2 ][ MAXM ]; inline int cost ( int i , int j ) { return max ( 0 , abs ( i - j ) - K ); } int main () { read_int ( N ); read_int ( M ); read_int ( K ); for ( int i = 1 ; i <= N ; i ++ ) read_int ( note [ i ]); int * dp = _dp [ 0 ], * dp2 = _dp [ 1 ]; int mn_b = 0 ; for ( int i = 2 ; i <= N ; i ++ ) { int mn_b_tmp = INT_MAX ; for ( int j = 0 ; j < M ; j ++ ) { int mn_a = min ( dp [ max ( 0 , j - K )], dp [ min ( M - 1 , j + K )]); dp2 [ j ] = min ( mn_a + cost ( note [ i - 1 ], note [ i ]), cost ( note [ i - 1 ], j ) + mn_b ); mn_b_tmp = min ( mn_b_tmp , dp2 [ j ] + cost ( j , note [ i + 1 ])); } mn_b = mn_b_tmp ; swap ( dp , dp2 ); } cout << * min_element ( dp , dp + M ) << '\\n' ; return 0 ; } // input optimize inline int read_char () { constexpr int N = 1 << 20 ; static char buf [ N ]; static char * p = buf , * end = buf ; if ( p == end ) { if ( ( end = buf + fread_unlocked ( buf , 1 , N , stdin )) == buf ) return EOF ; p = buf ; } return * p ++ ; } inline int read_int ( int & x ) { static char c , neg ; while ( ( c = read_char ()) < '-' ) if ( c == EOF ) return 0 ; neg = ( c == '-' ) ? - 1 : 1 ; x = ( neg == 1 ) ? c - '0' : 0 ; while ( ( c = read_char ()) >= '0' ) x = ( x << 3 ) + ( x << 1 ) + ( c - '0' ); x *= neg ; return 1 ; } // output optimize #define _pc putchar_unlocked char _buf [ 128 ]; inline void write_int ( LL x ) { if ( ! x ) { _pc ( '0' ); _pc ( '\\n' ); return ; } int t = 0 ; while ( x ) { _buf [ t ++ ] = x % 10 + '0' ; x /= 10 ; } while ( t -- ) _pc ( _buf [ t ]); _pc ( '\\n' ); } #undef _pc","title":"Chunithm"},{"location":"courses/ada-fall-2019/hw2/chunithm/#chunithm","text":"","title":"Chunithm"},{"location":"courses/ada-fall-2019/hw2/chunithm/#problem-description","text":"Yun-Nung (Vivian) Chen's website","title":"Problem Description"},{"location":"courses/ada-fall-2019/hw2/chunithm/#concept","text":"\u55ae\u8abf\u968a\u5217\u512a\u5316","title":"Concept"},{"location":"courses/ada-fall-2019/hw2/chunithm/#code","text":"#include <bits/stdc++.h> #define IOS {ios::sync_with_stdio(false);cin.tie(nullptr);} using namespace std ; using LL = long long ; using ULL = unsigned long long ; inline int read_int ( int & x ); constexpr int MAXN = 1e5 + 5 ; constexpr int MAXM = 300 + 5 ; // dp[i][j] = min(dp[i-1][k] + cost(k, j) + cost(note[i-1], note[i]), dp[i-1][k] + cost(k, note[i]) + cost(note[i-1], j)) for all 0 <= k < M int N , M , K ; int note [ MAXN ]; int _dp [ 2 ][ MAXM ]; inline int cost ( int i , int j ) { return max ( 0 , abs ( i - j ) - K ); } int main () { read_int ( N ); read_int ( M ); read_int ( K ); for ( int i = 1 ; i <= N ; i ++ ) read_int ( note [ i ]); int * dp = _dp [ 0 ], * dp2 = _dp [ 1 ]; int mn_b = 0 ; for ( int i = 2 ; i <= N ; i ++ ) { int mn_b_tmp = INT_MAX ; for ( int j = 0 ; j < M ; j ++ ) { int mn_a = min ( dp [ max ( 0 , j - K )], dp [ min ( M - 1 , j + K )]); dp2 [ j ] = min ( mn_a + cost ( note [ i - 1 ], note [ i ]), cost ( note [ i - 1 ], j ) + mn_b ); mn_b_tmp = min ( mn_b_tmp , dp2 [ j ] + cost ( j , note [ i + 1 ])); } mn_b = mn_b_tmp ; swap ( dp , dp2 ); } cout << * min_element ( dp , dp + M ) << '\\n' ; return 0 ; } // input optimize inline int read_char () { constexpr int N = 1 << 20 ; static char buf [ N ]; static char * p = buf , * end = buf ; if ( p == end ) { if ( ( end = buf + fread_unlocked ( buf , 1 , N , stdin )) == buf ) return EOF ; p = buf ; } return * p ++ ; } inline int read_int ( int & x ) { static char c , neg ; while ( ( c = read_char ()) < '-' ) if ( c == EOF ) return 0 ; neg = ( c == '-' ) ? - 1 : 1 ; x = ( neg == 1 ) ? c - '0' : 0 ; while ( ( c = read_char ()) >= '0' ) x = ( x << 3 ) + ( x << 1 ) + ( c - '0' ); x *= neg ; return 1 ; } // output optimize #define _pc putchar_unlocked char _buf [ 128 ]; inline void write_int ( LL x ) { if ( ! x ) { _pc ( '0' ); _pc ( '\\n' ); return ; } int t = 0 ; while ( x ) { _buf [ t ++ ] = x % 10 + '0' ; x /= 10 ; } while ( t -- ) _pc ( _buf [ t ]); _pc ( '\\n' ); } #undef _pc","title":"Code"},{"location":"courses/ada-fall-2019/hw2/line-of-battle/","text":"Line of Battle \u00b6 Problem Description \u00b6 Yun-Nung (Vivian) Chen's website Concept \u00b6 dynamic programming binary search Code \u00b6 #include <bits/stdc++.h> namespace ada { class Xoroshiro128 { public : using result_type = uint32_t ; static constexpr result_type ( min )() { return 0 ; } static constexpr result_type ( max )() { return UINT32_MAX ; } static inline result_type rotl ( const result_type x , int k ) { return ( x << k ) | ( x >> ( 32 - k )); } Xoroshiro128 () : Xoroshiro128 ( 1 , 2 , 3 , 4 ) {} Xoroshiro128 ( result_type a , result_type b , result_type c , result_type d ) : s { a , b , c , d } {} result_type operator ()() { const result_type result = rotl ( s [ 0 ] + s [ 3 ], 7 ) + s [ 0 ]; const result_type t = s [ 1 ] << 9 ; s [ 2 ] ^= s [ 0 ]; s [ 3 ] ^= s [ 1 ]; s [ 1 ] ^= s [ 2 ]; s [ 0 ] ^= s [ 3 ]; s [ 2 ] ^= t ; s [ 3 ] = rotl ( s [ 3 ], 11 ); return result ; } private : std :: array < result_type , 4 > s ; }; namespace { int c_lead , c_team ; Xoroshiro128 rng ; } // namespace int Init () { int n ; uint32_t s1 , s2 , s3 , s4 ; std :: cin >> n >> c_lead >> c_team >> s1 >> s2 >> s3 >> s4 ; rng = Xoroshiro128 ( s1 , s2 , s3 , s4 ); return n ; } int GetLeadership () { return uint64_t ( rng ()) * c_lead >> 32 ; } int GetTeamValue () { int tmp = int ( uint64_t ( rng ()) * c_team >> 32 ) + 1 ; return int ( c_team / sqrt ( tmp )); } } // namespace ada #define IOS {ios::sync_with_stdio(false);cin.tie(nullptr);} using namespace std ; using LL = int64_t ; using ULL = uint64_t ; using LD = long double ; using pii = pair < int , int > ; constexpr int MAXN = 2e6 + 5 ; constexpr int MOD = 1e9 + 7 ; int n ; int lead [ MAXN ], team [ MAXN ]; int dp [ MAXN ], dp2 [ MAXN ]; LL psum [ MAXN ]; int my_bsearch ( LL x ) { int l = 1 , r = n + 1 ; while ( l + 1 < r ) { int m = ( l + r ) >> 1 ; ( x < psum [ m ] ? r : l ) = m ; } return r ; } int main () { IOS ; n = ada :: Init (); for ( int i = 1 ; i <= n ; i ++ ) lead [ i ] = ada :: GetLeadership (); for ( int i = 1 ; i <= n ; i ++ ) team [ i ] = ada :: GetTeamValue (); for ( int i = 1 ; i <= n ; i ++ ) psum [ i ] = psum [ i - 1 ] + team [ i ]; dp2 [ n + 1 ] = 1 ; for ( int i = n ; i >= 1 ; i -- ) { int p = my_bsearch ( lead [ i ] + psum [ i ]); dp [ i ] = ( dp2 [ i + 1 ] - dp2 [ p + 1 ]); dp [ i ] += dp [ i ] < 0 ? MOD : 0 ; dp2 [ i ] = ( dp [ i ] + dp2 [ i + 1 ]); dp2 [ i ] -= dp2 [ i ] >= MOD ? MOD : 0 ; } cout << dp [ 1 ] << '\\n' ; return 0 ; }","title":"Line of Battle"},{"location":"courses/ada-fall-2019/hw2/line-of-battle/#line-of-battle","text":"","title":"Line of Battle"},{"location":"courses/ada-fall-2019/hw2/line-of-battle/#problem-description","text":"Yun-Nung (Vivian) Chen's website","title":"Problem Description"},{"location":"courses/ada-fall-2019/hw2/line-of-battle/#concept","text":"dynamic programming binary search","title":"Concept"},{"location":"courses/ada-fall-2019/hw2/line-of-battle/#code","text":"#include <bits/stdc++.h> namespace ada { class Xoroshiro128 { public : using result_type = uint32_t ; static constexpr result_type ( min )() { return 0 ; } static constexpr result_type ( max )() { return UINT32_MAX ; } static inline result_type rotl ( const result_type x , int k ) { return ( x << k ) | ( x >> ( 32 - k )); } Xoroshiro128 () : Xoroshiro128 ( 1 , 2 , 3 , 4 ) {} Xoroshiro128 ( result_type a , result_type b , result_type c , result_type d ) : s { a , b , c , d } {} result_type operator ()() { const result_type result = rotl ( s [ 0 ] + s [ 3 ], 7 ) + s [ 0 ]; const result_type t = s [ 1 ] << 9 ; s [ 2 ] ^= s [ 0 ]; s [ 3 ] ^= s [ 1 ]; s [ 1 ] ^= s [ 2 ]; s [ 0 ] ^= s [ 3 ]; s [ 2 ] ^= t ; s [ 3 ] = rotl ( s [ 3 ], 11 ); return result ; } private : std :: array < result_type , 4 > s ; }; namespace { int c_lead , c_team ; Xoroshiro128 rng ; } // namespace int Init () { int n ; uint32_t s1 , s2 , s3 , s4 ; std :: cin >> n >> c_lead >> c_team >> s1 >> s2 >> s3 >> s4 ; rng = Xoroshiro128 ( s1 , s2 , s3 , s4 ); return n ; } int GetLeadership () { return uint64_t ( rng ()) * c_lead >> 32 ; } int GetTeamValue () { int tmp = int ( uint64_t ( rng ()) * c_team >> 32 ) + 1 ; return int ( c_team / sqrt ( tmp )); } } // namespace ada #define IOS {ios::sync_with_stdio(false);cin.tie(nullptr);} using namespace std ; using LL = int64_t ; using ULL = uint64_t ; using LD = long double ; using pii = pair < int , int > ; constexpr int MAXN = 2e6 + 5 ; constexpr int MOD = 1e9 + 7 ; int n ; int lead [ MAXN ], team [ MAXN ]; int dp [ MAXN ], dp2 [ MAXN ]; LL psum [ MAXN ]; int my_bsearch ( LL x ) { int l = 1 , r = n + 1 ; while ( l + 1 < r ) { int m = ( l + r ) >> 1 ; ( x < psum [ m ] ? r : l ) = m ; } return r ; } int main () { IOS ; n = ada :: Init (); for ( int i = 1 ; i <= n ; i ++ ) lead [ i ] = ada :: GetLeadership (); for ( int i = 1 ; i <= n ; i ++ ) team [ i ] = ada :: GetTeamValue (); for ( int i = 1 ; i <= n ; i ++ ) psum [ i ] = psum [ i - 1 ] + team [ i ]; dp2 [ n + 1 ] = 1 ; for ( int i = n ; i >= 1 ; i -- ) { int p = my_bsearch ( lead [ i ] + psum [ i ]); dp [ i ] = ( dp2 [ i + 1 ] - dp2 [ p + 1 ]); dp [ i ] += dp [ i ] < 0 ? MOD : 0 ; dp2 [ i ] = ( dp [ i ] + dp2 [ i + 1 ]); dp2 [ i ] -= dp2 [ i ] >= MOD ? MOD : 0 ; } cout << dp [ 1 ] << '\\n' ; return 0 ; }","title":"Code"},{"location":"courses/ada-fall-2019/hw2/pokemon-go/","text":"Pokemon GO \u00b6 Problem Description \u00b6 Yun-Nung (Vivian) Chen's website Concept \u00b6 Knapsack Problem Code \u00b6 #include <bits/stdc++.h> #define IOS {ios::sync_with_stdio(false);cin.tie(nullptr);} #pragma GCC optimize(\"Ofast\", \"no-stack-protector\", \"unroll-loops\") #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,sse4.2,popcnt,abm,mmx,avx,tune=native\") using namespace std ; using LL = int64_t ; using ULL = uint64_t ; using LD = long double ; using pii = pair < int , int > ; constexpr int MAXB = 100 ; constexpr int MAXN = 105 ; constexpr int MAXK = 105 ; int dp [ MAXK ][ MAXB * MAXN ]; int A [ MAXN ], B [ MAXN ]; int N , K ; int main () { IOS ; cin >> N >> K ; for ( int i = 1 ; i <= N ; i ++ ) cin >> A [ i ] >> B [ i ]; vector < int > arr ; for ( int i = 1 ; i <= N ; i ++ ) { int mx = - 1 , mx_idx ; for ( int j = 0 ; j <= arr . size (); j ++ ) { int bsum = 0 ; for ( int k = 0 ; k < j ; k ++ ) bsum += B [ arr [ k ]]; int asum = 0 ; for ( int k = j ; k < arr . size (); k ++ ) asum += A [ arr [ k ]]; int val = asum * B [ i ] + bsum * A [ i ]; if ( val > mx ) { mx = val ; mx_idx = j ; } } if ( mx_idx == arr . size () ) arr . push_back ( i ); else arr . insert ( arr . begin () + mx_idx , i ); } memset ( dp , - 1 , sizeof ( dp )); dp [ 0 ][ 0 ] = 0 ; for ( int i : arr ) for ( int k = K - 1 ; k >= 0 ; k -- ) for ( int xp = 10000 - B [ i ]; xp >= 0 ; xp -- ) if ( dp [ k ][ xp ] != - 1 ) dp [ k + 1 ][ xp + B [ i ]] = max ( dp [ k + 1 ][ xp + B [ i ]], dp [ k ][ xp ] + A [ i ] * xp ); cout << * max_element ( dp [ K ], dp [ K ] + 10001 ) << '\\n' ; return 0 ; } // input optimize inline int read_char () { constexpr int N = 1 << 20 ; static char buf [ N ]; static char * p = buf , * end = buf ; if ( p == end ) { if ( ( end = buf + fread_unlocked ( buf , 1 , N , stdin )) == buf ) return EOF ; p = buf ; } return * p ++ ; } inline int read_int ( int & x ) { static char c , neg ; while ( ( c = read_char ()) < '-' ) if ( c == EOF ) return 0 ; neg = ( c == '-' ) ? - 1 : 1 ; x = ( neg == 1 ) ? c - '0' : 0 ; while ( ( c = read_char ()) >= '0' ) x = ( x << 3 ) + ( x << 1 ) + ( c - '0' ); x *= neg ; return 1 ; } // output optimize #define _pc putchar_unlocked char _buf [ 128 ]; inline void write_int ( LL x ) { if ( ! x ) { _pc ( '0' ); _pc ( '\\n' ); return ; } int t = 0 ; while ( x ) { _buf [ t ++ ] = x % 10 + '0' ; x /= 10 ; } while ( t -- ) _pc ( _buf [ t ]); _pc ( '\\n' ); } #undef _pc","title":"Pokemon GO"},{"location":"courses/ada-fall-2019/hw2/pokemon-go/#pokemon-go","text":"","title":"Pokemon GO"},{"location":"courses/ada-fall-2019/hw2/pokemon-go/#problem-description","text":"Yun-Nung (Vivian) Chen's website","title":"Problem Description"},{"location":"courses/ada-fall-2019/hw2/pokemon-go/#concept","text":"Knapsack Problem","title":"Concept"},{"location":"courses/ada-fall-2019/hw2/pokemon-go/#code","text":"#include <bits/stdc++.h> #define IOS {ios::sync_with_stdio(false);cin.tie(nullptr);} #pragma GCC optimize(\"Ofast\", \"no-stack-protector\", \"unroll-loops\") #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,sse4.2,popcnt,abm,mmx,avx,tune=native\") using namespace std ; using LL = int64_t ; using ULL = uint64_t ; using LD = long double ; using pii = pair < int , int > ; constexpr int MAXB = 100 ; constexpr int MAXN = 105 ; constexpr int MAXK = 105 ; int dp [ MAXK ][ MAXB * MAXN ]; int A [ MAXN ], B [ MAXN ]; int N , K ; int main () { IOS ; cin >> N >> K ; for ( int i = 1 ; i <= N ; i ++ ) cin >> A [ i ] >> B [ i ]; vector < int > arr ; for ( int i = 1 ; i <= N ; i ++ ) { int mx = - 1 , mx_idx ; for ( int j = 0 ; j <= arr . size (); j ++ ) { int bsum = 0 ; for ( int k = 0 ; k < j ; k ++ ) bsum += B [ arr [ k ]]; int asum = 0 ; for ( int k = j ; k < arr . size (); k ++ ) asum += A [ arr [ k ]]; int val = asum * B [ i ] + bsum * A [ i ]; if ( val > mx ) { mx = val ; mx_idx = j ; } } if ( mx_idx == arr . size () ) arr . push_back ( i ); else arr . insert ( arr . begin () + mx_idx , i ); } memset ( dp , - 1 , sizeof ( dp )); dp [ 0 ][ 0 ] = 0 ; for ( int i : arr ) for ( int k = K - 1 ; k >= 0 ; k -- ) for ( int xp = 10000 - B [ i ]; xp >= 0 ; xp -- ) if ( dp [ k ][ xp ] != - 1 ) dp [ k + 1 ][ xp + B [ i ]] = max ( dp [ k + 1 ][ xp + B [ i ]], dp [ k ][ xp ] + A [ i ] * xp ); cout << * max_element ( dp [ K ], dp [ K ] + 10001 ) << '\\n' ; return 0 ; } // input optimize inline int read_char () { constexpr int N = 1 << 20 ; static char buf [ N ]; static char * p = buf , * end = buf ; if ( p == end ) { if ( ( end = buf + fread_unlocked ( buf , 1 , N , stdin )) == buf ) return EOF ; p = buf ; } return * p ++ ; } inline int read_int ( int & x ) { static char c , neg ; while ( ( c = read_char ()) < '-' ) if ( c == EOF ) return 0 ; neg = ( c == '-' ) ? - 1 : 1 ; x = ( neg == 1 ) ? c - '0' : 0 ; while ( ( c = read_char ()) >= '0' ) x = ( x << 3 ) + ( x << 1 ) + ( c - '0' ); x *= neg ; return 1 ; } // output optimize #define _pc putchar_unlocked char _buf [ 128 ]; inline void write_int ( LL x ) { if ( ! x ) { _pc ( '0' ); _pc ( '\\n' ); return ; } int t = 0 ; while ( x ) { _buf [ t ++ ] = x % 10 + '0' ; x /= 10 ; } while ( t -- ) _pc ( _buf [ t ]); _pc ( '\\n' ); } #undef _pc","title":"Code"},{"location":"courses/ada-fall-2019/hw2/weigh-anchor/","text":"Weigh Anchor \u00b6 Problem Description \u00b6 Yun-Nung (Vivian) Chen's website Concept \u00b6 Greedy Code \u00b6 #include <bits/stdc++.h> #define IOS {ios::sync_with_stdio(false);cin.tie(nullptr);} using namespace std ; using LL = long long ; int read_int ( int & ); int main () { int N ; int s1 , s2 , s3 , s12 , s13 , s23 , s123 ; int c1 = 0 , c2 = 0 , c3 = 0 , c12 = 0 , c23 = 0 , c13 = 0 , c123 = 0 ; read_int ( N ); read_int ( s1 ); read_int ( s2 ); read_int ( s3 ); if ( s1 > s2 ) swap ( s1 , s2 ); if ( s2 > s3 ) swap ( s2 , s3 ); if ( s1 > s2 ) swap ( s1 , s2 ); s123 = s1 + s2 + s3 ; s12 = s1 + s2 , s13 = s1 + s3 , s23 = s2 + s3 ; int ans = 0 ; if ( s12 > s3 ) { bool fail = false ; for ( int i = 1 ; i <= N ; i ++ ) { int a ; read_int ( a ); if ( a <= s1 ) ++ c1 ; else if ( a <= s2 ) ++ c2 ; else if ( a <= s3 ) ++ c3 ; else if ( a <= s12 ) ++ c12 ; else if ( a <= s13 ) ++ c13 ; else if ( a <= s23 ) ++ c23 ; else if ( a <= s123 ) ++ c123 ; else fail = true ; } if ( fail ) { cout << \"-1 \\n \" ; return 0 ; } ans = c123 ; while ( c23 > 0 || c13 > 0 || c12 > 0 || c3 > 0 || c2 > 0 || c1 > 0 ) { if ( c23 > 0 ) { -- c23 ; if ( c1 > 0 ) -- c1 ; } else if ( c13 > 0 ) { -- c13 ; if ( c2 > 0 ) -- c2 ; else if ( c1 > 0 ) -- c1 ; } else if ( c12 > 0 ) { -- c12 ; if ( c3 > 0 ) -- c3 ; else if ( c2 > 0 ) -- c2 ; else if ( c1 > 0 ) -- c1 ; } else if ( c3 > 0 ) { -- c3 ; if ( c2 > 0 ) { -- c2 ; if ( c1 > 0 ) -- c1 ; } else if ( c1 > 0 ) { c1 -= 2 ; } else if ( c3 > 0 ) -- c3 ; // s12!! } else if ( c2 > 0 ) { -- c2 ; // s2 if ( c2 > 0 ) -- c2 ; // s3 else if ( c1 > 0 ) -- c1 ; // s3 if ( c1 > 0 ) -- c1 ; // s1 } else if ( c1 > 0 ) { c1 -= 3 ; } ++ ans ; } } else { bool fail = false ; for ( int i = 1 ; i <= N ; i ++ ) { int a ; read_int ( a ); if ( a <= s1 ) ++ c1 ; else if ( a <= s2 ) ++ c2 ; else if ( a <= s12 ) ++ c12 ; else if ( a <= s3 ) ++ c3 ; else if ( a <= s13 ) ++ c13 ; else if ( a <= s23 ) ++ c23 ; else if ( a <= s123 ) ++ c123 ; else fail = true ; } if ( fail ) { cout << \"-1 \\n \" ; return 0 ; } ans = c123 ; while ( c23 > 0 || c13 > 0 || c12 > 0 || c3 > 0 || c2 > 0 || c1 > 0 ) { if ( c23 > 0 ) { -- c23 ; if ( c1 > 0 ) -- c1 ; } else if ( c13 > 0 ) { -- c13 ; if ( c2 > 0 ) -- c2 ; // s2 else if ( c1 > 0 ) -- c1 ; // s2 } else if ( c3 > 0 ) { -- c3 ; if ( c2 > 0 ) { -- c2 ; // s2 if ( c1 > 0 ) -- c1 ; // s1 } else if ( c1 > 0 ) { c1 -= 2 ; // s1 , s2 } else if ( c12 > 0 ) -- c12 ; } else if ( c12 > 0 ) { -- c12 ; // s3 if ( c2 > 0 ) { -- c2 ; // s2 if ( c1 > 0 ) -- c1 ; } else if ( c1 > 0 ) { c1 -= 2 ; } else if ( c12 > 0 ) -- c12 ; } else if ( c2 > 0 ) { -- c2 ; // s2 if ( c2 > 0 ) -- c2 ; // s3 else if ( c1 > 0 ) -- c1 ; // s3 if ( c1 > 0 ) -- c1 ; // s1 } else if ( c1 > 0 ) { c1 -= 3 ; } ++ ans ; } } cout << ans << '\\n' ; return 0 ; } // input optimize inline int read_char () { constexpr int N = 1 << 20 ; static char buf [ N ]; static char * p = buf , * end = buf ; if ( p == end ) { if ( ( end = buf + fread_unlocked ( buf , 1 , N , stdin )) == buf ) return EOF ; p = buf ; } return * p ++ ; } inline int read_int ( int & x ) { static char c , neg ; while ( ( c = read_char ()) < '-' ) if ( c == EOF ) return 0 ; neg = ( c == '-' ) ? - 1 : 1 ; x = ( neg == 1 ) ? c - '0' : 0 ; while ( ( c = read_char ()) >= '0' ) x = ( x << 3 ) + ( x << 1 ) + ( c - '0' ); x *= neg ; return 1 ; } // output optimize #define _pc putchar_unlocked char _buf [ 128 ]; inline void write_int ( LL x ) { if ( ! x ) { _pc ( '0' ); _pc ( '\\n' ); return ; } int t = 0 ; while ( x ) { _buf [ t ++ ] = x % 10 + '0' ; x /= 10 ; } while ( t -- ) _pc ( _buf [ t ]); _pc ( '\\n' ); } #undef _pc","title":"Weigh Anchor"},{"location":"courses/ada-fall-2019/hw2/weigh-anchor/#weigh-anchor","text":"","title":"Weigh Anchor"},{"location":"courses/ada-fall-2019/hw2/weigh-anchor/#problem-description","text":"Yun-Nung (Vivian) Chen's website","title":"Problem Description"},{"location":"courses/ada-fall-2019/hw2/weigh-anchor/#concept","text":"Greedy","title":"Concept"},{"location":"courses/ada-fall-2019/hw2/weigh-anchor/#code","text":"#include <bits/stdc++.h> #define IOS {ios::sync_with_stdio(false);cin.tie(nullptr);} using namespace std ; using LL = long long ; int read_int ( int & ); int main () { int N ; int s1 , s2 , s3 , s12 , s13 , s23 , s123 ; int c1 = 0 , c2 = 0 , c3 = 0 , c12 = 0 , c23 = 0 , c13 = 0 , c123 = 0 ; read_int ( N ); read_int ( s1 ); read_int ( s2 ); read_int ( s3 ); if ( s1 > s2 ) swap ( s1 , s2 ); if ( s2 > s3 ) swap ( s2 , s3 ); if ( s1 > s2 ) swap ( s1 , s2 ); s123 = s1 + s2 + s3 ; s12 = s1 + s2 , s13 = s1 + s3 , s23 = s2 + s3 ; int ans = 0 ; if ( s12 > s3 ) { bool fail = false ; for ( int i = 1 ; i <= N ; i ++ ) { int a ; read_int ( a ); if ( a <= s1 ) ++ c1 ; else if ( a <= s2 ) ++ c2 ; else if ( a <= s3 ) ++ c3 ; else if ( a <= s12 ) ++ c12 ; else if ( a <= s13 ) ++ c13 ; else if ( a <= s23 ) ++ c23 ; else if ( a <= s123 ) ++ c123 ; else fail = true ; } if ( fail ) { cout << \"-1 \\n \" ; return 0 ; } ans = c123 ; while ( c23 > 0 || c13 > 0 || c12 > 0 || c3 > 0 || c2 > 0 || c1 > 0 ) { if ( c23 > 0 ) { -- c23 ; if ( c1 > 0 ) -- c1 ; } else if ( c13 > 0 ) { -- c13 ; if ( c2 > 0 ) -- c2 ; else if ( c1 > 0 ) -- c1 ; } else if ( c12 > 0 ) { -- c12 ; if ( c3 > 0 ) -- c3 ; else if ( c2 > 0 ) -- c2 ; else if ( c1 > 0 ) -- c1 ; } else if ( c3 > 0 ) { -- c3 ; if ( c2 > 0 ) { -- c2 ; if ( c1 > 0 ) -- c1 ; } else if ( c1 > 0 ) { c1 -= 2 ; } else if ( c3 > 0 ) -- c3 ; // s12!! } else if ( c2 > 0 ) { -- c2 ; // s2 if ( c2 > 0 ) -- c2 ; // s3 else if ( c1 > 0 ) -- c1 ; // s3 if ( c1 > 0 ) -- c1 ; // s1 } else if ( c1 > 0 ) { c1 -= 3 ; } ++ ans ; } } else { bool fail = false ; for ( int i = 1 ; i <= N ; i ++ ) { int a ; read_int ( a ); if ( a <= s1 ) ++ c1 ; else if ( a <= s2 ) ++ c2 ; else if ( a <= s12 ) ++ c12 ; else if ( a <= s3 ) ++ c3 ; else if ( a <= s13 ) ++ c13 ; else if ( a <= s23 ) ++ c23 ; else if ( a <= s123 ) ++ c123 ; else fail = true ; } if ( fail ) { cout << \"-1 \\n \" ; return 0 ; } ans = c123 ; while ( c23 > 0 || c13 > 0 || c12 > 0 || c3 > 0 || c2 > 0 || c1 > 0 ) { if ( c23 > 0 ) { -- c23 ; if ( c1 > 0 ) -- c1 ; } else if ( c13 > 0 ) { -- c13 ; if ( c2 > 0 ) -- c2 ; // s2 else if ( c1 > 0 ) -- c1 ; // s2 } else if ( c3 > 0 ) { -- c3 ; if ( c2 > 0 ) { -- c2 ; // s2 if ( c1 > 0 ) -- c1 ; // s1 } else if ( c1 > 0 ) { c1 -= 2 ; // s1 , s2 } else if ( c12 > 0 ) -- c12 ; } else if ( c12 > 0 ) { -- c12 ; // s3 if ( c2 > 0 ) { -- c2 ; // s2 if ( c1 > 0 ) -- c1 ; } else if ( c1 > 0 ) { c1 -= 2 ; } else if ( c12 > 0 ) -- c12 ; } else if ( c2 > 0 ) { -- c2 ; // s2 if ( c2 > 0 ) -- c2 ; // s3 else if ( c1 > 0 ) -- c1 ; // s3 if ( c1 > 0 ) -- c1 ; // s1 } else if ( c1 > 0 ) { c1 -= 3 ; } ++ ans ; } } cout << ans << '\\n' ; return 0 ; } // input optimize inline int read_char () { constexpr int N = 1 << 20 ; static char buf [ N ]; static char * p = buf , * end = buf ; if ( p == end ) { if ( ( end = buf + fread_unlocked ( buf , 1 , N , stdin )) == buf ) return EOF ; p = buf ; } return * p ++ ; } inline int read_int ( int & x ) { static char c , neg ; while ( ( c = read_char ()) < '-' ) if ( c == EOF ) return 0 ; neg = ( c == '-' ) ? - 1 : 1 ; x = ( neg == 1 ) ? c - '0' : 0 ; while ( ( c = read_char ()) >= '0' ) x = ( x << 3 ) + ( x << 1 ) + ( c - '0' ); x *= neg ; return 1 ; } // output optimize #define _pc putchar_unlocked char _buf [ 128 ]; inline void write_int ( LL x ) { if ( ! x ) { _pc ( '0' ); _pc ( '\\n' ); return ; } int t = 0 ; while ( x ) { _buf [ t ++ ] = x % 10 + '0' ; x /= 10 ; } while ( t -- ) _pc ( _buf [ t ]); _pc ( '\\n' ); } #undef _pc","title":"Code"},{"location":"courses/ada-fall-2019/hw3/idol-master/","text":"Idol Master! \u00b6 Problem Description \u00b6 Yun-Nung (Vivian) Chen's website Concept \u00b6 path compression copy-on-write to avoid resetting counting array to 0 Code \u00b6 #include <bits/stdc++.h> #define IOS {ios::sync_with_stdio(false);cin.tie(nullptr);} #pragma GCC optimize(\"Ofast\", \"no-stack-protector\", \"unroll-loops\") #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,sse4.2,popcnt,abm,mmx,avx,tune=native\") using namespace std ; using LL = int64_t ; using ULL = uint64_t ; using LD = long double ; using pii = pair < int , int > ; constexpr int MAXN = ( 1 << 18 ) + 5 ; inline int read_int ( int & x ); inline void write_int ( LL x ); int N ; int G [ MAXN ], ref_cnt [ MAXN ], cnt [ MAXN ], label [ MAXN ], len [ MAXN ]; bool done [ MAXN ]; void dfs ( int o ) { int v = G [ o ], d = 1 ; while ( v && ref_cnt [ v ] == 1 ) v = G [ v ], ++ d ; G [ o ] = v ; len [ o ] = d ; done [ o ] = true ; if ( v && ! done [ v ] ) dfs ( v ); } void compress () { for ( int i = 1 ; i <= N ; i ++ ) if ( ref_cnt [ i ] == 0 ) dfs ( i ); } int main () { read_int ( N ); for ( int i = 1 ; i <= N ; i ++ ) { read_int ( G [ i ]); ref_cnt [ G [ i ]] ++ ; } compress (); int Q ; read_int ( Q ); for ( int q = 1 ; q <= Q ; q ++ ) { int ans = 0 ; int nx ; read_int ( nx ); for ( int _ = 0 ; _ < nx ; ++ _ ) { int x ; read_int ( x ); while ( cnt [ x ] == 0 ) { ans += len [ x ]; x = G [ x ]; if ( ! x ) break ; if ( label [ x ] != q ) { label [ x ] = q ; cnt [ x ] = ref_cnt [ x ]; } cnt [ x ] -- ; } } write_int ( ans ); } return 0 ; } // input optimize inline int read_char () { constexpr int N = 1 << 20 ; static char buf [ N ]; static char * p = buf , * end = buf ; if ( p == end ) { if ( ( end = buf + fread_unlocked ( buf , 1 , N , stdin )) == buf ) return EOF ; p = buf ; } return * p ++ ; } inline int read_int ( int & x ) { static char c , neg ; while ( ( c = read_char ()) < '-' ) if ( c == EOF ) return 0 ; neg = ( c == '-' ) ? - 1 : 1 ; x = ( neg == 1 ) ? c - '0' : 0 ; while ( ( c = read_char ()) >= '0' ) x = ( x << 3 ) + ( x << 1 ) + ( c - '0' ); x *= neg ; return 1 ; } // output optimize #define _pc putchar_unlocked char _buf [ 128 ]; inline void write_int ( LL x ) { if ( ! x ) { _pc ( '0' ); _pc ( '\\n' ); return ; } int t = 0 ; while ( x ) { _buf [ t ++ ] = x % 10 + '0' ; x /= 10 ; } while ( t -- ) _pc ( _buf [ t ]); _pc ( '\\n' ); } #undef _pc","title":"Idol Master!"},{"location":"courses/ada-fall-2019/hw3/idol-master/#idol-master","text":"","title":"Idol Master!"},{"location":"courses/ada-fall-2019/hw3/idol-master/#problem-description","text":"Yun-Nung (Vivian) Chen's website","title":"Problem Description"},{"location":"courses/ada-fall-2019/hw3/idol-master/#concept","text":"path compression copy-on-write to avoid resetting counting array to 0","title":"Concept"},{"location":"courses/ada-fall-2019/hw3/idol-master/#code","text":"#include <bits/stdc++.h> #define IOS {ios::sync_with_stdio(false);cin.tie(nullptr);} #pragma GCC optimize(\"Ofast\", \"no-stack-protector\", \"unroll-loops\") #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,sse4.2,popcnt,abm,mmx,avx,tune=native\") using namespace std ; using LL = int64_t ; using ULL = uint64_t ; using LD = long double ; using pii = pair < int , int > ; constexpr int MAXN = ( 1 << 18 ) + 5 ; inline int read_int ( int & x ); inline void write_int ( LL x ); int N ; int G [ MAXN ], ref_cnt [ MAXN ], cnt [ MAXN ], label [ MAXN ], len [ MAXN ]; bool done [ MAXN ]; void dfs ( int o ) { int v = G [ o ], d = 1 ; while ( v && ref_cnt [ v ] == 1 ) v = G [ v ], ++ d ; G [ o ] = v ; len [ o ] = d ; done [ o ] = true ; if ( v && ! done [ v ] ) dfs ( v ); } void compress () { for ( int i = 1 ; i <= N ; i ++ ) if ( ref_cnt [ i ] == 0 ) dfs ( i ); } int main () { read_int ( N ); for ( int i = 1 ; i <= N ; i ++ ) { read_int ( G [ i ]); ref_cnt [ G [ i ]] ++ ; } compress (); int Q ; read_int ( Q ); for ( int q = 1 ; q <= Q ; q ++ ) { int ans = 0 ; int nx ; read_int ( nx ); for ( int _ = 0 ; _ < nx ; ++ _ ) { int x ; read_int ( x ); while ( cnt [ x ] == 0 ) { ans += len [ x ]; x = G [ x ]; if ( ! x ) break ; if ( label [ x ] != q ) { label [ x ] = q ; cnt [ x ] = ref_cnt [ x ]; } cnt [ x ] -- ; } } write_int ( ans ); } return 0 ; } // input optimize inline int read_char () { constexpr int N = 1 << 20 ; static char buf [ N ]; static char * p = buf , * end = buf ; if ( p == end ) { if ( ( end = buf + fread_unlocked ( buf , 1 , N , stdin )) == buf ) return EOF ; p = buf ; } return * p ++ ; } inline int read_int ( int & x ) { static char c , neg ; while ( ( c = read_char ()) < '-' ) if ( c == EOF ) return 0 ; neg = ( c == '-' ) ? - 1 : 1 ; x = ( neg == 1 ) ? c - '0' : 0 ; while ( ( c = read_char ()) >= '0' ) x = ( x << 3 ) + ( x << 1 ) + ( c - '0' ); x *= neg ; return 1 ; } // output optimize #define _pc putchar_unlocked char _buf [ 128 ]; inline void write_int ( LL x ) { if ( ! x ) { _pc ( '0' ); _pc ( '\\n' ); return ; } int t = 0 ; while ( x ) { _buf [ t ++ ] = x % 10 + '0' ; x /= 10 ; } while ( t -- ) _pc ( _buf [ t ]); _pc ( '\\n' ); } #undef _pc","title":"Code"},{"location":"courses/ada-fall-2019/hw3/magic-song/","text":"Magic Song \u00b6 Problem Description \u00b6 Yun-Nung (Vivian) Chen's website Concept \u00b6 methods to convert the input to a graph: hash table ( __gnu_pbds::gp_hash_table ) \u96e2\u6563\u5316 + std::lower_bound longest path on DAG dynamic programming Code \u00b6 #include <bits/stdc++.h> #include <bits/extc++.h> #define IOS {ios::sync_with_stdio(false);cin.tie(nullptr);} #define unordered_map __gnu_pbds::gp_hash_table #pragma GCC optimize(\"Ofast\", \"no-stack-protector\", \"unroll-loops\") #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,sse4.2,popcnt,abm,mmx,avx,tune=native\") using namespace std ; using LL = int64_t ; using ULL = uint64_t ; using LD = long double ; using pii = pair < int , int > ; inline int read_int ( int & x ); constexpr int MAXN = 1e5 + 5 , MAXM = 5e5 + 5 ; constexpr int MAXV = 1e6 + 2e5 + 100 ; constexpr LL INF = ( 1LL << 61 ) + 1 ; int N , M ; int A [ MAXN ]; vector < int > V [ MAXN ]; vector < pii > G [ MAXV ]; void add_edge ( int from , int to , int w ) { G [ from ]. push_back ( { to , w } ); } int nd = 0 ; unordered_map < ULL , int > mp ; ULL get_hash ( int a , int b ) { return (( ULL ) a << 31 ) | b ; } int add_node ( int s , int t ) { auto res = mp . insert ( make_pair ( get_hash ( s , t ), nd ) ); if ( res . second ) { ++ nd ; V [ s ]. push_back ( t ); } return res . first -> second ; } int get_node ( int s , int t ) { return mp [ get_hash ( s , t ) ]; } LL dist [ MAXV ]; bool vis [ MAXV ], done [ MAXV ]; LL dfs ( int v ) { vis [ v ] = true ; for ( pii p : G [ v ] ) { if ( ! vis [ p . first ] ) dfs ( p . first ); else if ( ! done [ p . first ] ) return ( dist [ v ] = INF ); dist [ v ] = max ( dist [ v ], dist [ p . first ] + p . second ); if ( dist [ v ] >= INF ) return INF ; } done [ v ] = true ; return dist [ v ]; } int main () { IOS ; int T ; read_int ( T ); while ( T -- ) { read_int ( N ); read_int ( M ); for ( int i = 1 ; i <= N ; i ++ ) { read_int ( A [ i ]); add_node ( i , A [ i ]); } for ( int i = 0 ; i < M ; i ++ ) { int s1 , t1 , s2 , t2 ; read_int ( s1 ); read_int ( t1 ); read_int ( s2 ); read_int ( t2 ); int from = add_node ( s1 , t1 ); int to = add_node ( s2 , t2 ); add_edge ( from , to , 1 ); } int S = nd ; for ( int i = 1 ; i <= N ; i ++ ) { sort ( V [ i ]. begin (), V [ i ]. end ()); int prev_id = S , prev_pos = 0 ; for ( int j = 0 ; j < V [ i ]. size (); j ++ ) { int now_id = get_node ( i , V [ i ][ j ]), now_pos = V [ i ][ j ]; add_edge ( prev_id , now_id , now_pos - prev_pos ); prev_id = now_id , prev_pos = now_pos ; } V [ i ]. clear (); } LL ans = dfs ( S ); if ( ans >= INF ) cout << \"LoveLive! \\n \" ; else cout << ans << '\\n' ; memset ( vis , 0 , sizeof ( vis )); memset ( done , 0 , sizeof ( done )); memset ( dist , 0 , sizeof ( dist )); for ( int i = 0 ; i <= nd ; i ++ ) G [ i ]. clear (); mp . clear (); nd = 0 ; } return EXIT_SUCCESS ; } // input optimize inline int read_char () { constexpr int N = 1 << 20 ; static char buf [ N ]; static char * p = buf , * end = buf ; if ( p == end ) { if ( ( end = buf + fread_unlocked ( buf , 1 , N , stdin )) == buf ) return EOF ; p = buf ; } return * p ++ ; } inline int read_int ( int & x ) { static char c , neg ; while ( ( c = read_char ()) < '-' ) if ( c == EOF ) return 0 ; neg = ( c == '-' ) ? - 1 : 1 ; x = ( neg == 1 ) ? c - '0' : 0 ; while ( ( c = read_char ()) >= '0' ) x = ( x << 3 ) + ( x << 1 ) + ( c - '0' ); x *= neg ; return 1 ; } // output optimize #define _pc putchar_unlocked char _buf [ 128 ]; inline void write_int ( LL x ) { if ( ! x ) { _pc ( '0' ); _pc ( '\\n' ); return ; } int t = 0 ; while ( x ) { _buf [ t ++ ] = x % 10 + '0' ; x /= 10 ; } while ( t -- ) _pc ( _buf [ t ]); _pc ( '\\n' ); } #undef _pc","title":"Magic Song"},{"location":"courses/ada-fall-2019/hw3/magic-song/#magic-song","text":"","title":"Magic Song"},{"location":"courses/ada-fall-2019/hw3/magic-song/#problem-description","text":"Yun-Nung (Vivian) Chen's website","title":"Problem Description"},{"location":"courses/ada-fall-2019/hw3/magic-song/#concept","text":"methods to convert the input to a graph: hash table ( __gnu_pbds::gp_hash_table ) \u96e2\u6563\u5316 + std::lower_bound longest path on DAG dynamic programming","title":"Concept"},{"location":"courses/ada-fall-2019/hw3/magic-song/#code","text":"#include <bits/stdc++.h> #include <bits/extc++.h> #define IOS {ios::sync_with_stdio(false);cin.tie(nullptr);} #define unordered_map __gnu_pbds::gp_hash_table #pragma GCC optimize(\"Ofast\", \"no-stack-protector\", \"unroll-loops\") #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,sse4.2,popcnt,abm,mmx,avx,tune=native\") using namespace std ; using LL = int64_t ; using ULL = uint64_t ; using LD = long double ; using pii = pair < int , int > ; inline int read_int ( int & x ); constexpr int MAXN = 1e5 + 5 , MAXM = 5e5 + 5 ; constexpr int MAXV = 1e6 + 2e5 + 100 ; constexpr LL INF = ( 1LL << 61 ) + 1 ; int N , M ; int A [ MAXN ]; vector < int > V [ MAXN ]; vector < pii > G [ MAXV ]; void add_edge ( int from , int to , int w ) { G [ from ]. push_back ( { to , w } ); } int nd = 0 ; unordered_map < ULL , int > mp ; ULL get_hash ( int a , int b ) { return (( ULL ) a << 31 ) | b ; } int add_node ( int s , int t ) { auto res = mp . insert ( make_pair ( get_hash ( s , t ), nd ) ); if ( res . second ) { ++ nd ; V [ s ]. push_back ( t ); } return res . first -> second ; } int get_node ( int s , int t ) { return mp [ get_hash ( s , t ) ]; } LL dist [ MAXV ]; bool vis [ MAXV ], done [ MAXV ]; LL dfs ( int v ) { vis [ v ] = true ; for ( pii p : G [ v ] ) { if ( ! vis [ p . first ] ) dfs ( p . first ); else if ( ! done [ p . first ] ) return ( dist [ v ] = INF ); dist [ v ] = max ( dist [ v ], dist [ p . first ] + p . second ); if ( dist [ v ] >= INF ) return INF ; } done [ v ] = true ; return dist [ v ]; } int main () { IOS ; int T ; read_int ( T ); while ( T -- ) { read_int ( N ); read_int ( M ); for ( int i = 1 ; i <= N ; i ++ ) { read_int ( A [ i ]); add_node ( i , A [ i ]); } for ( int i = 0 ; i < M ; i ++ ) { int s1 , t1 , s2 , t2 ; read_int ( s1 ); read_int ( t1 ); read_int ( s2 ); read_int ( t2 ); int from = add_node ( s1 , t1 ); int to = add_node ( s2 , t2 ); add_edge ( from , to , 1 ); } int S = nd ; for ( int i = 1 ; i <= N ; i ++ ) { sort ( V [ i ]. begin (), V [ i ]. end ()); int prev_id = S , prev_pos = 0 ; for ( int j = 0 ; j < V [ i ]. size (); j ++ ) { int now_id = get_node ( i , V [ i ][ j ]), now_pos = V [ i ][ j ]; add_edge ( prev_id , now_id , now_pos - prev_pos ); prev_id = now_id , prev_pos = now_pos ; } V [ i ]. clear (); } LL ans = dfs ( S ); if ( ans >= INF ) cout << \"LoveLive! \\n \" ; else cout << ans << '\\n' ; memset ( vis , 0 , sizeof ( vis )); memset ( done , 0 , sizeof ( done )); memset ( dist , 0 , sizeof ( dist )); for ( int i = 0 ; i <= nd ; i ++ ) G [ i ]. clear (); mp . clear (); nd = 0 ; } return EXIT_SUCCESS ; } // input optimize inline int read_char () { constexpr int N = 1 << 20 ; static char buf [ N ]; static char * p = buf , * end = buf ; if ( p == end ) { if ( ( end = buf + fread_unlocked ( buf , 1 , N , stdin )) == buf ) return EOF ; p = buf ; } return * p ++ ; } inline int read_int ( int & x ) { static char c , neg ; while ( ( c = read_char ()) < '-' ) if ( c == EOF ) return 0 ; neg = ( c == '-' ) ? - 1 : 1 ; x = ( neg == 1 ) ? c - '0' : 0 ; while ( ( c = read_char ()) >= '0' ) x = ( x << 3 ) + ( x << 1 ) + ( c - '0' ); x *= neg ; return 1 ; } // output optimize #define _pc putchar_unlocked char _buf [ 128 ]; inline void write_int ( LL x ) { if ( ! x ) { _pc ( '0' ); _pc ( '\\n' ); return ; } int t = 0 ; while ( x ) { _buf [ t ++ ] = x % 10 + '0' ; x /= 10 ; } while ( t -- ) _pc ( _buf [ t ]); _pc ( '\\n' ); } #undef _pc","title":"Code"},{"location":"courses/ada-fall-2019/hw3/traveling-pony-problem/","text":"Traveling Pony Problem \u00b6 Problem Description \u00b6 Yun-Nung (Vivian) Chen's website Concept \u00b6 First Stage: Find the minimum possible protection min_l By altered Dijkstra By Disjoint Set Union (the usage is like Kruskal ) Second Stage: Run normal Dijkstra On the graph which all edges' weight \\leq \\leq min_l Code \u00b6 #include <bits/stdc++.h> #define IOS {ios::sync_with_stdio(false);cin.tie(nullptr);} #pragma GCC optimize(\"Ofast\", \"no-stack-protector\", \"unroll-loops\") #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,sse4.2,popcnt,abm,mmx,avx,tune=native\") using namespace std ; using LL = int64_t ; using ULL = uint64_t ; using LD = long double ; using pii = pair < LL , LL > ; inline int read_int ( int & ); constexpr int MAXN = 2e5 + 5 , MAXM = 5e5 + 5 ; constexpr LL INF = ( 1LL << 61 ) + 1 ; int n ; struct DSU { int parent [ MAXN ], size [ MAXN ]; void init ( int n ) { for ( int i = 0 ; i < n ; i ++ ) mk_set ( i ); } void mk_set ( int v ) { parent [ v ] = v ; size [ v ] = 1 ; } int find_set ( int v ) { if ( v == parent [ v ] ) return v ; return ( parent [ v ] = find_set ( parent [ v ])); } void unite_set ( int v , int u ) { v = find_set ( v ), u = find_set ( u ); if ( v != u ) { if ( size [ v ] < size [ u ] ) swap ( v , u ); parent [ u ] = v ; size [ v ] += size [ u ]; } } } dsu ; struct Dijkstra { vector < pii > adj [ MAXN ]; // first: weight, second: to LL min_d [ MAXN ]; Dijkstra () = default ; void add_edge ( int u , int v , int w ) { adj [ u ]. push_back ( { w , v } ); } LL run ( int src , int dst ) { fill ( min_d , min_d + n , INF ); min_d [ src ] = 0 ; priority_queue < pii , vector < pii > , greater < pii > > pq ; pq . push ({ 0 , src }); while ( ! pq . empty () ) { LL v = pq . top (). second , d_v = pq . top (). first ; pq . pop (); if ( d_v != min_d [ v ] ) continue ; if ( v == dst ) return d_v ; for ( auto e : adj [ v ] ) { LL to = e . second , wei = e . first ; if ( d_v + wei < min_d [ to ] ) { min_d [ to ] = min_d [ v ] + wei ; pq . push ( { min_d [ to ], to } ); } } } } } G ; struct Edge { int x , y , d , l ; bool operator < ( const Edge & rhs ) const { return l < rhs . l ; } }; Edge edges [ MAXM ]; int main () { IOS ; int m ; read_int ( n ); read_int ( m ); int s , t ; read_int ( s ); read_int ( t ); if ( s == t ) { cout << \"0 0 \\n \" ; return 0 ; } for ( int i = 0 ; i < m ; i ++ ) { read_int ( edges [ i ]. x ); read_int ( edges [ i ]. y ); read_int ( edges [ i ]. d ); read_int ( edges [ i ]. l ); } sort ( edges , edges + m ); if ( edges [ 0 ]. l == edges [ m - 1 ]. l ) { for ( auto e : edges ) { G . add_edge ( e . x , e . y , e . d ); G . add_edge ( e . y , e . x , e . d ); } cout << G . run ( s , t ) << ' ' << edges [ 0 ]. l << '\\n' ; return 0 ; } int L = 0 ; dsu . init ( n ); for ( Edge * it = edges ; it != edges + m ; ++ it ) { dsu . unite_set ( it -> x , it -> y ); G . add_edge ( it -> x , it -> y , it -> d ); G . add_edge ( it -> y , it -> x , it -> d ); if ( dsu . find_set ( s ) == dsu . find_set ( t ) ) { L = it -> l ; for ( ++ it ; it != edges + m && it -> l == L ; ++ it ) { G . add_edge ( it -> x , it -> y , it -> d ); G . add_edge ( it -> y , it -> x , it -> d ); } break ; } } cout << G . run ( s , t ) << ' ' << L << '\\n' ; return 0 ; } // input optimize inline int read_char () { constexpr int N = 1 << 20 ; static char buf [ N ]; static char * p = buf , * end = buf ; if ( p == end ) { if ( ( end = buf + fread_unlocked ( buf , 1 , N , stdin )) == buf ) return EOF ; p = buf ; } return * p ++ ; } inline int read_int ( int & x ) { static char c , neg ; while ( ( c = read_char ()) < '-' ) if ( c == EOF ) return 0 ; neg = ( c == '-' ) ? - 1 : 1 ; x = ( neg == 1 ) ? c - '0' : 0 ; while ( ( c = read_char ()) >= '0' ) x = ( x << 3 ) + ( x << 1 ) + ( c - '0' ); x *= neg ; return 1 ; } // output optimize #define _pc putchar_unlocked char _buf [ 128 ]; inline void write_int ( LL x ) { if ( ! x ) { _pc ( '0' ); _pc ( '\\n' ); return ; } int t = 0 ; while ( x ) { _buf [ t ++ ] = x % 10 + '0' ; x /= 10 ; } while ( t -- ) _pc ( _buf [ t ]); _pc ( '\\n' ); } #undef _pc","title":"Traveling Pony Problem"},{"location":"courses/ada-fall-2019/hw3/traveling-pony-problem/#traveling-pony-problem","text":"","title":"Traveling Pony Problem"},{"location":"courses/ada-fall-2019/hw3/traveling-pony-problem/#problem-description","text":"Yun-Nung (Vivian) Chen's website","title":"Problem Description"},{"location":"courses/ada-fall-2019/hw3/traveling-pony-problem/#concept","text":"First Stage: Find the minimum possible protection min_l By altered Dijkstra By Disjoint Set Union (the usage is like Kruskal ) Second Stage: Run normal Dijkstra On the graph which all edges' weight \\leq \\leq min_l","title":"Concept"},{"location":"courses/ada-fall-2019/hw3/traveling-pony-problem/#code","text":"#include <bits/stdc++.h> #define IOS {ios::sync_with_stdio(false);cin.tie(nullptr);} #pragma GCC optimize(\"Ofast\", \"no-stack-protector\", \"unroll-loops\") #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,sse4.2,popcnt,abm,mmx,avx,tune=native\") using namespace std ; using LL = int64_t ; using ULL = uint64_t ; using LD = long double ; using pii = pair < LL , LL > ; inline int read_int ( int & ); constexpr int MAXN = 2e5 + 5 , MAXM = 5e5 + 5 ; constexpr LL INF = ( 1LL << 61 ) + 1 ; int n ; struct DSU { int parent [ MAXN ], size [ MAXN ]; void init ( int n ) { for ( int i = 0 ; i < n ; i ++ ) mk_set ( i ); } void mk_set ( int v ) { parent [ v ] = v ; size [ v ] = 1 ; } int find_set ( int v ) { if ( v == parent [ v ] ) return v ; return ( parent [ v ] = find_set ( parent [ v ])); } void unite_set ( int v , int u ) { v = find_set ( v ), u = find_set ( u ); if ( v != u ) { if ( size [ v ] < size [ u ] ) swap ( v , u ); parent [ u ] = v ; size [ v ] += size [ u ]; } } } dsu ; struct Dijkstra { vector < pii > adj [ MAXN ]; // first: weight, second: to LL min_d [ MAXN ]; Dijkstra () = default ; void add_edge ( int u , int v , int w ) { adj [ u ]. push_back ( { w , v } ); } LL run ( int src , int dst ) { fill ( min_d , min_d + n , INF ); min_d [ src ] = 0 ; priority_queue < pii , vector < pii > , greater < pii > > pq ; pq . push ({ 0 , src }); while ( ! pq . empty () ) { LL v = pq . top (). second , d_v = pq . top (). first ; pq . pop (); if ( d_v != min_d [ v ] ) continue ; if ( v == dst ) return d_v ; for ( auto e : adj [ v ] ) { LL to = e . second , wei = e . first ; if ( d_v + wei < min_d [ to ] ) { min_d [ to ] = min_d [ v ] + wei ; pq . push ( { min_d [ to ], to } ); } } } } } G ; struct Edge { int x , y , d , l ; bool operator < ( const Edge & rhs ) const { return l < rhs . l ; } }; Edge edges [ MAXM ]; int main () { IOS ; int m ; read_int ( n ); read_int ( m ); int s , t ; read_int ( s ); read_int ( t ); if ( s == t ) { cout << \"0 0 \\n \" ; return 0 ; } for ( int i = 0 ; i < m ; i ++ ) { read_int ( edges [ i ]. x ); read_int ( edges [ i ]. y ); read_int ( edges [ i ]. d ); read_int ( edges [ i ]. l ); } sort ( edges , edges + m ); if ( edges [ 0 ]. l == edges [ m - 1 ]. l ) { for ( auto e : edges ) { G . add_edge ( e . x , e . y , e . d ); G . add_edge ( e . y , e . x , e . d ); } cout << G . run ( s , t ) << ' ' << edges [ 0 ]. l << '\\n' ; return 0 ; } int L = 0 ; dsu . init ( n ); for ( Edge * it = edges ; it != edges + m ; ++ it ) { dsu . unite_set ( it -> x , it -> y ); G . add_edge ( it -> x , it -> y , it -> d ); G . add_edge ( it -> y , it -> x , it -> d ); if ( dsu . find_set ( s ) == dsu . find_set ( t ) ) { L = it -> l ; for ( ++ it ; it != edges + m && it -> l == L ; ++ it ) { G . add_edge ( it -> x , it -> y , it -> d ); G . add_edge ( it -> y , it -> x , it -> d ); } break ; } } cout << G . run ( s , t ) << ' ' << L << '\\n' ; return 0 ; } // input optimize inline int read_char () { constexpr int N = 1 << 20 ; static char buf [ N ]; static char * p = buf , * end = buf ; if ( p == end ) { if ( ( end = buf + fread_unlocked ( buf , 1 , N , stdin )) == buf ) return EOF ; p = buf ; } return * p ++ ; } inline int read_int ( int & x ) { static char c , neg ; while ( ( c = read_char ()) < '-' ) if ( c == EOF ) return 0 ; neg = ( c == '-' ) ? - 1 : 1 ; x = ( neg == 1 ) ? c - '0' : 0 ; while ( ( c = read_char ()) >= '0' ) x = ( x << 3 ) + ( x << 1 ) + ( c - '0' ); x *= neg ; return 1 ; } // output optimize #define _pc putchar_unlocked char _buf [ 128 ]; inline void write_int ( LL x ) { if ( ! x ) { _pc ( '0' ); _pc ( '\\n' ); return ; } int t = 0 ; while ( x ) { _buf [ t ++ ] = x % 10 + '0' ; x /= 10 ; } while ( t -- ) _pc ( _buf [ t ]); _pc ( '\\n' ); } #undef _pc","title":"Code"},{"location":"courses/ada-fall-2019/hw4/hex/","text":"Hex \u00b6 Problem Description \u00b6 Yun-Nung (Vivian) Chen's website TA's Hint \u00b6 There are many different approaches that can solve this problem. You can try the following ways (or combine some of them): alpha-beta pruning Monte Carlo simulation heuristic algorithms based on human knowledge Concept \u00b6 assign each possible move a weight by some heuristics choose the move with highest weight my heuristics is bad and the code is ugly, please don't read it Code \u00b6 #include <bits/stdc++.h> #include \"hex.h\" using namespace std ; using pii = pair < int , int > ; constexpr int MAXN = 8 ; constexpr int Me = 1 , He = 2 ; const vector < pii > Adj = { pii ( - 1 , 1 ), pii ( - 1 , 0 ), pii ( 1 , - 1 ), pii ( 1 , 0 ), pii ( - 1 , 1 ), pii ( 0 , 1 )}; const vector < pii > GoodUp = { pii ( - 1 , 1 ), pii ( - 1 , 0 )}; const vector < pii > GoodDown = { pii ( 1 , - 1 ), pii ( 1 , 0 )}; const vector < pii > BadAdj = { pii ( 0 , - 1 ), pii ( 1 , - 1 ), pii ( - 1 , 1 ), pii ( 0 , 1 )}; const vector < pii > GoodBri = { pii ( - 2 , 1 ), pii ( 2 , - 1 )}; const vector < pii > BadBri = { pii ( 1 , - 2 ), pii ( - 1 , 2 )}; const vector < pii > Block = { pii ( 1 , 0 ), pii ( 0 , 1 )}; int board [ MAXN ][ MAXN ]; int n ; pii SRC ; int W [ MAXN ][ MAXN ]; int cnt ; void init2 ( int _n ) { n = _n ; cnt = 0 ; memset ( board , 0 , sizeof board ); } void init ( int _n ) { if ( _n == 5 ) { init2 ( _n ); return ; } srand ( 7902064 ); n = _n ; memset ( board , 0 , sizeof board ); memset ( W , 0 , sizeof ( W )); int x = n / 2 , y = n / 2 ; if ( n % 2 == 0 ) -- x ; W [ x ][ y ] += 100 ; SRC = pii ( x , y ); } bool in_board ( int i , int j ) { return i >= 0 && j >= 0 && i < n && j < n ; } int how_many ( int i , int j , int label , vector < pii > DIR ) { int cnt = 0 ; for ( pii d : DIR ) { int ni = i + d . first , nj = j + d . second ; if ( in_board ( ni , nj ) && board [ ni ][ nj ] == label ) ++ cnt ; } return cnt ; } int plus_adj ( int i , int j , int add , vector < pii > DIR ) { int cnt = 0 ; for ( pii d : DIR ) { int ni = i + d . first , nj = j + d . second ; if ( in_board ( ni , nj ) && board [ ni ][ nj ] == 0 ) W [ ni ][ nj ] += add , ++ cnt ; } return cnt ; } void good ( int i , int j ) { int up_me = how_many ( i , j , Me , GoodUp ); if ( up_me >= 1 || i == 0 ) ++ W [ i ][ j ]; int down_me = how_many ( i , j , Me , GoodDown ); if ( down_me >= 1 || i == n - 1 ) ++ W [ i ][ j ]; } void bad ( int i , int j ) { int up_he = how_many ( i , j , He , GoodUp ); int down_he = how_many ( i , j , He , GoodDown ); if ( up_he > 0 ) W [ i ][ j ] -- ; if ( down_he > 0 ) W [ i ][ j ] -- ; } void block ( int i , int j ) { int a = how_many ( i , j , He , BadAdj ); if ( a > 0 ) W [ i ][ j ] += 2 ; } pii decide2 ( pii p ) { if ( p != make_pair ( - 1 , - 1 ) ) board [ p . first ][ p . second ] = He ; if ( cnt == 0 ) { ++ cnt ; int x = n / 2 , y = n / 2 ; if ( n % 2 == 0 ) -- x ; board [ x ][ y ] = Me ; return pii ( x , y ); } memset ( W , 0 , sizeof ( W )); for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { good ( i , j ); bad ( i , j ); block ( i , j ); } } int best = 0 ; pii best_pos = { 0 , 0 }; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( board [ i ][ j ] == 0 && W [ i ][ j ] > best ) { best = W [ i ][ j ]; best_pos = pii ( i , j ); } } } board [ best_pos . first ][ best_pos . second ] = Me ; ++ cnt ; return best_pos ; } pii decide ( pii p ) { if ( n == 5 ) return decide2 ( p ); if ( p != make_pair ( - 1 , - 1 ) ) board [ p . first ][ p . second ] = He ; if ( p . second > 0 ) W [ p . first ][ p . second - 1 ] += 1 ; plus_adj ( p . first , p . second , 1 , Block ); for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( board [ i ][ j ] == Me ) { if ( how_many ( i , j , Me , GoodUp ) == 0 ) plus_adj ( i , j , 2 , GoodUp ); if ( how_many ( i , j , Me , GoodDown ) == 0 ) plus_adj ( i , j , 2 , GoodDown ); } for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( board [ i ][ j ] == 0 && ( how_many ( i , j , He , GoodUp ) == 2 || how_many ( i , j , He , GoodDown ) == 2 ) ) W [ i ][ j ] = 0 ; int best = - 1 ; vector < pii > L ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( board [ i ][ j ] == 0 && W [ i ][ j ] > best ) { best = W [ i ][ j ]; L . clear (); L . push_back ( pii ( i , j )); } else if ( board [ i ][ j ] == 0 && W [ i ][ j ] == best ) { L . push_back ( pii ( i , j )); } } } pii best_pos = L [ rand () % L . size ()]; board [ best_pos . first ][ best_pos . second ] = Me ; memset ( W , 0 , sizeof ( W )); return best_pos ; }","title":"Hex"},{"location":"courses/ada-fall-2019/hw4/hex/#hex","text":"","title":"Hex"},{"location":"courses/ada-fall-2019/hw4/hex/#problem-description","text":"Yun-Nung (Vivian) Chen's website","title":"Problem Description"},{"location":"courses/ada-fall-2019/hw4/hex/#tas-hint","text":"There are many different approaches that can solve this problem. You can try the following ways (or combine some of them): alpha-beta pruning Monte Carlo simulation heuristic algorithms based on human knowledge","title":"TA's Hint"},{"location":"courses/ada-fall-2019/hw4/hex/#concept","text":"assign each possible move a weight by some heuristics choose the move with highest weight my heuristics is bad and the code is ugly, please don't read it","title":"Concept"},{"location":"courses/ada-fall-2019/hw4/hex/#code","text":"#include <bits/stdc++.h> #include \"hex.h\" using namespace std ; using pii = pair < int , int > ; constexpr int MAXN = 8 ; constexpr int Me = 1 , He = 2 ; const vector < pii > Adj = { pii ( - 1 , 1 ), pii ( - 1 , 0 ), pii ( 1 , - 1 ), pii ( 1 , 0 ), pii ( - 1 , 1 ), pii ( 0 , 1 )}; const vector < pii > GoodUp = { pii ( - 1 , 1 ), pii ( - 1 , 0 )}; const vector < pii > GoodDown = { pii ( 1 , - 1 ), pii ( 1 , 0 )}; const vector < pii > BadAdj = { pii ( 0 , - 1 ), pii ( 1 , - 1 ), pii ( - 1 , 1 ), pii ( 0 , 1 )}; const vector < pii > GoodBri = { pii ( - 2 , 1 ), pii ( 2 , - 1 )}; const vector < pii > BadBri = { pii ( 1 , - 2 ), pii ( - 1 , 2 )}; const vector < pii > Block = { pii ( 1 , 0 ), pii ( 0 , 1 )}; int board [ MAXN ][ MAXN ]; int n ; pii SRC ; int W [ MAXN ][ MAXN ]; int cnt ; void init2 ( int _n ) { n = _n ; cnt = 0 ; memset ( board , 0 , sizeof board ); } void init ( int _n ) { if ( _n == 5 ) { init2 ( _n ); return ; } srand ( 7902064 ); n = _n ; memset ( board , 0 , sizeof board ); memset ( W , 0 , sizeof ( W )); int x = n / 2 , y = n / 2 ; if ( n % 2 == 0 ) -- x ; W [ x ][ y ] += 100 ; SRC = pii ( x , y ); } bool in_board ( int i , int j ) { return i >= 0 && j >= 0 && i < n && j < n ; } int how_many ( int i , int j , int label , vector < pii > DIR ) { int cnt = 0 ; for ( pii d : DIR ) { int ni = i + d . first , nj = j + d . second ; if ( in_board ( ni , nj ) && board [ ni ][ nj ] == label ) ++ cnt ; } return cnt ; } int plus_adj ( int i , int j , int add , vector < pii > DIR ) { int cnt = 0 ; for ( pii d : DIR ) { int ni = i + d . first , nj = j + d . second ; if ( in_board ( ni , nj ) && board [ ni ][ nj ] == 0 ) W [ ni ][ nj ] += add , ++ cnt ; } return cnt ; } void good ( int i , int j ) { int up_me = how_many ( i , j , Me , GoodUp ); if ( up_me >= 1 || i == 0 ) ++ W [ i ][ j ]; int down_me = how_many ( i , j , Me , GoodDown ); if ( down_me >= 1 || i == n - 1 ) ++ W [ i ][ j ]; } void bad ( int i , int j ) { int up_he = how_many ( i , j , He , GoodUp ); int down_he = how_many ( i , j , He , GoodDown ); if ( up_he > 0 ) W [ i ][ j ] -- ; if ( down_he > 0 ) W [ i ][ j ] -- ; } void block ( int i , int j ) { int a = how_many ( i , j , He , BadAdj ); if ( a > 0 ) W [ i ][ j ] += 2 ; } pii decide2 ( pii p ) { if ( p != make_pair ( - 1 , - 1 ) ) board [ p . first ][ p . second ] = He ; if ( cnt == 0 ) { ++ cnt ; int x = n / 2 , y = n / 2 ; if ( n % 2 == 0 ) -- x ; board [ x ][ y ] = Me ; return pii ( x , y ); } memset ( W , 0 , sizeof ( W )); for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { good ( i , j ); bad ( i , j ); block ( i , j ); } } int best = 0 ; pii best_pos = { 0 , 0 }; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( board [ i ][ j ] == 0 && W [ i ][ j ] > best ) { best = W [ i ][ j ]; best_pos = pii ( i , j ); } } } board [ best_pos . first ][ best_pos . second ] = Me ; ++ cnt ; return best_pos ; } pii decide ( pii p ) { if ( n == 5 ) return decide2 ( p ); if ( p != make_pair ( - 1 , - 1 ) ) board [ p . first ][ p . second ] = He ; if ( p . second > 0 ) W [ p . first ][ p . second - 1 ] += 1 ; plus_adj ( p . first , p . second , 1 , Block ); for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( board [ i ][ j ] == Me ) { if ( how_many ( i , j , Me , GoodUp ) == 0 ) plus_adj ( i , j , 2 , GoodUp ); if ( how_many ( i , j , Me , GoodDown ) == 0 ) plus_adj ( i , j , 2 , GoodDown ); } for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( board [ i ][ j ] == 0 && ( how_many ( i , j , He , GoodUp ) == 2 || how_many ( i , j , He , GoodDown ) == 2 ) ) W [ i ][ j ] = 0 ; int best = - 1 ; vector < pii > L ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( board [ i ][ j ] == 0 && W [ i ][ j ] > best ) { best = W [ i ][ j ]; L . clear (); L . push_back ( pii ( i , j )); } else if ( board [ i ][ j ] == 0 && W [ i ][ j ] == best ) { L . push_back ( pii ( i , j )); } } } pii best_pos = L [ rand () % L . size ()]; board [ best_pos . first ][ best_pos . second ] = Me ; memset ( W , 0 , sizeof ( W )); return best_pos ; }","title":"Code"},{"location":"courses/ada-fall-2019/hw4/loopy-tippy/","text":"Loopy Tippy \u00b6 Problem Description \u00b6 Yun-Nung (Vivian) Chen's website TA's Hint \u00b6 The constraints can be modeled as three parts: The number of edges Simple loops Connectivity n^4 n^4 variables: x_{i,j}^t x_{i,j}^t denotes whether (i, j) (i, j) is reachable at time t t . Online Resources \u00b6 Slitherlink Reloaded Code \u00b6 #include <bits/stdc++.h> #define IOS { ios::sync_with_stdio(false); cin.tie(nullptr); } #pragma GCC optimize(\"Ofast\", \"no-stack-protector\", \"unroll-loops\") #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,sse4.2,popcnt,abm,mmx,avx,tune=native\") #ifndef DIMACS #include <cryptominisat5/cryptominisat.h> #else #include <fstream> #include <vector> #endif namespace sat { #ifndef DIMACS CMSat :: SATSolver solver ; std :: vector < CMSat :: Lit > lit_buf ; void Init ( int n ) { solver . new_vars ( n + 1 ); } void AddClause ( std :: vector < int > v ) { lit_buf . clear (); lit_buf . reserve ( v . size ()); for ( int x : v ) lit_buf . emplace_back ( abs ( x ), x < 0 ); solver . add_clause ( lit_buf ); } bool Solve () { return solver . solve () == CMSat :: l_True ; } int GetResult ( int id ) { auto r = solver . get_model ()[ id ]; return r == CMSat :: l_True ? 1 : r == CMSat :: l_False ? - 1 : 0 ; } #else std :: vector < std :: vector < int >> clauses ; int n_vars ; void Init ( int n ) { n_vars = n ; } void AddClause ( std :: vector < int > v ) { clauses . emplace_back ( std :: move ( v )); } bool Solve () { std :: fstream fs ( \"out.dimacs\" , fs . trunc | fs . out ); fs << \"p cnf \" << n_vars << ' ' << clauses . size () << '\\n' ; for ( auto & v : clauses ) { for ( auto x : v ) fs << x << ' ' ; fs << \"0 \\n \" ; } fs . close (); exit ( 0 ); } int GetResult ( int id ) { return 0 ; } #endif // DIMACS } // namespace sat using namespace std ; using LL = long long ; using ULL = unsigned long long ; using pii = pair < int , int > ; constexpr int MAXR = 128 ; constexpr int MAXC = 128 ; int r , c , board [ MAXR ][ MAXC ]; bool is_wall [ MAXR + MAXC + 2 * MAXR * MAXC ]; inline int id_h ( int i , int j ) { return i * ( 2 * c + 1 ) + j + 1 ; } inline int id_v ( int i , int j ) { return c + i * ( 2 * c + 1 ) + j + 1 ; } void all_false ( vector < int >& S ) { for ( int v : S ) { vector < int > vv = { - v }; sat :: AddClause ( vv ); } } void exactly_one ( vector < int >& S ) { sat :: AddClause ( S ); int sz = S . size (); for ( int i = 0 ; i < sz ; i ++ ) for ( int j = i + 1 ; j < sz ; j ++ ) { vector < int > vv = { - S [ i ], - S [ j ]}; sat :: AddClause ( vv ); } } void exactly_one_false ( vector < int > & S ) { for ( int & v : S ) v = - v ; exactly_one ( S ); } void exactly_two ( vector < int > & S ) { for ( int i = 0 ; i < 4 ; i ++ ) { vector < int > vv ; for ( int j = 0 ; j < 4 ; j ++ ) if ( j != i ) vv . push_back ( S [ j ]); sat :: AddClause ( vv ); for ( int & v : vv ) v = - v ; sat :: AddClause ( vv ); } } void exactly_two_or_none ( vector < int > & S ) { if ( S . size () == 2 ) { vector < int > v1 = { - S [ 0 ], S [ 1 ]}, v2 = { S [ 0 ], - S [ 1 ]}; sat :: AddClause ( v1 ); sat :: AddClause ( v2 ); } else if ( S . size () == 3 ) { for ( int i = 0 ; i < 3 ; i ++ ) { S [ i ] = - S [ i ]; sat :: AddClause ( S ); S [ i ] = - S [ i ]; } for ( int & i : S ) i = - i ; sat :: AddClause ( S ); } else if ( S . size () == 4 ) { for ( int i = 0 ; i < 4 ; i ++ ) { S [ i ] = - S [ i ]; sat :: AddClause ( S ); S [ i ] = - S [ i ]; } for ( int i = 0 ; i < 4 ; i ++ ) { vector < int > vv ; for ( int j = 0 ; j < 4 ; j ++ ) if ( j != i ) vv . push_back ( - S [ j ]); sat :: AddClause ( vv ); } } } bool vis [ MAXR ][ MAXC ]; stack < pii > stk ; void floodfill () { while ( ! stk . empty () ) { pii v = stk . top (); stk . pop (); int i = v . first , j = v . second ; if ( vis [ i ][ j ] ) continue ; vis [ i ][ j ] = true ; if ( i > 0 && ! is_wall [ id_h ( i , j )] ) stk . push ( pii ( i - 1 , j )); if ( i < r - 1 && ! is_wall [ id_h ( i + 1 , j )] ) stk . push ( pii ( i + 1 , j )); if ( j > 0 && ! is_wall [ id_v ( i , j )] ) stk . push ( pii ( i , j - 1 )); if ( j < c - 1 && ! is_wall [ id_v ( i , j + 1 )] ) stk . push ( pii ( i , j + 1 )); } } pii first_loop ; bool valid () { for ( int i = 0 ; i < c ; i ++ ) if ( ! is_wall [ id_h ( 0 , i )] ) stk . push ( pii ( 0 , i )); for ( int i = 0 ; i < c ; i ++ ) if ( ! is_wall [ id_h ( r , i )] ) stk . push ( pii ( r - 1 , i )); for ( int i = 1 ; i < r - 1 ; i ++ ) if ( ! is_wall [ id_v ( i , 0 )] ) stk . push ( pii ( i , 0 )); for ( int i = 1 ; i < r - 1 ; i ++ ) if ( ! is_wall [ id_v ( i , c )] ) stk . push ( pii ( i , c - 1 )); bool f = true ; for ( int i = 0 ; i < r && f ; i ++ ) for ( int j = 0 ; j < c ; j ++ ) if ( is_wall [ id_v ( i , j )] ) { stk . push ( pii ( i , j )); first_loop = pii ( i , j ); f = false ; break ; } memset ( vis , 0 , sizeof ( vis )); floodfill (); for ( int i = 0 ; i < r ; i ++ ) for ( int j = 0 ; j < c ; j ++ ) if ( ! vis [ i ][ j ] ) return false ; return true ; } void get_loop ( int i , int j , vector < int >& L ) { stk . push ( pii ( i , j )); while ( ! stk . empty () ) { pii v = stk . top (); stk . pop (); int i = v . first , j = v . second ; if ( vis [ i ][ j ] ) continue ; vis [ i ][ j ] = true ; if ( i > 0 && ! is_wall [ id_h ( i , j )] ) stk . push ( pii ( i - 1 , j )); if ( i < r - 1 && ! is_wall [ id_h ( i + 1 , j )] ) stk . push ( pii ( i + 1 , j )); if ( j > 0 && ! is_wall [ id_v ( i , j )] ) stk . push ( pii ( i , j - 1 )); if ( j < c - 1 && ! is_wall [ id_v ( i , j + 1 )] ) stk . push ( pii ( i , j + 1 )); if ( is_wall [ id_h ( i , j )] ) L . push_back ( id_h ( i , j )); if ( is_wall [ id_h ( i + 1 , j )] ) L . push_back ( id_h ( i + 1 , j )); if ( is_wall [ id_v ( i , j )] ) L . push_back ( id_v ( i , j )); if ( is_wall [ id_v ( i , j + 1 )] ) L . push_back ( id_v ( i , j + 1 )); } } int main () { IOS ; cin >> r >> c ; for ( int i = 0 ; i < r ; i ++ ) { string s ; cin >> s ; for ( int j = 0 ; j < c ; j ++ ) board [ i ][ j ] = s [ j ] - '0' ; } int nd = 2 * r * c + r + c ; sat :: Init ( nd ); for ( int i = 0 ; i < r ; i ++ ) { for ( int j = 0 ; j < c ; j ++ ) { vector < int > S = { id_h ( i , j ), id_h ( i + 1 , j ), id_v ( i , j ), id_v ( i , j + 1 )}; switch ( board [ i ][ j ] ) { case 0 : all_false ( S ); break ; case 1 : exactly_one ( S ); break ; case 2 : exactly_two ( S ); break ; case 3 : exactly_one_false ( S ); break ; } } } for ( int i = 0 ; i <= r ; i ++ ) { for ( int j = 0 ; j <= c ; j ++ ) { vector < int > v ; if ( i < r ) v . push_back ( id_v ( i , j )); if ( i > 0 ) v . push_back ( id_v ( i - 1 , j )); if ( j < c ) v . push_back ( id_h ( i , j )); if ( j > 0 ) v . push_back ( id_h ( i , j - 1 )); exactly_two_or_none ( v ); } } while ( true ) { if ( ! sat :: Solve () ) { cerr << \"cannot solve \\n \" ; exit ( 128 ); } memset ( is_wall , 0 , sizeof ( is_wall )); for ( int i = 1 ; i <= nd ; i ++ ) is_wall [ i ] = ( sat :: GetResult ( i ) == 1 ); if ( valid () ) { break ; } else { for ( int i = 0 ; i < r ; i ++ ) { for ( int j = 0 ; j < c ; j ++ ) { if ( ! vis [ i ][ j ] ) { vector < int > v ; get_loop ( i , j , v ); for ( int & i : v ) i = - i ; sat :: AddClause ( v ); } } } memset ( vis , 0 , sizeof ( vis )); vector < int > v ; get_loop ( first_loop . first , first_loop . second , v ); for ( int & i : v ) i = - i ; sat :: AddClause ( v ); } } for ( int i = 1 ; i <= nd ; i ++ ) cout << is_wall [ i ]; cout << '\\n' ; #ifdef DEBUG for ( int i = 0 ; i < r ; i ++ ) { for ( int j = 0 ; j < c ; j ++ ) cout << \"+\" << ( is_wall [ id_h ( i , j )] ? \"-\" : \" \" ); cout << \"+ \\n \" ; for ( int j = 0 ; j < c ; j ++ ) cout << ( is_wall [ id_v ( i , j )] ? \"|\" : \" \" ) << ( char )( board [ i ][ j ] + '0' ); cout << ( is_wall [ id_v ( i , c )] ? \"| \\n \" : \" \\n \" ); } for ( int j = 0 ; j < c ; j ++ ) cout << \"+\" << ( is_wall [ id_h ( r , j )] ? \"-\" : \" \" ); cout << \"+ \\n \" ; #endif return EXIT_SUCCESS ; }","title":"Loopy Tippy"},{"location":"courses/ada-fall-2019/hw4/loopy-tippy/#loopy-tippy","text":"","title":"Loopy Tippy"},{"location":"courses/ada-fall-2019/hw4/loopy-tippy/#problem-description","text":"Yun-Nung (Vivian) Chen's website","title":"Problem Description"},{"location":"courses/ada-fall-2019/hw4/loopy-tippy/#tas-hint","text":"The constraints can be modeled as three parts: The number of edges Simple loops Connectivity n^4 n^4 variables: x_{i,j}^t x_{i,j}^t denotes whether (i, j) (i, j) is reachable at time t t .","title":"TA's Hint"},{"location":"courses/ada-fall-2019/hw4/loopy-tippy/#online-resources","text":"Slitherlink Reloaded","title":"Online Resources"},{"location":"courses/ada-fall-2019/hw4/loopy-tippy/#code","text":"#include <bits/stdc++.h> #define IOS { ios::sync_with_stdio(false); cin.tie(nullptr); } #pragma GCC optimize(\"Ofast\", \"no-stack-protector\", \"unroll-loops\") #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,sse4.2,popcnt,abm,mmx,avx,tune=native\") #ifndef DIMACS #include <cryptominisat5/cryptominisat.h> #else #include <fstream> #include <vector> #endif namespace sat { #ifndef DIMACS CMSat :: SATSolver solver ; std :: vector < CMSat :: Lit > lit_buf ; void Init ( int n ) { solver . new_vars ( n + 1 ); } void AddClause ( std :: vector < int > v ) { lit_buf . clear (); lit_buf . reserve ( v . size ()); for ( int x : v ) lit_buf . emplace_back ( abs ( x ), x < 0 ); solver . add_clause ( lit_buf ); } bool Solve () { return solver . solve () == CMSat :: l_True ; } int GetResult ( int id ) { auto r = solver . get_model ()[ id ]; return r == CMSat :: l_True ? 1 : r == CMSat :: l_False ? - 1 : 0 ; } #else std :: vector < std :: vector < int >> clauses ; int n_vars ; void Init ( int n ) { n_vars = n ; } void AddClause ( std :: vector < int > v ) { clauses . emplace_back ( std :: move ( v )); } bool Solve () { std :: fstream fs ( \"out.dimacs\" , fs . trunc | fs . out ); fs << \"p cnf \" << n_vars << ' ' << clauses . size () << '\\n' ; for ( auto & v : clauses ) { for ( auto x : v ) fs << x << ' ' ; fs << \"0 \\n \" ; } fs . close (); exit ( 0 ); } int GetResult ( int id ) { return 0 ; } #endif // DIMACS } // namespace sat using namespace std ; using LL = long long ; using ULL = unsigned long long ; using pii = pair < int , int > ; constexpr int MAXR = 128 ; constexpr int MAXC = 128 ; int r , c , board [ MAXR ][ MAXC ]; bool is_wall [ MAXR + MAXC + 2 * MAXR * MAXC ]; inline int id_h ( int i , int j ) { return i * ( 2 * c + 1 ) + j + 1 ; } inline int id_v ( int i , int j ) { return c + i * ( 2 * c + 1 ) + j + 1 ; } void all_false ( vector < int >& S ) { for ( int v : S ) { vector < int > vv = { - v }; sat :: AddClause ( vv ); } } void exactly_one ( vector < int >& S ) { sat :: AddClause ( S ); int sz = S . size (); for ( int i = 0 ; i < sz ; i ++ ) for ( int j = i + 1 ; j < sz ; j ++ ) { vector < int > vv = { - S [ i ], - S [ j ]}; sat :: AddClause ( vv ); } } void exactly_one_false ( vector < int > & S ) { for ( int & v : S ) v = - v ; exactly_one ( S ); } void exactly_two ( vector < int > & S ) { for ( int i = 0 ; i < 4 ; i ++ ) { vector < int > vv ; for ( int j = 0 ; j < 4 ; j ++ ) if ( j != i ) vv . push_back ( S [ j ]); sat :: AddClause ( vv ); for ( int & v : vv ) v = - v ; sat :: AddClause ( vv ); } } void exactly_two_or_none ( vector < int > & S ) { if ( S . size () == 2 ) { vector < int > v1 = { - S [ 0 ], S [ 1 ]}, v2 = { S [ 0 ], - S [ 1 ]}; sat :: AddClause ( v1 ); sat :: AddClause ( v2 ); } else if ( S . size () == 3 ) { for ( int i = 0 ; i < 3 ; i ++ ) { S [ i ] = - S [ i ]; sat :: AddClause ( S ); S [ i ] = - S [ i ]; } for ( int & i : S ) i = - i ; sat :: AddClause ( S ); } else if ( S . size () == 4 ) { for ( int i = 0 ; i < 4 ; i ++ ) { S [ i ] = - S [ i ]; sat :: AddClause ( S ); S [ i ] = - S [ i ]; } for ( int i = 0 ; i < 4 ; i ++ ) { vector < int > vv ; for ( int j = 0 ; j < 4 ; j ++ ) if ( j != i ) vv . push_back ( - S [ j ]); sat :: AddClause ( vv ); } } } bool vis [ MAXR ][ MAXC ]; stack < pii > stk ; void floodfill () { while ( ! stk . empty () ) { pii v = stk . top (); stk . pop (); int i = v . first , j = v . second ; if ( vis [ i ][ j ] ) continue ; vis [ i ][ j ] = true ; if ( i > 0 && ! is_wall [ id_h ( i , j )] ) stk . push ( pii ( i - 1 , j )); if ( i < r - 1 && ! is_wall [ id_h ( i + 1 , j )] ) stk . push ( pii ( i + 1 , j )); if ( j > 0 && ! is_wall [ id_v ( i , j )] ) stk . push ( pii ( i , j - 1 )); if ( j < c - 1 && ! is_wall [ id_v ( i , j + 1 )] ) stk . push ( pii ( i , j + 1 )); } } pii first_loop ; bool valid () { for ( int i = 0 ; i < c ; i ++ ) if ( ! is_wall [ id_h ( 0 , i )] ) stk . push ( pii ( 0 , i )); for ( int i = 0 ; i < c ; i ++ ) if ( ! is_wall [ id_h ( r , i )] ) stk . push ( pii ( r - 1 , i )); for ( int i = 1 ; i < r - 1 ; i ++ ) if ( ! is_wall [ id_v ( i , 0 )] ) stk . push ( pii ( i , 0 )); for ( int i = 1 ; i < r - 1 ; i ++ ) if ( ! is_wall [ id_v ( i , c )] ) stk . push ( pii ( i , c - 1 )); bool f = true ; for ( int i = 0 ; i < r && f ; i ++ ) for ( int j = 0 ; j < c ; j ++ ) if ( is_wall [ id_v ( i , j )] ) { stk . push ( pii ( i , j )); first_loop = pii ( i , j ); f = false ; break ; } memset ( vis , 0 , sizeof ( vis )); floodfill (); for ( int i = 0 ; i < r ; i ++ ) for ( int j = 0 ; j < c ; j ++ ) if ( ! vis [ i ][ j ] ) return false ; return true ; } void get_loop ( int i , int j , vector < int >& L ) { stk . push ( pii ( i , j )); while ( ! stk . empty () ) { pii v = stk . top (); stk . pop (); int i = v . first , j = v . second ; if ( vis [ i ][ j ] ) continue ; vis [ i ][ j ] = true ; if ( i > 0 && ! is_wall [ id_h ( i , j )] ) stk . push ( pii ( i - 1 , j )); if ( i < r - 1 && ! is_wall [ id_h ( i + 1 , j )] ) stk . push ( pii ( i + 1 , j )); if ( j > 0 && ! is_wall [ id_v ( i , j )] ) stk . push ( pii ( i , j - 1 )); if ( j < c - 1 && ! is_wall [ id_v ( i , j + 1 )] ) stk . push ( pii ( i , j + 1 )); if ( is_wall [ id_h ( i , j )] ) L . push_back ( id_h ( i , j )); if ( is_wall [ id_h ( i + 1 , j )] ) L . push_back ( id_h ( i + 1 , j )); if ( is_wall [ id_v ( i , j )] ) L . push_back ( id_v ( i , j )); if ( is_wall [ id_v ( i , j + 1 )] ) L . push_back ( id_v ( i , j + 1 )); } } int main () { IOS ; cin >> r >> c ; for ( int i = 0 ; i < r ; i ++ ) { string s ; cin >> s ; for ( int j = 0 ; j < c ; j ++ ) board [ i ][ j ] = s [ j ] - '0' ; } int nd = 2 * r * c + r + c ; sat :: Init ( nd ); for ( int i = 0 ; i < r ; i ++ ) { for ( int j = 0 ; j < c ; j ++ ) { vector < int > S = { id_h ( i , j ), id_h ( i + 1 , j ), id_v ( i , j ), id_v ( i , j + 1 )}; switch ( board [ i ][ j ] ) { case 0 : all_false ( S ); break ; case 1 : exactly_one ( S ); break ; case 2 : exactly_two ( S ); break ; case 3 : exactly_one_false ( S ); break ; } } } for ( int i = 0 ; i <= r ; i ++ ) { for ( int j = 0 ; j <= c ; j ++ ) { vector < int > v ; if ( i < r ) v . push_back ( id_v ( i , j )); if ( i > 0 ) v . push_back ( id_v ( i - 1 , j )); if ( j < c ) v . push_back ( id_h ( i , j )); if ( j > 0 ) v . push_back ( id_h ( i , j - 1 )); exactly_two_or_none ( v ); } } while ( true ) { if ( ! sat :: Solve () ) { cerr << \"cannot solve \\n \" ; exit ( 128 ); } memset ( is_wall , 0 , sizeof ( is_wall )); for ( int i = 1 ; i <= nd ; i ++ ) is_wall [ i ] = ( sat :: GetResult ( i ) == 1 ); if ( valid () ) { break ; } else { for ( int i = 0 ; i < r ; i ++ ) { for ( int j = 0 ; j < c ; j ++ ) { if ( ! vis [ i ][ j ] ) { vector < int > v ; get_loop ( i , j , v ); for ( int & i : v ) i = - i ; sat :: AddClause ( v ); } } } memset ( vis , 0 , sizeof ( vis )); vector < int > v ; get_loop ( first_loop . first , first_loop . second , v ); for ( int & i : v ) i = - i ; sat :: AddClause ( v ); } } for ( int i = 1 ; i <= nd ; i ++ ) cout << is_wall [ i ]; cout << '\\n' ; #ifdef DEBUG for ( int i = 0 ; i < r ; i ++ ) { for ( int j = 0 ; j < c ; j ++ ) cout << \"+\" << ( is_wall [ id_h ( i , j )] ? \"-\" : \" \" ); cout << \"+ \\n \" ; for ( int j = 0 ; j < c ; j ++ ) cout << ( is_wall [ id_v ( i , j )] ? \"|\" : \" \" ) << ( char )( board [ i ][ j ] + '0' ); cout << ( is_wall [ id_v ( i , c )] ? \"| \\n \" : \" \\n \" ); } for ( int j = 0 ; j < c ; j ++ ) cout << \"+\" << ( is_wall [ id_h ( r , j )] ? \"-\" : \" \" ); cout << \"+ \\n \" ; #endif return EXIT_SUCCESS ; }","title":"Code"},{"location":"courses/ada-fall-2019/hw4/reachability-coefficient/","text":"Reachability Coefficient \u00b6 Problem Description \u00b6 Yun-Nung (Vivian) Chen's website TA's Hint \u00b6 f f is known as the \u201cJaccard similarity\u201d Concept \u00b6 Min Hash (single hash function variant) Code \u00b6 #include <bits/stdc++.h> #define IOS { ios::sync_with_stdio(false); cin.tie(nullptr); } #pragma GCC optimize(\"Ofast\", \"no-stack-protector\", \"unroll-loops\") #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,sse4.2,popcnt,abm,mmx,avx,tune=native\") using namespace std ; using LL = long long ; using ULL = unsigned long long ; using pii = pair < int , int > ; inline int read_int ( int & ); inline void write_int ( LL ); constexpr int MAXN = 2e5 + 5 ; constexpr int MOD = 1e9 + 7 ; constexpr int K = 300 ; constexpr int INF = 1e9 + 7 ; constexpr int SEED = 8787 ; int N , M , Q ; vector < int > G [ MAXN ]; bool vis [ MAXN ]; int H [ MAXN ]; int hk [ MAXN ][ K + 5 ], tmp [ 2 * K + 5 ]; int unite ( int * a , int * b , int * dst ) { int * a_end = a ; while ( * a_end != INF ) ++ a_end ; int * b_end = b ; while ( * b_end != INF ) ++ b_end ; ++ a_end ; // preserve one INF int sz = set_union ( a , a_end , b , b_end , tmp ) - tmp ; memcpy ( dst , tmp , sizeof ( int ) * K ); dst [ K ] = INF ; return min ( sz - 1 , K ); } int intersect ( int * a , int * b , int * dst ) { int * a_end = a ; while ( * a_end != INF ) ++ a_end ; int * b_end = b ; while ( * b_end != INF ) ++ b_end ; ++ a_end ; ++ b_end ; int sz = set_intersection ( a , a_end , b , b_end , tmp ) - tmp ; memcpy ( dst , tmp , sizeof ( int ) * K ); return sz - 1 ; } void dfs ( int v ) { vis [ v ] = true ; hk [ v ][ 0 ] = H [ v ], hk [ v ][ 1 ] = INF ; for ( int u : G [ v ] ) { if ( ! vis [ u ] ) dfs ( u ); unite ( hk [ v ], hk [ u ], hk [ v ]); } } int main () { srand ( SEED ); read_int ( N ); read_int ( M ); read_int ( Q ); for ( int i = 0 ; i < M ; i ++ ) { int from , to ; read_int ( from ); read_int ( to ); G [ from ]. push_back ( to ); } for ( int i = 1 ; i <= N ; i ++ ) H [ i ] = i ; random_shuffle ( H + 1 , H + N + 1 ); for ( int i = 1 ; i <= N ; i ++ ) if ( ! vis [ i ] ) dfs ( i ); for ( int q = 0 ; q < Q ; q ++ ) { int x , y ; read_int ( x ); read_int ( y ); int Y [ K + 5 ]; int S = unite ( hk [ x ], hk [ y ], Y ); intersect ( hk [ x ], Y , Y ); int sz = intersect ( hk [ y ], hk [ x ], Y ); double ans = ( double ) sz / S ; printf ( \"%lf \\n \" , ans ); } return EXIT_SUCCESS ; } // input optimize inline int read_char () { constexpr int N = 1 << 20 ; static char buf [ N ]; static char * p = buf , * end = buf ; if ( p == end ) { if ( ( end = buf + fread_unlocked ( buf , 1 , N , stdin )) == buf ) return EOF ; p = buf ; } return * p ++ ; } inline int read_int ( int & x ) { static char c , neg ; while ( ( c = read_char ()) < '-' ) if ( c == EOF ) return 0 ; neg = ( c == '-' ) ? - 1 : 1 ; x = ( neg == 1 ) ? c - '0' : 0 ; while ( ( c = read_char ()) >= '0' ) x = ( x << 3 ) + ( x << 1 ) + ( c - '0' ); x *= neg ; return 1 ; } // output optimize #define _pc putchar_unlocked char _buf [ 128 ]; inline void write_int ( LL x ) { if ( ! x ) { _pc ( '0' ); _pc ( '\\n' ); return ; } int t = 0 ; while ( x ) { _buf [ t ++ ] = x % 10 + '0' ; x /= 10 ; } while ( t -- ) _pc ( _buf [ t ]); _pc ( '\\n' ); } #undef _pc","title":"Reachability Coefficient"},{"location":"courses/ada-fall-2019/hw4/reachability-coefficient/#reachability-coefficient","text":"","title":"Reachability Coefficient"},{"location":"courses/ada-fall-2019/hw4/reachability-coefficient/#problem-description","text":"Yun-Nung (Vivian) Chen's website","title":"Problem Description"},{"location":"courses/ada-fall-2019/hw4/reachability-coefficient/#tas-hint","text":"f f is known as the \u201cJaccard similarity\u201d","title":"TA's Hint"},{"location":"courses/ada-fall-2019/hw4/reachability-coefficient/#concept","text":"Min Hash (single hash function variant)","title":"Concept"},{"location":"courses/ada-fall-2019/hw4/reachability-coefficient/#code","text":"#include <bits/stdc++.h> #define IOS { ios::sync_with_stdio(false); cin.tie(nullptr); } #pragma GCC optimize(\"Ofast\", \"no-stack-protector\", \"unroll-loops\") #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,sse4.2,popcnt,abm,mmx,avx,tune=native\") using namespace std ; using LL = long long ; using ULL = unsigned long long ; using pii = pair < int , int > ; inline int read_int ( int & ); inline void write_int ( LL ); constexpr int MAXN = 2e5 + 5 ; constexpr int MOD = 1e9 + 7 ; constexpr int K = 300 ; constexpr int INF = 1e9 + 7 ; constexpr int SEED = 8787 ; int N , M , Q ; vector < int > G [ MAXN ]; bool vis [ MAXN ]; int H [ MAXN ]; int hk [ MAXN ][ K + 5 ], tmp [ 2 * K + 5 ]; int unite ( int * a , int * b , int * dst ) { int * a_end = a ; while ( * a_end != INF ) ++ a_end ; int * b_end = b ; while ( * b_end != INF ) ++ b_end ; ++ a_end ; // preserve one INF int sz = set_union ( a , a_end , b , b_end , tmp ) - tmp ; memcpy ( dst , tmp , sizeof ( int ) * K ); dst [ K ] = INF ; return min ( sz - 1 , K ); } int intersect ( int * a , int * b , int * dst ) { int * a_end = a ; while ( * a_end != INF ) ++ a_end ; int * b_end = b ; while ( * b_end != INF ) ++ b_end ; ++ a_end ; ++ b_end ; int sz = set_intersection ( a , a_end , b , b_end , tmp ) - tmp ; memcpy ( dst , tmp , sizeof ( int ) * K ); return sz - 1 ; } void dfs ( int v ) { vis [ v ] = true ; hk [ v ][ 0 ] = H [ v ], hk [ v ][ 1 ] = INF ; for ( int u : G [ v ] ) { if ( ! vis [ u ] ) dfs ( u ); unite ( hk [ v ], hk [ u ], hk [ v ]); } } int main () { srand ( SEED ); read_int ( N ); read_int ( M ); read_int ( Q ); for ( int i = 0 ; i < M ; i ++ ) { int from , to ; read_int ( from ); read_int ( to ); G [ from ]. push_back ( to ); } for ( int i = 1 ; i <= N ; i ++ ) H [ i ] = i ; random_shuffle ( H + 1 , H + N + 1 ); for ( int i = 1 ; i <= N ; i ++ ) if ( ! vis [ i ] ) dfs ( i ); for ( int q = 0 ; q < Q ; q ++ ) { int x , y ; read_int ( x ); read_int ( y ); int Y [ K + 5 ]; int S = unite ( hk [ x ], hk [ y ], Y ); intersect ( hk [ x ], Y , Y ); int sz = intersect ( hk [ y ], hk [ x ], Y ); double ans = ( double ) sz / S ; printf ( \"%lf \\n \" , ans ); } return EXIT_SUCCESS ; } // input optimize inline int read_char () { constexpr int N = 1 << 20 ; static char buf [ N ]; static char * p = buf , * end = buf ; if ( p == end ) { if ( ( end = buf + fread_unlocked ( buf , 1 , N , stdin )) == buf ) return EOF ; p = buf ; } return * p ++ ; } inline int read_int ( int & x ) { static char c , neg ; while ( ( c = read_char ()) < '-' ) if ( c == EOF ) return 0 ; neg = ( c == '-' ) ? - 1 : 1 ; x = ( neg == 1 ) ? c - '0' : 0 ; while ( ( c = read_char ()) >= '0' ) x = ( x << 3 ) + ( x << 1 ) + ( c - '0' ); x *= neg ; return 1 ; } // output optimize #define _pc putchar_unlocked char _buf [ 128 ]; inline void write_int ( LL x ) { if ( ! x ) { _pc ( '0' ); _pc ( '\\n' ); return ; } int t = 0 ; while ( x ) { _buf [ t ++ ] = x % 10 + '0' ; x /= 10 ; } while ( t -- ) _pc ( _buf [ t ]); _pc ( '\\n' ); } #undef _pc","title":"Code"},{"location":"courses/ada-fall-2019/hw4/yet-another-permutation-problem/","text":"Reachability Coefficient \u00b6 Problem Description \u00b6 Yun-Nung (Vivian) Chen's website TA's Hint \u00b6 The problem is NP-Complete. Apply fast algorithm to solve it. Concept \u00b6 Reduce to Maximum Clique Problem (consider the matrix an \"adjancy matrix\") MaxCliqueDyn Algorithm (original paper was published in 2007) Code \u00b6 #include <bits/stdc++.h> #define IOS { ios::sync_with_stdio(false); cin.tie(nullptr); } #pragma GCC optimize(\"Ofast\", \"no-stack-protector\", \"unroll-loops\") #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,sse4.2,popcnt,abm,mmx,avx,tune=native\") using namespace std ; using ll = long long ; using ULL = unsigned long long ; using pii = pair < int , int > ; struct Vertex { int id , deg ; }; constexpr int MAXN = 120 ; using bst = bitset < MAXN > ; int N ; int A [ MAXN ][ MAXN ]; bool G [ MAXN ][ MAXN ]; vector < int > sol , Q ; vector < int > C [ MAXN ]; void add_edge ( int u , int v ) { G [ u ][ v ] = G [ v ][ u ] = 1 ; } bool test ( const int e , const vector < int >& S ) { for ( int i : S ) if ( G [ i ][ e ] ) return true ; return false ; } void color_sort ( vector < Vertex >& R ) { int max_no = 1 , j = 0 ; int k_min = sol . size () - Q . size () + 1 ; C [ 1 ]. clear (); C [ 2 ]. clear (); for ( int i = 0 ; i < R . size (); i ++ ) { int p = R [ i ]. id ; int k = 1 ; while ( test ( p , C [ k ]) ) ++ k ; if ( k > max_no ) { max_no = k ; C [ max_no + 1 ]. clear (); } C [ k ]. push_back ( p ); if ( k < k_min ) { R [ j ]. id = p ; ++ j ; } } if ( j > 0 ) R [ j - 1 ]. deg = 0 ; if ( k_min <= 0 ) k_min = 1 ; for ( int k = k_min ; k <= max_no ; ++ k ) { int sz = C [ k ]. size (); for ( int i = 0 ; i < sz ; i ++ ) { R [ j ]. id = C [ k ][ i ]; R [ j ]. deg = k ; ++ j ; } } } bool deg_cmp ( const Vertex u , const Vertex v ) { return u . deg > v . deg ; } void calc_deg ( vector < Vertex >& V ) { for ( Vertex & v : V ) { v . deg = 0 ; for ( int j = 0 ; j < N ; j ++ ) v . deg += ( int ) G [ v . id ][ j ]; } } void degree_sort ( vector < Vertex >& R ) { calc_deg ( R ); sort ( R . begin (), R . end (), deg_cmp ); } int S [ MAXN ], S_old [ MAXN ], ALLSTEP ; const double T_limit = 0.025 ; void expand_dyn ( vector < Vertex >& R , int level ) { S [ level ] = S [ level ] + S [ level - 1 ] - S_old [ level ]; S_old [ level ] = S [ level - 1 ]; while ( R . size () ) { if ( Q . size () + R . back (). deg <= sol . size () ) return ; int p = R . back (). id ; R . pop_back (); Q . push_back ( p ); vector < Vertex > Rp ; for ( Vertex v : R ) if ( G [ p ][ v . id ] ) Rp . push_back ( v ); if ( Rp . size () ) { if ( ( double ) S [ level ] / ++ ALLSTEP < T_limit ) degree_sort ( Rp ); color_sort ( Rp ); ++ S [ level ]; expand_dyn ( Rp , level + 1 ); } else if ( Q . size () > sol . size () ) { sol = vector < int > ( Q ); } Q . pop_back (); } } void init_V ( vector < Vertex >& V ) { calc_deg ( V ); sort ( V . begin (), V . end (), deg_cmp ); int mx_deg = V [ 0 ]. deg ; for ( int i = 0 ; i < mx_deg ; i ++ ) V [ i ]. deg = i + 1 ; for ( int i = mx_deg ; i < N ; i ++ ) V [ i ]. deg = mx_deg + 1 ; } void MCQdyn () { ALLSTEP = 0 ; vector < Vertex > V ; for ( int i = 0 ; i < N ; i ++ ) V . push_back ({ i , 0 }); init_V ( V ); memset ( S , 0 , sizeof ( S )); memset ( S_old , 0 , sizeof ( S_old )); expand_dyn ( V , 1 ); } int main () { IOS ; cin >> N ; for ( int i = 0 ; i < N ; i ++ ) { string s ; cin >> s ; for ( int j = 0 ; j < N ; j ++ ) { A [ i ][ j ] = s [ j ] - '0' ; } } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( A [ i ][ j ] && A [ j ][ i ] && A [ i ][ i ] && A [ j ][ j ] ) add_edge ( i , j ); } } MCQdyn (); int ans = sol . size (); bool used [ MAXN ] = { 0 }; for ( int i = 0 ; i < sol . size (); i ++ ) { used [ sol [ i ]] = true ; sol [ i ] ++ ; } for ( int i = 0 ; i < N ; i ++ ) if ( ! used [ i ] ) sol . push_back ( i + 1 ); for ( int i = 0 ; i < sol . size (); i ++ ) cout << sol [ i ] << \" \\n \" [ i == sol . size () - 1 ]; #ifdef DEBUG cout << \"max clique size = \" << ans << '\\n' ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) cout << A [ sol [ i ] - 1 ][ sol [ j ] - 1 ]; cout << '\\n' ; } #endif return EXIT_SUCCESS ; }","title":"Reachability Coefficient"},{"location":"courses/ada-fall-2019/hw4/yet-another-permutation-problem/#reachability-coefficient","text":"","title":"Reachability Coefficient"},{"location":"courses/ada-fall-2019/hw4/yet-another-permutation-problem/#problem-description","text":"Yun-Nung (Vivian) Chen's website","title":"Problem Description"},{"location":"courses/ada-fall-2019/hw4/yet-another-permutation-problem/#tas-hint","text":"The problem is NP-Complete. Apply fast algorithm to solve it.","title":"TA's Hint"},{"location":"courses/ada-fall-2019/hw4/yet-another-permutation-problem/#concept","text":"Reduce to Maximum Clique Problem (consider the matrix an \"adjancy matrix\") MaxCliqueDyn Algorithm (original paper was published in 2007)","title":"Concept"},{"location":"courses/ada-fall-2019/hw4/yet-another-permutation-problem/#code","text":"#include <bits/stdc++.h> #define IOS { ios::sync_with_stdio(false); cin.tie(nullptr); } #pragma GCC optimize(\"Ofast\", \"no-stack-protector\", \"unroll-loops\") #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,sse4.2,popcnt,abm,mmx,avx,tune=native\") using namespace std ; using ll = long long ; using ULL = unsigned long long ; using pii = pair < int , int > ; struct Vertex { int id , deg ; }; constexpr int MAXN = 120 ; using bst = bitset < MAXN > ; int N ; int A [ MAXN ][ MAXN ]; bool G [ MAXN ][ MAXN ]; vector < int > sol , Q ; vector < int > C [ MAXN ]; void add_edge ( int u , int v ) { G [ u ][ v ] = G [ v ][ u ] = 1 ; } bool test ( const int e , const vector < int >& S ) { for ( int i : S ) if ( G [ i ][ e ] ) return true ; return false ; } void color_sort ( vector < Vertex >& R ) { int max_no = 1 , j = 0 ; int k_min = sol . size () - Q . size () + 1 ; C [ 1 ]. clear (); C [ 2 ]. clear (); for ( int i = 0 ; i < R . size (); i ++ ) { int p = R [ i ]. id ; int k = 1 ; while ( test ( p , C [ k ]) ) ++ k ; if ( k > max_no ) { max_no = k ; C [ max_no + 1 ]. clear (); } C [ k ]. push_back ( p ); if ( k < k_min ) { R [ j ]. id = p ; ++ j ; } } if ( j > 0 ) R [ j - 1 ]. deg = 0 ; if ( k_min <= 0 ) k_min = 1 ; for ( int k = k_min ; k <= max_no ; ++ k ) { int sz = C [ k ]. size (); for ( int i = 0 ; i < sz ; i ++ ) { R [ j ]. id = C [ k ][ i ]; R [ j ]. deg = k ; ++ j ; } } } bool deg_cmp ( const Vertex u , const Vertex v ) { return u . deg > v . deg ; } void calc_deg ( vector < Vertex >& V ) { for ( Vertex & v : V ) { v . deg = 0 ; for ( int j = 0 ; j < N ; j ++ ) v . deg += ( int ) G [ v . id ][ j ]; } } void degree_sort ( vector < Vertex >& R ) { calc_deg ( R ); sort ( R . begin (), R . end (), deg_cmp ); } int S [ MAXN ], S_old [ MAXN ], ALLSTEP ; const double T_limit = 0.025 ; void expand_dyn ( vector < Vertex >& R , int level ) { S [ level ] = S [ level ] + S [ level - 1 ] - S_old [ level ]; S_old [ level ] = S [ level - 1 ]; while ( R . size () ) { if ( Q . size () + R . back (). deg <= sol . size () ) return ; int p = R . back (). id ; R . pop_back (); Q . push_back ( p ); vector < Vertex > Rp ; for ( Vertex v : R ) if ( G [ p ][ v . id ] ) Rp . push_back ( v ); if ( Rp . size () ) { if ( ( double ) S [ level ] / ++ ALLSTEP < T_limit ) degree_sort ( Rp ); color_sort ( Rp ); ++ S [ level ]; expand_dyn ( Rp , level + 1 ); } else if ( Q . size () > sol . size () ) { sol = vector < int > ( Q ); } Q . pop_back (); } } void init_V ( vector < Vertex >& V ) { calc_deg ( V ); sort ( V . begin (), V . end (), deg_cmp ); int mx_deg = V [ 0 ]. deg ; for ( int i = 0 ; i < mx_deg ; i ++ ) V [ i ]. deg = i + 1 ; for ( int i = mx_deg ; i < N ; i ++ ) V [ i ]. deg = mx_deg + 1 ; } void MCQdyn () { ALLSTEP = 0 ; vector < Vertex > V ; for ( int i = 0 ; i < N ; i ++ ) V . push_back ({ i , 0 }); init_V ( V ); memset ( S , 0 , sizeof ( S )); memset ( S_old , 0 , sizeof ( S_old )); expand_dyn ( V , 1 ); } int main () { IOS ; cin >> N ; for ( int i = 0 ; i < N ; i ++ ) { string s ; cin >> s ; for ( int j = 0 ; j < N ; j ++ ) { A [ i ][ j ] = s [ j ] - '0' ; } } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( A [ i ][ j ] && A [ j ][ i ] && A [ i ][ i ] && A [ j ][ j ] ) add_edge ( i , j ); } } MCQdyn (); int ans = sol . size (); bool used [ MAXN ] = { 0 }; for ( int i = 0 ; i < sol . size (); i ++ ) { used [ sol [ i ]] = true ; sol [ i ] ++ ; } for ( int i = 0 ; i < N ; i ++ ) if ( ! used [ i ] ) sol . push_back ( i + 1 ); for ( int i = 0 ; i < sol . size (); i ++ ) cout << sol [ i ] << \" \\n \" [ i == sol . size () - 1 ]; #ifdef DEBUG cout << \"max clique size = \" << ans << '\\n' ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) cout << A [ sol [ i ] - 1 ][ sol [ j ] - 1 ]; cout << '\\n' ; } #endif return EXIT_SUCCESS ; }","title":"Code"},{"location":"courses/nasa-spring-2019/","text":"Network Administration and System Administration \u00b6 Homework 0 \u00b6 Homework 1 \u00b6 Homework 2 \u00b6 Homework 3 \u00b6 Homework 4 \u00b6 Homework 5 \u00b6 Homework 6 \u00b6 Homework 7 \u00b6","title":"Network Administration and System Administration"},{"location":"courses/nasa-spring-2019/#network-administration-and-system-administration","text":"","title":"Network Administration and System Administration"},{"location":"courses/nasa-spring-2019/#homework-0","text":"","title":"Homework 0"},{"location":"courses/nasa-spring-2019/#homework-1","text":"","title":"Homework 1"},{"location":"courses/nasa-spring-2019/#homework-2","text":"","title":"Homework 2"},{"location":"courses/nasa-spring-2019/#homework-3","text":"","title":"Homework 3"},{"location":"courses/nasa-spring-2019/#homework-4","text":"","title":"Homework 4"},{"location":"courses/nasa-spring-2019/#homework-5","text":"","title":"Homework 5"},{"location":"courses/nasa-spring-2019/#homework-6","text":"","title":"Homework 6"},{"location":"courses/nasa-spring-2019/#homework-7","text":"","title":"Homework 7"},{"location":"courses/nasa-spring-2019/hw0/","text":"Homework Assignment 0 \u00b6 Network Administration \u00b6 link System Administration \u00b6 link","title":"Homework Assignment 0"},{"location":"courses/nasa-spring-2019/hw0/#homework-assignment-0","text":"","title":"Homework Assignment 0"},{"location":"courses/nasa-spring-2019/hw0/#network-administration","text":"link","title":"Network Administration"},{"location":"courses/nasa-spring-2019/hw0/#system-administration","text":"link","title":"System Administration"},{"location":"courses/nasa-spring-2019/hw1/","text":"Homework Assignment 1 \u00b6 Network Administration \u00b6 link System Administration \u00b6 format_check.sh \u00b6 #! /usr/bin/env bash date_patterns =( '^[0-9]{4}-[0-9]{2}-[0-9]{2}$' '^[0-9]{4}/[0-9]{2}/[0-9]{2}$' '^[0-9]{4}\\.[0-9]{2}\\.[0-9]{2}$' ) time_patterns =( '^[0-9]{2}:[0-9]{2}$' '^[0-9]{2}:[0-9]{2}:[0-9]{2}$' ) date_is_valid = 0 time_is_valid = 0 for pattern in ${ date_patterns [@] } ; do if [ ` echo \" $1 \" | grep -cE \" $pattern \" ` -eq 1 ] ; then date_is_valid = 1 fi done for pattern in ${ time_patterns [@] } ; do if [ ` echo \" $2 \" | grep -cE \" $pattern \" ` -eq 1 ] ; then time_is_valid = 1 fi done if [ $date_is_valid ! = 0 ] && [ $time_is_valid ! = 0 ] ; then echo \" $1 $2 \" else echo \"Invalid\" fi rtt_test.sh \u00b6 #! /usr/bin/env bash output_str = '' url_list = ` cat $1 | grep '^#Server = ' | cut -d ' ' -f 3 ` for url in $url_list do ping_result = ` ping -c 3 -q \" $url \" 2 > & 1 ` #if [ `echo \"$ping_result\" | grep -E -c \"not known|Unknown host|100% packet loss\"` == '0' ] if [ $? -eq 0 ] then rtt = ` echo \" $ping_result \" | grep rtt | cut -d ' ' -f 4 | cut -d '/' -f 2 ` output_str = \" $output_str$url $rtt \\n\" fi done printf \" ${ output_str } \" | sort -g -k 2 csie_analytics.sh \u00b6 #! /usr/bin/env bash N = 10 usage () { echo \"Usage: csie_analytics.sh [-n count] [filename]:\" } if [ $# -eq 0 ] ; then usage # lack file name exit 5 fi if [ \" $1 \" == \"-n\" ] ; then if [ $# -eq 2 ] ; then if [ -f \" $2 \" ] ; then # example: ./csie_analytics.sh -n log.txt echo \"Error: option requires an argument.\" exit 1 else # example: ./csie_analytics.sh -n 8 usage exit 5 fi elif [ ` echo \" $2 \" | grep -c \"^[1-9][0-9]* $ \" ` -eq 0 ] ; then # example: ./csie_analytics.sh -n 11.7 log.txt echo \"Error: line number must be positive integer.\" exit 2 else # correct: ./csie_analytics -n 42 log.txt FILENAME = $3 N = $2 fi elif [ ` echo \" $1 \" | grep -c -- '-.*' ` -ne 0 ] || [ $# -gt 1 ] ; then # example: ./csie_analytics.sh -q ... || ./csie_analytics.sh log.txt -n 999 usage # Other arguments error exit 3 else FILENAME = \" $1 \" # correct or file not exists fi if [ ! -f \" $FILENAME \" ] ; then echo \"Error: log file does not exist.\" exit 4 fi data = ` cat $FILENAME | cut -d ' ' -f 5 | sed 's/?[^ ]*//g' | sort | uniq -c | sort -gr -k 1 ` sum = ` cat \" $FILENAME \" | wc -l ` echo \" $data \" | head -n $N | awk -v sum = \" $sum \" 'BEGIN{printf \"%-35s %-10s %s\\n\", \"Path\", \"Times\", \"Percentage\"} {percentage = $1 / sum * 100; printf \"%-35s %-10s %-2.2f%%\\n\", $2, $1, percentage}'","title":"Homework Assignment 1"},{"location":"courses/nasa-spring-2019/hw1/#homework-assignment-1","text":"","title":"Homework Assignment 1"},{"location":"courses/nasa-spring-2019/hw1/#network-administration","text":"link","title":"Network Administration"},{"location":"courses/nasa-spring-2019/hw1/#system-administration","text":"","title":"System Administration"},{"location":"courses/nasa-spring-2019/hw1/#format_checksh","text":"#! /usr/bin/env bash date_patterns =( '^[0-9]{4}-[0-9]{2}-[0-9]{2}$' '^[0-9]{4}/[0-9]{2}/[0-9]{2}$' '^[0-9]{4}\\.[0-9]{2}\\.[0-9]{2}$' ) time_patterns =( '^[0-9]{2}:[0-9]{2}$' '^[0-9]{2}:[0-9]{2}:[0-9]{2}$' ) date_is_valid = 0 time_is_valid = 0 for pattern in ${ date_patterns [@] } ; do if [ ` echo \" $1 \" | grep -cE \" $pattern \" ` -eq 1 ] ; then date_is_valid = 1 fi done for pattern in ${ time_patterns [@] } ; do if [ ` echo \" $2 \" | grep -cE \" $pattern \" ` -eq 1 ] ; then time_is_valid = 1 fi done if [ $date_is_valid ! = 0 ] && [ $time_is_valid ! = 0 ] ; then echo \" $1 $2 \" else echo \"Invalid\" fi","title":"format_check.sh"},{"location":"courses/nasa-spring-2019/hw1/#rtt_testsh","text":"#! /usr/bin/env bash output_str = '' url_list = ` cat $1 | grep '^#Server = ' | cut -d ' ' -f 3 ` for url in $url_list do ping_result = ` ping -c 3 -q \" $url \" 2 > & 1 ` #if [ `echo \"$ping_result\" | grep -E -c \"not known|Unknown host|100% packet loss\"` == '0' ] if [ $? -eq 0 ] then rtt = ` echo \" $ping_result \" | grep rtt | cut -d ' ' -f 4 | cut -d '/' -f 2 ` output_str = \" $output_str$url $rtt \\n\" fi done printf \" ${ output_str } \" | sort -g -k 2","title":"rtt_test.sh"},{"location":"courses/nasa-spring-2019/hw1/#csie_analyticssh","text":"#! /usr/bin/env bash N = 10 usage () { echo \"Usage: csie_analytics.sh [-n count] [filename]:\" } if [ $# -eq 0 ] ; then usage # lack file name exit 5 fi if [ \" $1 \" == \"-n\" ] ; then if [ $# -eq 2 ] ; then if [ -f \" $2 \" ] ; then # example: ./csie_analytics.sh -n log.txt echo \"Error: option requires an argument.\" exit 1 else # example: ./csie_analytics.sh -n 8 usage exit 5 fi elif [ ` echo \" $2 \" | grep -c \"^[1-9][0-9]* $ \" ` -eq 0 ] ; then # example: ./csie_analytics.sh -n 11.7 log.txt echo \"Error: line number must be positive integer.\" exit 2 else # correct: ./csie_analytics -n 42 log.txt FILENAME = $3 N = $2 fi elif [ ` echo \" $1 \" | grep -c -- '-.*' ` -ne 0 ] || [ $# -gt 1 ] ; then # example: ./csie_analytics.sh -q ... || ./csie_analytics.sh log.txt -n 999 usage # Other arguments error exit 3 else FILENAME = \" $1 \" # correct or file not exists fi if [ ! -f \" $FILENAME \" ] ; then echo \"Error: log file does not exist.\" exit 4 fi data = ` cat $FILENAME | cut -d ' ' -f 5 | sed 's/?[^ ]*//g' | sort | uniq -c | sort -gr -k 1 ` sum = ` cat \" $FILENAME \" | wc -l ` echo \" $data \" | head -n $N | awk -v sum = \" $sum \" 'BEGIN{printf \"%-35s %-10s %s\\n\", \"Path\", \"Times\", \"Percentage\"} {percentage = $1 / sum * 100; printf \"%-35s %-10s %-2.2f%%\\n\", $2, $1, percentage}'","title":"csie_analytics.sh"},{"location":"courses/nasa-spring-2019/hw2/","text":"Homework Assignment 2 \u00b6 link","title":"Homework Assignment 2"},{"location":"courses/nasa-spring-2019/hw2/#homework-assignment-2","text":"link","title":"Homework Assignment 2"},{"location":"courses/nasa-spring-2019/hw3/","text":"Homework Assignment 3 \u00b6 link","title":"Homework Assignment 3"},{"location":"courses/nasa-spring-2019/hw3/#homework-assignment-3","text":"link","title":"Homework Assignment 3"},{"location":"courses/nasa-spring-2019/hw4/","text":"Homework Assignment 4 \u00b6 link","title":"Homework Assignment 4"},{"location":"courses/nasa-spring-2019/hw4/#homework-assignment-4","text":"link","title":"Homework Assignment 4"},{"location":"courses/nasa-spring-2019/hw5/","text":"Homework Assignment 5 \u00b6 link","title":"Homework Assignment 5"},{"location":"courses/nasa-spring-2019/hw5/#homework-assignment-5","text":"link","title":"Homework Assignment 5"},{"location":"courses/nasa-spring-2019/hw6/","text":"Homework Assignment 6 \u00b6 link","title":"Homework Assignment 6"},{"location":"courses/nasa-spring-2019/hw6/#homework-assignment-6","text":"link","title":"Homework Assignment 6"},{"location":"courses/nasa-spring-2019/hw7/","text":"Homework Assignment 7 \u00b6 link","title":"Homework Assignment 7"},{"location":"courses/nasa-spring-2019/hw7/#homework-assignment-7","text":"link","title":"Homework Assignment 7"},{"location":"courses/sp-fall-2019/","text":"System Programming \u00b6 Instructor: Pu-Jen Cheng \u912d\u535c\u58ec Programming Assignments \u00b6 topics: I/O multiplexing advisory file lock description: Given a simple server, you have to modify it to a banking system supporting I/O Multiplexing and content protection my implementation topics: multi-processing and handling zombie processes Inter process communication by pipe and FIFO description: Implement a bidding system which will handle a sequence of competitions. The goal of this assignment is to practice how to communicate between processes through pipe and FIFO , and to understand how to use fork() to create processes. my implementation topics: signal handling non-local jump ( setjmp() , longjmp() ) description: Simulate a user-thread library by using longjmp() , setjmp() , and implement a scheduler to control the action of these threads. Additionally, signals are used to send instructions to the scheduler, and signal mask is applied to handle the timing of the delivery of signals . my implementation topics: multi-threading pthread library description: implement a multiclass classifier with thread. You should train a model to classify handwritten digits from MNIST dataset. And the most important part is that you have to accelerate the matrix multiplication (let it parallelly) by thread. my implementation Hand-written Assignments \u00b6 Assignment 1 Assignment 4 Assignment 5 Assignment 7","title":"System Programming"},{"location":"courses/sp-fall-2019/#system-programming","text":"Instructor: Pu-Jen Cheng \u912d\u535c\u58ec","title":"System Programming"},{"location":"courses/sp-fall-2019/#programming-assignments","text":"topics: I/O multiplexing advisory file lock description: Given a simple server, you have to modify it to a banking system supporting I/O Multiplexing and content protection my implementation topics: multi-processing and handling zombie processes Inter process communication by pipe and FIFO description: Implement a bidding system which will handle a sequence of competitions. The goal of this assignment is to practice how to communicate between processes through pipe and FIFO , and to understand how to use fork() to create processes. my implementation topics: signal handling non-local jump ( setjmp() , longjmp() ) description: Simulate a user-thread library by using longjmp() , setjmp() , and implement a scheduler to control the action of these threads. Additionally, signals are used to send instructions to the scheduler, and signal mask is applied to handle the timing of the delivery of signals . my implementation topics: multi-threading pthread library description: implement a multiclass classifier with thread. You should train a model to classify handwritten digits from MNIST dataset. And the most important part is that you have to accelerate the matrix multiplication (let it parallelly) by thread. my implementation","title":"Programming Assignments"},{"location":"courses/sp-fall-2019/#hand-written-assignments","text":"Assignment 1 Assignment 4 Assignment 5 Assignment 7","title":"Hand-written Assignments"},{"location":"courses/sp-fall-2019/hand-written/hw1/","text":"Assignment 1 \u00b6 1. File Redirection \u00b6 Please give the meaning of the command: ./a.out < infile 2 > & 1 > outfile my answer Redirect a.out's standard input to read from the file named infile. Redirect a.out's standard input to read from the file named infile. Redirect a.out's standard output to write to the file named outfile. Please use dup() or dup2() to do the redirections of the command ./a.out < infile 2 > & 1 > outfile in the following program fragment. Error checking could be ignored. int main ( int argc , char * argv []) { int fd1 , fd2 ; fd1 = open ( infile , O_RDONLY ); fd2 = open ( outfile , O_WRONLY | O_CREAT , 0666 ); // redirect standard input to infile dup2 ( fd1 , 0 ); // redirect standard error to standard output dup2 ( 1 , 2 ); // redirect standard output to outfile dup2 ( fd2 , 1 ); execlp ( \"./a.out\" , \"./a.out\" , ( char * ) 0 ); return 0 ; } 2. Atomic operation \u00b6 To randomly write a file, a student develops two functions write_to_fd() and write_to_fn() by which users can write data to a given position in the file. The only difference between the two functions is the first parameter. One accepts a file descriptor while the other accepts a file name. Here are the two functions. ssize_t write_to_fd ( int fd , void * buf , size_t nbytes , off_t offset ) { if ( lseek ( fd , offset , SEEK_SET ) < 0 ) return - 1 ; return ( write ( fd , buf , nbytes ) ); } ssize_t write_to_fn ( char * filename , void * buf , size_t nbytes , off_t offset ) { int fd ; ssize_t retval ; if ( ( fd = open ( filename , O_WRONLY )) < 0 ) return - 1 ; if ( lseek ( fd , offset , SEEK_SET ) < 0 ) return - 1 ; retval = write ( fd , buf , nbytes ); close ( fd ); return retval ; } (a) Should the write_to_fd() function be an atomic operation? Please give an example to clearly explain your answer. my answer Yes, function write_to_fd should be an atomic operation. Since the function accepts a file descriptor, the file is opened before the function is called. If the process fork a child process after opening the file and before calling this function, then there exists another process that inherits the descriptor table, whose fd is pointed to the same file table which containing the current file offset. Between the time the parent process calls lseek(fd, offset, SEEK_SET) and write(fd, buf, nbytes) , if the CPU context switch to that child process and it calls lseek(fd, 0, SEEK_SET) or read(fd, &x, 1) , i.e. anything that changes the current file offset, then after the CPU context switch back to parent process, the current file offset is not at the specified offset and thus it write to wrong position when calling write(fd, buf, nbytes) . Thus, we should make write_to_fd be an atomic operation to prevent it from misbehaving. (b) Should the write_to_fn() function be an atomic operation? Please give an example to clearly explain your answer. my answer No, function write_to_fn is not necessarily be an atomic operation. Every time this function is called, it use open function to create a brand new open file table entry and file table, which have its own current file offset. Though there might be another process write to the same file between lseek and write , the function will definitely write to the requested offset, no matter what contents are overwritten.","title":"Assignment 1"},{"location":"courses/sp-fall-2019/hand-written/hw1/#assignment-1","text":"","title":"Assignment 1"},{"location":"courses/sp-fall-2019/hand-written/hw1/#1-file-redirection","text":"Please give the meaning of the command: ./a.out < infile 2 > & 1 > outfile my answer Redirect a.out's standard input to read from the file named infile. Redirect a.out's standard input to read from the file named infile. Redirect a.out's standard output to write to the file named outfile. Please use dup() or dup2() to do the redirections of the command ./a.out < infile 2 > & 1 > outfile in the following program fragment. Error checking could be ignored. int main ( int argc , char * argv []) { int fd1 , fd2 ; fd1 = open ( infile , O_RDONLY ); fd2 = open ( outfile , O_WRONLY | O_CREAT , 0666 ); // redirect standard input to infile dup2 ( fd1 , 0 ); // redirect standard error to standard output dup2 ( 1 , 2 ); // redirect standard output to outfile dup2 ( fd2 , 1 ); execlp ( \"./a.out\" , \"./a.out\" , ( char * ) 0 ); return 0 ; }","title":"1. File Redirection"},{"location":"courses/sp-fall-2019/hand-written/hw1/#2-atomic-operation","text":"To randomly write a file, a student develops two functions write_to_fd() and write_to_fn() by which users can write data to a given position in the file. The only difference between the two functions is the first parameter. One accepts a file descriptor while the other accepts a file name. Here are the two functions. ssize_t write_to_fd ( int fd , void * buf , size_t nbytes , off_t offset ) { if ( lseek ( fd , offset , SEEK_SET ) < 0 ) return - 1 ; return ( write ( fd , buf , nbytes ) ); } ssize_t write_to_fn ( char * filename , void * buf , size_t nbytes , off_t offset ) { int fd ; ssize_t retval ; if ( ( fd = open ( filename , O_WRONLY )) < 0 ) return - 1 ; if ( lseek ( fd , offset , SEEK_SET ) < 0 ) return - 1 ; retval = write ( fd , buf , nbytes ); close ( fd ); return retval ; } (a) Should the write_to_fd() function be an atomic operation? Please give an example to clearly explain your answer. my answer Yes, function write_to_fd should be an atomic operation. Since the function accepts a file descriptor, the file is opened before the function is called. If the process fork a child process after opening the file and before calling this function, then there exists another process that inherits the descriptor table, whose fd is pointed to the same file table which containing the current file offset. Between the time the parent process calls lseek(fd, offset, SEEK_SET) and write(fd, buf, nbytes) , if the CPU context switch to that child process and it calls lseek(fd, 0, SEEK_SET) or read(fd, &x, 1) , i.e. anything that changes the current file offset, then after the CPU context switch back to parent process, the current file offset is not at the specified offset and thus it write to wrong position when calling write(fd, buf, nbytes) . Thus, we should make write_to_fd be an atomic operation to prevent it from misbehaving. (b) Should the write_to_fn() function be an atomic operation? Please give an example to clearly explain your answer. my answer No, function write_to_fn is not necessarily be an atomic operation. Every time this function is called, it use open function to create a brand new open file table entry and file table, which have its own current file offset. Though there might be another process write to the same file between lseek and write , the function will definitely write to the requested offset, no matter what contents are overwritten.","title":"2. Atomic operation"},{"location":"courses/sp-fall-2019/hand-written/hw2/","text":"Assignment 1 \u00b6 Double Fork \u00b6 Double fork is a common solution to the problem: the parent doesn\u2019t need to wait for the child to complete and the child doesn\u2019t become a zombie. Give two reasons to explain why UNIX-like systems need zombie processes. my answer Without zombie processes, parent may not be able to know the the termination status of its child processes if they terminate before the parent wait for them. With zombie processes, parent can fetch its child\u2019s termination status no matter when the child processes die. Without zombie state, the relationship between parent and children may miss. For example, a parent process can end up trying to wait for the return code of another process\u2019s child. How does the copy-on-write technique improve the efficiency of fork()? my answer Because fork() make the child have a independent memory space containing the same data as its parent at the time of fork() . However, the child may not change some of the memory and just read it or ignore it, which makes it unnecessary to make new copy of it. copy-on-write means the system only copys those which are modified by child process, and thus saves the time to copy the other data. Please implement function double_fork() with the prototype: pid_t double_fork () Your code should follow the rules: Call both fork() and vfork(). Each is invoked exactly once. Do not call fork() twice. Return 0 in the child. Return the process ID of the grandchild in the parent. Use a pipe and unbuffered I/O in blocking mode to avoid a race condition. Cannot produce any zombie processes. Close all of the unused file descriptors. The errors returned from system calls can be ignored. pid_t double_fork () { pid_t pid_child , pid_grandchild ; int pfd [ 2 ]; pipe ( pfd ); pid_child = vfork (); if ( pid_child == 0 ) { pid_grandchild = fork (); if ( pid_grandchild == 0 ) { // grandchild // close unused fd close ( pfd [ 1 ]); // read message from parent to ensure child (grandchild's parent) is dead char msg [ 128 ]; read ( pfd [ 0 ], msg , 128 ); close ( pfd [ 0 ]); /* do stuff */ return 0 ; } else { // child _exit ( 0 ); } } else { // parent // close unused fd close ( pfd [ 0 ]); // wait child process waitpid ( pid_child , NULL , 0 ); // tell grandchild that child is dead char * msg = \"The child is dead!\" ; write ( pfd [ 1 ], msg , strlen ( msg )); close ( pfd [ 1 ]); // because vfork() make the child process share // the same memory space, the parent's variable // also has the pid of the grandchild return pid_grandchild ; } }","title":"Assignment 1"},{"location":"courses/sp-fall-2019/hand-written/hw2/#assignment-1","text":"","title":"Assignment 1"},{"location":"courses/sp-fall-2019/hand-written/hw2/#double-fork","text":"Double fork is a common solution to the problem: the parent doesn\u2019t need to wait for the child to complete and the child doesn\u2019t become a zombie. Give two reasons to explain why UNIX-like systems need zombie processes. my answer Without zombie processes, parent may not be able to know the the termination status of its child processes if they terminate before the parent wait for them. With zombie processes, parent can fetch its child\u2019s termination status no matter when the child processes die. Without zombie state, the relationship between parent and children may miss. For example, a parent process can end up trying to wait for the return code of another process\u2019s child. How does the copy-on-write technique improve the efficiency of fork()? my answer Because fork() make the child have a independent memory space containing the same data as its parent at the time of fork() . However, the child may not change some of the memory and just read it or ignore it, which makes it unnecessary to make new copy of it. copy-on-write means the system only copys those which are modified by child process, and thus saves the time to copy the other data. Please implement function double_fork() with the prototype: pid_t double_fork () Your code should follow the rules: Call both fork() and vfork(). Each is invoked exactly once. Do not call fork() twice. Return 0 in the child. Return the process ID of the grandchild in the parent. Use a pipe and unbuffered I/O in blocking mode to avoid a race condition. Cannot produce any zombie processes. Close all of the unused file descriptors. The errors returned from system calls can be ignored. pid_t double_fork () { pid_t pid_child , pid_grandchild ; int pfd [ 2 ]; pipe ( pfd ); pid_child = vfork (); if ( pid_child == 0 ) { pid_grandchild = fork (); if ( pid_grandchild == 0 ) { // grandchild // close unused fd close ( pfd [ 1 ]); // read message from parent to ensure child (grandchild's parent) is dead char msg [ 128 ]; read ( pfd [ 0 ], msg , 128 ); close ( pfd [ 0 ]); /* do stuff */ return 0 ; } else { // child _exit ( 0 ); } } else { // parent // close unused fd close ( pfd [ 0 ]); // wait child process waitpid ( pid_child , NULL , 0 ); // tell grandchild that child is dead char * msg = \"The child is dead!\" ; write ( pfd [ 1 ], msg , strlen ( msg )); close ( pfd [ 1 ]); // because vfork() make the child process share // the same memory space, the parent's variable // also has the pid of the grandchild return pid_grandchild ; } }","title":"Double Fork"},{"location":"courses/sp-fall-2019/hand-written/hw3/","text":"Assignment 5 \u00b6 Signal \u00b6 In the following code, the child sends 10 signals to its parent and then the parent counts the total number. What's the output of the parent? Explain your answer. if fork() is replaced with vfork(), is your answer still the same? Why? int count = 0 ; void handler ( int sig ) { count ++ ; return ; } int main () { int i , status ; signal ( SIGUSR1 , handler ); if ( fork () == 0 ) { for ( i = 0 ; i < 10 ; i ++ ) kill ( getppid (), SIGUSR1 ); exit ( 0 ); } wait ( & status ); printf ( \"Got %d signals \\n \" , count ); } My Answer \u00b6 \u5047\u8a2d \uff1a\u5728\u57f7\u884csignal handler\u4e4b\u5f8c\u8a72handler\u4e0d\u6703\u88abreset\u6210default action\u3002 count\u53ef\u80fd\u662f1\u523010\u7684\u4efb\u4f55\u4e00\u500b\u6578\u5b57\u3002 \u56e0\u70ba\u82e5\u6211\u5011\u4f7f\u7528 fork(),\u4fbf\u6709\u53ef\u80fd\u5728child\u548cparent\u4e4b\u9593context switch\u3002\u7531\u65bc\u7576parent\u4e0d\u5728CPU\u57f7\u884c\u6642\uff0csignal\u6703\u88abgenerate\u4f46\u4e0d\u6703\u88abdeliver\uff0c\u7cfb\u7d71\u6703\u5c07process table\u4e2d\u7684\u4e00\u500bflag on\u8d77\u4f86\u8868\u793a\u9019\u500bsignal\u662f\u5728pending\u7684\u72c0\u614b\u3002\u6240\u4ee5\u82e5\u662f\u5728\u9019\u6642\u91cd\u8907generate\u8a72signal\uff0c\u5728deliver\u6642\u4e5f\u9084\u662f\u53ea\u6703\u6709\u4e00\u6b21(\u56e0\u70baflag\u53ea\u6709on/off\u5169\u7a2e\u72c0\u614b\uff09\u3002\u56e0\u6b64\uff0cchild\u9001\u7d66parent\u768410\u6b21SIG_USR1\u53ef\u80fd\u6703\u6709\u6578\u6b21\u662f\u9019\u7a2e\u60c5\u6cc1\uff0c\u5728\u6975\u7aef\u60c5\u6cc1\u4e0b\uff0cchild\u53ef\u80fd\u9001\u5b8c10\u6b21\u5f8c\u624dcontext switch\u5230parent\uff0c\u5982\u6b64parent\u5c31\u53ea\u6703\u88abdeliver\u4e00\u6b21SIG_USR1\uff0c\u6700\u7d42count\u70ba1\u3002\u6216\u8005child\u6bcf\u9001\u4e00\u6b21SIG_USR1\uff0c\u5c31context switch\u5230parent\u53bb\u57f7\u884csignal handler\uff0c\u518d\u56de\u5230child\u9001\u4e0b\u4e00\u6b21signal\uff0c\u9019\u6a23\u5c31\u6703\u670910\u6b21deliver\uff0c\u5247count\u70ba10\u3002 \u9644\u8a3b \uff1a\u82e5\u8a72\u7cfb\u7d71\u5728\u6bcf\u6b21signal handler\u57f7\u884c\u5b8c\u5f8c\u4fbf\u6703\u5c07\u8a72signal\u7684action\u91cd\u8a2d\u6210default action\uff0c\u5247handler()\u6700\u591a\u57f7\u884c\u4e00\u6b21\uff0c\u4e14\u56e0\u70baSIG_USR1\u7684default action\u662fterminate\uff0c\u6240\u4ee5\u82e5SIG_USR1\u767c\u751f\u7b2c\u4e8c\u6b21deliver\uff0cparent process\u4fbf\u6703\u88ab\u5f37\u5236\u7d50\u675f\uff0c\u800c\u4e0d\u6703print \"Got ? signals\"\u3002 \u4e0d\uff0c\u548c(a)\u4e0d\u540c\uff0ccount\u6c38\u9060\u662f1\u3002 \u56e0vfork()\u6703suspend parent process\u76f4\u5230child process return\u3002\u6240\u4ee5child\u6703\u5b8c\u6574\u9001\u5b8c10\u6b21SIG_USR1\u624d\u6703\u56de\u5230parent\uff0c\u7531\u65bc\u7cfb\u7d71\u8655\u7406pending signal\u7684\u6a5f\u5236\u662f\u628aprocess table\u4e2d\u7684flag on\u6216off\uff0c\u6240\u4ee5\u5c31\u7b97\u9001\u4e8610\u6b21\uff0c\u5c0d\u7cfb\u7d71\u4f86\u8aaa\u6700\u5f8c\u90fd\u662f\u4e00\u500bon\u7684\u72c0\u614b\u800c\u5df2\uff0c\u5728\u56de\u5230parent\u6642\u53ea\u6703deliver\u4e00\u6b21\u5c31\u7d50\u675f\u4e86\u3002\u6240\u4ee5 handle()\u53ea\u6703\u57f7\u884c\u4e00\u6b21\uff0c\u6545count\u6700\u7d42\u5fc5\u70ba1\u3002","title":"Assignment 5"},{"location":"courses/sp-fall-2019/hand-written/hw3/#assignment-5","text":"","title":"Assignment 5"},{"location":"courses/sp-fall-2019/hand-written/hw3/#signal","text":"In the following code, the child sends 10 signals to its parent and then the parent counts the total number. What's the output of the parent? Explain your answer. if fork() is replaced with vfork(), is your answer still the same? Why? int count = 0 ; void handler ( int sig ) { count ++ ; return ; } int main () { int i , status ; signal ( SIGUSR1 , handler ); if ( fork () == 0 ) { for ( i = 0 ; i < 10 ; i ++ ) kill ( getppid (), SIGUSR1 ); exit ( 0 ); } wait ( & status ); printf ( \"Got %d signals \\n \" , count ); }","title":"Signal"},{"location":"courses/sp-fall-2019/hand-written/hw3/#my-answer","text":"\u5047\u8a2d \uff1a\u5728\u57f7\u884csignal handler\u4e4b\u5f8c\u8a72handler\u4e0d\u6703\u88abreset\u6210default action\u3002 count\u53ef\u80fd\u662f1\u523010\u7684\u4efb\u4f55\u4e00\u500b\u6578\u5b57\u3002 \u56e0\u70ba\u82e5\u6211\u5011\u4f7f\u7528 fork(),\u4fbf\u6709\u53ef\u80fd\u5728child\u548cparent\u4e4b\u9593context switch\u3002\u7531\u65bc\u7576parent\u4e0d\u5728CPU\u57f7\u884c\u6642\uff0csignal\u6703\u88abgenerate\u4f46\u4e0d\u6703\u88abdeliver\uff0c\u7cfb\u7d71\u6703\u5c07process table\u4e2d\u7684\u4e00\u500bflag on\u8d77\u4f86\u8868\u793a\u9019\u500bsignal\u662f\u5728pending\u7684\u72c0\u614b\u3002\u6240\u4ee5\u82e5\u662f\u5728\u9019\u6642\u91cd\u8907generate\u8a72signal\uff0c\u5728deliver\u6642\u4e5f\u9084\u662f\u53ea\u6703\u6709\u4e00\u6b21(\u56e0\u70baflag\u53ea\u6709on/off\u5169\u7a2e\u72c0\u614b\uff09\u3002\u56e0\u6b64\uff0cchild\u9001\u7d66parent\u768410\u6b21SIG_USR1\u53ef\u80fd\u6703\u6709\u6578\u6b21\u662f\u9019\u7a2e\u60c5\u6cc1\uff0c\u5728\u6975\u7aef\u60c5\u6cc1\u4e0b\uff0cchild\u53ef\u80fd\u9001\u5b8c10\u6b21\u5f8c\u624dcontext switch\u5230parent\uff0c\u5982\u6b64parent\u5c31\u53ea\u6703\u88abdeliver\u4e00\u6b21SIG_USR1\uff0c\u6700\u7d42count\u70ba1\u3002\u6216\u8005child\u6bcf\u9001\u4e00\u6b21SIG_USR1\uff0c\u5c31context switch\u5230parent\u53bb\u57f7\u884csignal handler\uff0c\u518d\u56de\u5230child\u9001\u4e0b\u4e00\u6b21signal\uff0c\u9019\u6a23\u5c31\u6703\u670910\u6b21deliver\uff0c\u5247count\u70ba10\u3002 \u9644\u8a3b \uff1a\u82e5\u8a72\u7cfb\u7d71\u5728\u6bcf\u6b21signal handler\u57f7\u884c\u5b8c\u5f8c\u4fbf\u6703\u5c07\u8a72signal\u7684action\u91cd\u8a2d\u6210default action\uff0c\u5247handler()\u6700\u591a\u57f7\u884c\u4e00\u6b21\uff0c\u4e14\u56e0\u70baSIG_USR1\u7684default action\u662fterminate\uff0c\u6240\u4ee5\u82e5SIG_USR1\u767c\u751f\u7b2c\u4e8c\u6b21deliver\uff0cparent process\u4fbf\u6703\u88ab\u5f37\u5236\u7d50\u675f\uff0c\u800c\u4e0d\u6703print \"Got ? signals\"\u3002 \u4e0d\uff0c\u548c(a)\u4e0d\u540c\uff0ccount\u6c38\u9060\u662f1\u3002 \u56e0vfork()\u6703suspend parent process\u76f4\u5230child process return\u3002\u6240\u4ee5child\u6703\u5b8c\u6574\u9001\u5b8c10\u6b21SIG_USR1\u624d\u6703\u56de\u5230parent\uff0c\u7531\u65bc\u7cfb\u7d71\u8655\u7406pending signal\u7684\u6a5f\u5236\u662f\u628aprocess table\u4e2d\u7684flag on\u6216off\uff0c\u6240\u4ee5\u5c31\u7b97\u9001\u4e8610\u6b21\uff0c\u5c0d\u7cfb\u7d71\u4f86\u8aaa\u6700\u5f8c\u90fd\u662f\u4e00\u500bon\u7684\u72c0\u614b\u800c\u5df2\uff0c\u5728\u56de\u5230parent\u6642\u53ea\u6703deliver\u4e00\u6b21\u5c31\u7d50\u675f\u4e86\u3002\u6240\u4ee5 handle()\u53ea\u6703\u57f7\u884c\u4e00\u6b21\uff0c\u6545count\u6700\u7d42\u5fc5\u70ba1\u3002","title":"My Answer"},{"location":"courses/sp-fall-2019/hand-written/hw4/","text":"Assignment 7 \u00b6 Signals \u00b6 Please answer the questions according the following program and assumptions: A blocked signal will be delivered immediately when unblocked. If several signals are ready to be delivered at the same time, they will be delivered in the same order of generation. If a blocked signal is generated several times, it will be delivered only once when unblocked. void catchit ( int signo ) { // Line C } int main () { pid_t pid ; sigset_t newmask , waitmask , oldmask ; if ( ( pid = fork ()) == 0 ) { struct sigaction action ; sigemptyset ( & newmask ); sigemptyset ( & waitmask ); sigaddset ( & newmask , SIGUSR1 ); sigaddset ( & waitmask , SIGUSR2 ); sigprocmask ( SIG_BLOCK , & newmask , & oldmask ); action . sa_flags = 0 ; sigemptyset ( & action . sa_mask ); action . sa_handler = catchit ; sigaction ( SIGUSR2 , & action , NULL ); sigaction ( SIGINT , & action , NULL ); sigaddset ( & action . sa_mask , SIGINT ); sigaction ( SIGUSR1 , & action , NULL ); // Line A: critical section sigsuspend ( & waitmask ); // Line B } else { int stat ; kill ( pid , SIGUSR1 ); kill ( pid , SIGUSR2 ); kill ( pid , SIGINT ); pid = wait ( & stat ); } _exit ( 0 ); } (1) Suppose the child process receives SIGUSR2 at line A, SIGINT when blocked at line B, and SIGUSR1 when SIGINT is caught at line C. How does the child process' signal mask change \\begin{array}[rl]x \\xrightarrow{\\text{the program start}} &\\ \\text{empty} \\\\[2ex] \\xrightarrow{\\text{block SIGUSR1 by sigprocmask}} &\\ \\texttt{SIGUSR1} \\\\[2ex] \\xrightarrow{\\text{SIGUSR2 delivered at line A}} &\\ \\texttt{SIGUSR1 + SIGUSR2} \\\\[2ex] \\xrightarrow{\\text{return to main}} &\\ \\texttt{SIGUSR1} \\\\[2ex] \\xrightarrow{\\text{sigsuspend (change to waitmask)}} &\\ \\texttt{SIGUSR2} \\\\[2ex] \\xrightarrow{\\text{SIGINT delivered in sigsuspend}} &\\ \\texttt{SIGUSR2 + SIGINT} \\\\[2ex] \\xrightarrow{\\text{SIGUSR1 delivered in the handler of SIGINT}} &\\ \\texttt{SIGUSR1 + SIGUSR2 + SIGINT} \\\\[2ex] \\xrightarrow{\\text{return to the handler of SIGINT}} &\\ \\texttt{SIGUSR2 + SIGINT} \\\\[2ex] \\xrightarrow{\\text{return to main}} &\\ \\texttt{SIGUSR1}\\\\[2ex] \\end{array} \\\\ \\begin{array}[rl]x \\xrightarrow{\\text{the program start}} &\\ \\text{empty} \\\\[2ex] \\xrightarrow{\\text{block SIGUSR1 by sigprocmask}} &\\ \\texttt{SIGUSR1} \\\\[2ex] \\xrightarrow{\\text{SIGUSR2 delivered at line A}} &\\ \\texttt{SIGUSR1 + SIGUSR2} \\\\[2ex] \\xrightarrow{\\text{return to main}} &\\ \\texttt{SIGUSR1} \\\\[2ex] \\xrightarrow{\\text{sigsuspend (change to waitmask)}} &\\ \\texttt{SIGUSR2} \\\\[2ex] \\xrightarrow{\\text{SIGINT delivered in sigsuspend}} &\\ \\texttt{SIGUSR2 + SIGINT} \\\\[2ex] \\xrightarrow{\\text{SIGUSR1 delivered in the handler of SIGINT}} &\\ \\texttt{SIGUSR1 + SIGUSR2 + SIGINT} \\\\[2ex] \\xrightarrow{\\text{return to the handler of SIGINT}} &\\ \\texttt{SIGUSR2 + SIGINT} \\\\[2ex] \\xrightarrow{\\text{return to main}} &\\ \\texttt{SIGUSR1}\\\\[2ex] \\end{array} \\\\ (2) Suppose the child process receives SIGUSR1 at line A, SIGUSR2 when blocked at line B, and SIGINT when SIGUSR1 is caught at line C. How does the child process' signal mask change? \\begin{array}[rl]x \\xrightarrow{\\text{the program start}} &\\ \\text{empty} \\\\[2ex] \\xrightarrow{\\text{block SIGUSR1 by sigprocmask}} &\\ \\texttt{SIGUSR1} \\\\[2ex] \\text{(}\\texttt{SIGUSR1} \\text{ generated} \\text{ but blocked)} & \\\\[2ex] \\xrightarrow{\\text{sigsuspend (change to waitmask)}} &\\ \\texttt{SIGUSR2} \\\\[2ex] \\text{(}\\texttt{SIGUSR2}\\text{ generated} \\text{ but blocked)} & \\\\[2ex] \\xrightarrow{\\text{SIGUSR1 delivered in sigsuspend}} &\\ \\texttt{SIGUSR1 + SIGUSR2 + SIGINT} \\\\[2ex] \\text{(}\\texttt{SIGINT}\\text{ generated} \\text{ but blocked)} & \\\\[2ex] \\xrightarrow{\\text{return to main}} &\\ \\texttt{SIGUSR1} \\\\[2ex] \\xrightarrow{\\text{SIGUSR2 delivered}} &\\ \\texttt{SIGUSR1 + SIGUSR2} \\\\[2ex] \\xrightarrow{\\text{SIGINT delivered in the handler of SIGUSR2}} &\\ \\texttt{SIGUSR1 + SIGUSR2 + SIGINT} \\\\[2ex] \\xrightarrow{\\text{return to the handler of SIGUSR2}} &\\ \\texttt{SIGUSR1 + SIGUSR2} \\\\[2ex] \\xrightarrow{\\text{return to main}} &\\ \\texttt{SIGUSR1}\\\\[2ex] \\end{array} \\begin{array}[rl]x \\xrightarrow{\\text{the program start}} &\\ \\text{empty} \\\\[2ex] \\xrightarrow{\\text{block SIGUSR1 by sigprocmask}} &\\ \\texttt{SIGUSR1} \\\\[2ex] \\text{(}\\texttt{SIGUSR1} \\text{ generated} \\text{ but blocked)} & \\\\[2ex] \\xrightarrow{\\text{sigsuspend (change to waitmask)}} &\\ \\texttt{SIGUSR2} \\\\[2ex] \\text{(}\\texttt{SIGUSR2}\\text{ generated} \\text{ but blocked)} & \\\\[2ex] \\xrightarrow{\\text{SIGUSR1 delivered in sigsuspend}} &\\ \\texttt{SIGUSR1 + SIGUSR2 + SIGINT} \\\\[2ex] \\text{(}\\texttt{SIGINT}\\text{ generated} \\text{ but blocked)} & \\\\[2ex] \\xrightarrow{\\text{return to main}} &\\ \\texttt{SIGUSR1} \\\\[2ex] \\xrightarrow{\\text{SIGUSR2 delivered}} &\\ \\texttt{SIGUSR1 + SIGUSR2} \\\\[2ex] \\xrightarrow{\\text{SIGINT delivered in the handler of SIGUSR2}} &\\ \\texttt{SIGUSR1 + SIGUSR2 + SIGINT} \\\\[2ex] \\xrightarrow{\\text{return to the handler of SIGUSR2}} &\\ \\texttt{SIGUSR1 + SIGUSR2} \\\\[2ex] \\xrightarrow{\\text{return to main}} &\\ \\texttt{SIGUSR1}\\\\[2ex] \\end{array}","title":"Assignment 7"},{"location":"courses/sp-fall-2019/hand-written/hw4/#assignment-7","text":"","title":"Assignment 7"},{"location":"courses/sp-fall-2019/hand-written/hw4/#signals","text":"Please answer the questions according the following program and assumptions: A blocked signal will be delivered immediately when unblocked. If several signals are ready to be delivered at the same time, they will be delivered in the same order of generation. If a blocked signal is generated several times, it will be delivered only once when unblocked. void catchit ( int signo ) { // Line C } int main () { pid_t pid ; sigset_t newmask , waitmask , oldmask ; if ( ( pid = fork ()) == 0 ) { struct sigaction action ; sigemptyset ( & newmask ); sigemptyset ( & waitmask ); sigaddset ( & newmask , SIGUSR1 ); sigaddset ( & waitmask , SIGUSR2 ); sigprocmask ( SIG_BLOCK , & newmask , & oldmask ); action . sa_flags = 0 ; sigemptyset ( & action . sa_mask ); action . sa_handler = catchit ; sigaction ( SIGUSR2 , & action , NULL ); sigaction ( SIGINT , & action , NULL ); sigaddset ( & action . sa_mask , SIGINT ); sigaction ( SIGUSR1 , & action , NULL ); // Line A: critical section sigsuspend ( & waitmask ); // Line B } else { int stat ; kill ( pid , SIGUSR1 ); kill ( pid , SIGUSR2 ); kill ( pid , SIGINT ); pid = wait ( & stat ); } _exit ( 0 ); } (1) Suppose the child process receives SIGUSR2 at line A, SIGINT when blocked at line B, and SIGUSR1 when SIGINT is caught at line C. How does the child process' signal mask change \\begin{array}[rl]x \\xrightarrow{\\text{the program start}} &\\ \\text{empty} \\\\[2ex] \\xrightarrow{\\text{block SIGUSR1 by sigprocmask}} &\\ \\texttt{SIGUSR1} \\\\[2ex] \\xrightarrow{\\text{SIGUSR2 delivered at line A}} &\\ \\texttt{SIGUSR1 + SIGUSR2} \\\\[2ex] \\xrightarrow{\\text{return to main}} &\\ \\texttt{SIGUSR1} \\\\[2ex] \\xrightarrow{\\text{sigsuspend (change to waitmask)}} &\\ \\texttt{SIGUSR2} \\\\[2ex] \\xrightarrow{\\text{SIGINT delivered in sigsuspend}} &\\ \\texttt{SIGUSR2 + SIGINT} \\\\[2ex] \\xrightarrow{\\text{SIGUSR1 delivered in the handler of SIGINT}} &\\ \\texttt{SIGUSR1 + SIGUSR2 + SIGINT} \\\\[2ex] \\xrightarrow{\\text{return to the handler of SIGINT}} &\\ \\texttt{SIGUSR2 + SIGINT} \\\\[2ex] \\xrightarrow{\\text{return to main}} &\\ \\texttt{SIGUSR1}\\\\[2ex] \\end{array} \\\\ \\begin{array}[rl]x \\xrightarrow{\\text{the program start}} &\\ \\text{empty} \\\\[2ex] \\xrightarrow{\\text{block SIGUSR1 by sigprocmask}} &\\ \\texttt{SIGUSR1} \\\\[2ex] \\xrightarrow{\\text{SIGUSR2 delivered at line A}} &\\ \\texttt{SIGUSR1 + SIGUSR2} \\\\[2ex] \\xrightarrow{\\text{return to main}} &\\ \\texttt{SIGUSR1} \\\\[2ex] \\xrightarrow{\\text{sigsuspend (change to waitmask)}} &\\ \\texttt{SIGUSR2} \\\\[2ex] \\xrightarrow{\\text{SIGINT delivered in sigsuspend}} &\\ \\texttt{SIGUSR2 + SIGINT} \\\\[2ex] \\xrightarrow{\\text{SIGUSR1 delivered in the handler of SIGINT}} &\\ \\texttt{SIGUSR1 + SIGUSR2 + SIGINT} \\\\[2ex] \\xrightarrow{\\text{return to the handler of SIGINT}} &\\ \\texttt{SIGUSR2 + SIGINT} \\\\[2ex] \\xrightarrow{\\text{return to main}} &\\ \\texttt{SIGUSR1}\\\\[2ex] \\end{array} \\\\ (2) Suppose the child process receives SIGUSR1 at line A, SIGUSR2 when blocked at line B, and SIGINT when SIGUSR1 is caught at line C. How does the child process' signal mask change? \\begin{array}[rl]x \\xrightarrow{\\text{the program start}} &\\ \\text{empty} \\\\[2ex] \\xrightarrow{\\text{block SIGUSR1 by sigprocmask}} &\\ \\texttt{SIGUSR1} \\\\[2ex] \\text{(}\\texttt{SIGUSR1} \\text{ generated} \\text{ but blocked)} & \\\\[2ex] \\xrightarrow{\\text{sigsuspend (change to waitmask)}} &\\ \\texttt{SIGUSR2} \\\\[2ex] \\text{(}\\texttt{SIGUSR2}\\text{ generated} \\text{ but blocked)} & \\\\[2ex] \\xrightarrow{\\text{SIGUSR1 delivered in sigsuspend}} &\\ \\texttt{SIGUSR1 + SIGUSR2 + SIGINT} \\\\[2ex] \\text{(}\\texttt{SIGINT}\\text{ generated} \\text{ but blocked)} & \\\\[2ex] \\xrightarrow{\\text{return to main}} &\\ \\texttt{SIGUSR1} \\\\[2ex] \\xrightarrow{\\text{SIGUSR2 delivered}} &\\ \\texttt{SIGUSR1 + SIGUSR2} \\\\[2ex] \\xrightarrow{\\text{SIGINT delivered in the handler of SIGUSR2}} &\\ \\texttt{SIGUSR1 + SIGUSR2 + SIGINT} \\\\[2ex] \\xrightarrow{\\text{return to the handler of SIGUSR2}} &\\ \\texttt{SIGUSR1 + SIGUSR2} \\\\[2ex] \\xrightarrow{\\text{return to main}} &\\ \\texttt{SIGUSR1}\\\\[2ex] \\end{array} \\begin{array}[rl]x \\xrightarrow{\\text{the program start}} &\\ \\text{empty} \\\\[2ex] \\xrightarrow{\\text{block SIGUSR1 by sigprocmask}} &\\ \\texttt{SIGUSR1} \\\\[2ex] \\text{(}\\texttt{SIGUSR1} \\text{ generated} \\text{ but blocked)} & \\\\[2ex] \\xrightarrow{\\text{sigsuspend (change to waitmask)}} &\\ \\texttt{SIGUSR2} \\\\[2ex] \\text{(}\\texttt{SIGUSR2}\\text{ generated} \\text{ but blocked)} & \\\\[2ex] \\xrightarrow{\\text{SIGUSR1 delivered in sigsuspend}} &\\ \\texttt{SIGUSR1 + SIGUSR2 + SIGINT} \\\\[2ex] \\text{(}\\texttt{SIGINT}\\text{ generated} \\text{ but blocked)} & \\\\[2ex] \\xrightarrow{\\text{return to main}} &\\ \\texttt{SIGUSR1} \\\\[2ex] \\xrightarrow{\\text{SIGUSR2 delivered}} &\\ \\texttt{SIGUSR1 + SIGUSR2} \\\\[2ex] \\xrightarrow{\\text{SIGINT delivered in the handler of SIGUSR2}} &\\ \\texttt{SIGUSR1 + SIGUSR2 + SIGINT} \\\\[2ex] \\xrightarrow{\\text{return to the handler of SIGUSR2}} &\\ \\texttt{SIGUSR1 + SIGUSR2} \\\\[2ex] \\xrightarrow{\\text{return to main}} &\\ \\texttt{SIGUSR1}\\\\[2ex] \\end{array}","title":"Signals"},{"location":"courses/sp-fall-2019/programming/hw1/","text":"Programming Assignment #1 \u00b6 Important Techniques Learned in this Homework \u00b6 how to use select() to do I/O multiplexing how to use struct flock and fcntl() to operate on advisory file lock readme.txt \u00b6 \u6211\u5c07\u9019\u6b21\u4f5c\u696d\u5206\u6210\u5169\u500b\u968e\u6bb5\u89e3\u6c7a\uff1a \uff081\uff09 IO Multiplexing * \u5361\u95dc1\uff1a\u672a\u5c07server\u7684fd\u8003\u616e\u9032IO Multiplexing\uff0c\u56e0\u6b64\u6211\u7684\u7a0b\u5f0f\u6703\u5361\u5728accept\u9019\u500b\u51fd\u6578\uff0c\u800c\u7121\u6cd5\u53bb\u8655\u7406\u5176\u4ed6\u8981\u6c42 * \u5361\u95dc2\uff1a\u6c92\u6ce8\u610f\u5230\u5728call select\u7684\u6642\u5019\uff0ctimeout\u53ef\u80fd\u6703\u88ab\u6539\u8b8a -> solution: \u5fa9\u5236\u4e00\u4efdtmp_timeout * \u512a\u53161\uff1a\u539f\u672c\u6211\u5c0d3~maxfd\u9032\u884cselect\uff0c\u5f8c\u4f86\u6539\u6210\u53ea\u6aa2\u67e5\u5230\u7576\u4e0b\u958b\u5553\u7684\u6700\u5927fd * \u512a\u53162\uff1a\u5c07server\u53ca\u6bcf\u4e00\u500bconnection\u90fd\u8a2d\u6210nonblocking mode\uff0c\u96d6\u7136\u5728select\u7684\u63a7\u5236\u4e0b\u7406\u61c9\u4e0d\u6703\u88abblock\uff0c\u4f46\u56e0\u7232\u6559\u6388\u5728\u4e0a\u8ab2\u6642\u8aaa\u5efa\u8b70\u5169\u8005\u90fd\u505a\uff0c\u6240\u4ee5\u6211\u4ecd\u7136\u5c07\u5b83\u5011\u8a2d\u7232nonblocking * \u512a\u53163: \u6211\u672c\u4f86\u6bcf\u6b21select\u90fd\u53ea\u53d6\u4e00\u500b\u6700\u5c0f\u53ef\u8b80\u7684fd\u505a\u8655\u7406\uff0c\u5176\u4ed6\u7559\u5230\u4e0b\u6b21select\uff0c\u96d6\u7136\u5728query\u4e0d\u983b\u7e41\u7684\u60c5\u6cc1\u6c92\u6709\u554f\u984c\uff0c\u4f46\u7576concurrency\u589e\u52a0\uff0c\u9019\u6a23\u7406\u8ad6\u4e0a\u5f88\u6c92\u6709\u6548\u7387\uff0c\u56e0\u6b64\u6211\u4fbf\u6539\u7232 \u4e00\u6b21\u6027\u5c0d\u6240\u6709\u53ef\u8b80\u7684fd\u505a\u8655\u7406 # \u51fd\u6578 void add_read_set(int fd): \u5c07fd\u52a0\u5230master_set # \u51fd\u6578 fd_set do_select(): \u56de\u50b3select\u8655\u7406\u904e\u7684fd_set \uff082\uff09 Requests Handling * \u5361\u95dc1\uff1a\u672a\u6ce8\u610f\u5230\u540c\u4e00\u500bprocess\u662f\u7121\u6cd5\u5229\u7528fcntl\u5f97\u77e5\u81ea\u5df1\u4e4b\u524d\u662f\u5426\u6709\u5c0d\u4e00\u500bbyte\u4e0alock -> \u89e3\u6c7a\u8fa6\u6cd5\uff1a\u5229\u7528\u4e00\u500barray\u53bb\u8a18\u61b6\u73fe\u5728\u4e00\u500bid\u662f\u5426\u6709\u88ab\u9396\u4f4f * \u5c0d\u65bc\u5beb\u5165\u52d5\u4f5c\u5169\u500b\u968e\u6bb5\u7684\u8655\u7406\uff1a\u6211\u4f7f\u7528\u4e00\u500barray (wait_for_cmd) \u8a18\u9304\u73fe\u5728\u4e00\u500bconnection\u662f\u5728\u54ea\u4e00\u500b\u968e\u6bb5\u3002\u7531\u65bc\u7576\u6211select\u5230\u4e00\u500b\u4e0d\u662fserver\u7684fd\u6642\uff0c\u6211\u90fd\u6703\u5148\u628a\u8a72fd\u5f9emaster_set\u4e2d\u79fb\u9664\uff0c \u56e0\u6b64\u82e5\u662f\u7b2c\u4e00\u968e\u6bb5\u7684write query\uff0c\u6211\u6703\u5728\u8655\u7406\u7d50\u675f\u5f8c\u518d\u6b21\u5c07\u5b83\u52a0\u5230master_set * \u6211\u5229\u7528 F_SETLK \u9019\u500b fcntl command \u4f86\u4f7f\u6aa2\u67e5\u6709\u6c92\u6709lock\u548c\u4e0alock\u662f\u4e00\u500batomic operation\uff0c\u5982\u6b64\u4e00\u4f86\u5c31\u53ef\u4ee5\u907f\u514d\u5728\u9019\u5169\u8005\u4e4b\u9593\u767c\u751fcontext switch\u7684\u60c5\u6cc1 # \u51fd\u6578 void query_for_read(request *req): \u8655\u7406read query # \u51fd\u6578 query_for_write(request *req): \u8655\u7406write_query\uff0c\u5982\u679c\u8a72connection\u662f\u7b2c\u4e8c\u968e\u6bb5\uff0c\u5247\u547c\u53ebdo_action\u5f8creturn # \u51fd\u6578 do_action(request *req): \u8655\u7406\u7b2c\u4e8c\u968e\u6bb5\u7684write_query\uff0c\u5305\u542b\u5c0daccount_list\u7684\u5404\u7a2e\u5beb\u5165\u64cd\u4f5c server.c \u00b6 #include <unistd.h> #include <stdio.h> #include <stdlib.h> #include <string.h> #include <stdbool.h> #include <errno.h> #include <sys/socket.h> #include <fcntl.h> #include <netinet/in.h> #include <arpa/inet.h> #include <netdb.h> #include <sys/select.h> #define ERR_EXIT(a) { perror(a); exit(1); } typedef struct { char hostname [ 512 ]; // server's hostname unsigned short port ; // port to listen int listen_fd ; // fd to wait for a new connection } server ; typedef struct { char host [ 512 ]; // client's host int conn_fd ; // fd to talk with client char buf [ 512 ]; // data sent by/to client size_t buf_len ; // bytes used by buf // you don't need to change this. int item ; int wait_for_write ; // used by handle_read to know if the header is read or not. } request ; typedef struct { int id ; int balance ; } Account ; server svr ; // server request * requestP = NULL ; // point to a list of requests int maxfd ; // size of open file descriptor table, size of request list const char * accept_read_header = \"ACCEPT_FROM_READ\" ; const char * accept_write_header = \"ACCEPT_FROM_WRITE\" ; // Forwards static void init_server ( unsigned short port ); // initailize a server, exit for error static void init_request ( request * reqP ); // initailize a request instance static void free_request ( request * reqP ); // free resources used by a request instance static int handle_read ( request * reqP ); // return 0: socket ended, request done. // return 1: success, message (without header) got this time is in reqP->buf with reqP->buf_len bytes. read more until got <= 0. // It's guaranteed that the header would be correctly set after the first read. // error code: // -1: client connection error // auxiliary function static void end_conn ( int fd ) { close ( fd ); free_request ( & requestP [ fd ]); } static void set_nonblock ( int fd ) { int flags = fcntl ( fd , F_GETFL , 0 ); flags |= O_NONBLOCK ; fcntl ( fd , F_SETFL , flags ); } // io multiplexing static void init_io_multiplexing (); static void add_read_set ( int fd ); static fd_set do_select (); // request handling static void init_req_handling (); static void query_for_read ( request * req ); static void query_for_write ( request * req ); static void do_action ( request * req , int fd ); int maxfd_now = 0 ; // the max fd among current open fds fd_set master_set ; int main ( int argc , char ** argv ) { int i , ret ; struct sockaddr_in cliaddr ; // used by accept() int clilen ; int conn_fd ; // fd for a new connection with client int file_fd ; // fd for file that we open for reading char buf [ 512 ]; int buf_len ; // Parse args. if ( argc != 2 ) { fprintf ( stderr , \"usage: %s [port] \\n \" , argv [ 0 ]); exit ( 1 ); } // Initialize server init_server (( unsigned short ) atoi ( argv [ 1 ])); // change server to nonblocking mode set_nonblock ( svr . listen_fd ); // Get file descripter table size and initize request table maxfd = getdtablesize (); requestP = ( request * ) malloc ( sizeof ( request ) * maxfd ); if ( requestP == NULL ) { ERR_EXIT ( \"out of memory allocating all requests\" ); } for ( i = 0 ; i < maxfd ; i ++ ) { init_request ( & requestP [ i ]); } requestP [ svr . listen_fd ]. conn_fd = svr . listen_fd ; strcpy ( requestP [ svr . listen_fd ]. host , svr . hostname ); // Loop for handling connections fprintf ( stderr , \" \\n starting on %.80s, port %d, fd %d, maxconn %d... \\n \" , svr . hostname , svr . port , svr . listen_fd , maxfd ); init_io_multiplexing (); add_read_set ( svr . listen_fd ); init_req_handling (); while ( 1 ) { // select one ready to read fd fd_set working_set = do_select (); for ( int fd = 3 ; fd <= maxfd_now ; fd ++ ) { if ( FD_ISSET ( fd , & working_set ) ) { if ( fd == svr . listen_fd ) { // Check new connection clilen = sizeof ( cliaddr ); conn_fd = accept ( svr . listen_fd , ( struct sockaddr * ) & cliaddr , ( socklen_t * ) & clilen ); if ( conn_fd < 0 ) { if ( errno == EINTR || errno == EAGAIN ) { continue ; } if ( errno == ENFILE ) { ( void ) fprintf ( stderr , \"out of file descriptor table ... (maxconn %d) \\n \" , maxfd ); continue ; } ERR_EXIT ( \"accept\" ) } // add conn_fd to io multiplexing waiting queue add_read_set ( conn_fd ); set_nonblock ( conn_fd ); requestP [ conn_fd ]. conn_fd = conn_fd ; strcpy ( requestP [ conn_fd ]. host , inet_ntoa ( cliaddr . sin_addr )); fprintf ( stderr , \"getting a new request... fd %d from %s \\n \" , conn_fd , requestP [ conn_fd ]. host ); } else { FD_CLR ( fd , & master_set ); ret = handle_read ( & requestP [ fd ]); if ( ret < 0 ) { fprintf ( stderr , \"bad request from %s \\n \" , requestP [ fd ]. host ); continue ; } else { #ifdef READ_SERVER query_for_read ( & requestP [ fd ]); #else query_for_write ( & requestP [ fd ]); #endif } } } } } free ( requestP ); return 0 ; } // Start of IO Multiplexing Utilities const static struct timeval timeout = { . tv_sec = 0 , . tv_usec = 10000 }; static void init_io_multiplexing () { FD_ZERO ( & master_set ); maxfd_now = 0 ; } static void add_read_set ( int fd ) { FD_SET ( fd , & master_set ); if ( fd > maxfd_now ) maxfd_now = fd ; } static fd_set do_select () { fd_set fdset ; struct timeval tmp_timeout ; memcpy ( & fdset , & master_set , sizeof ( fd_set )); memcpy ( & tmp_timeout , & timeout , sizeof ( timeout )); if ( select ( maxfd_now + 1 , & fdset , NULL , NULL , & tmp_timeout ) == - 1 ) ERR_EXIT ( \"select\" ); return fdset ; } // End of IO Multiplexing Utilities // Start of Request Handling Utilities static bool try_set_lock ( short type , off_t start , off_t len ); static bool is_locked ( short type , off_t start , off_t len ); static void un_lock ( off_t start , off_t len ); static struct flock mk_lock ( short type , off_t start , off_t len ); static void send_msg ( request * req , char * msg ) { write ( req -> conn_fd , msg , strlen ( msg )); } int account_fd ; int * wait_for_cmd ; bool locked [ 21 ]; static void init_req_handling () { account_fd = open ( \"account_list\" , O_RDWR ); wait_for_cmd = calloc ( maxfd + 1 , sizeof ( int )); memset ( locked , 0 , sizeof ( locked )); } static void query_for_read ( request * req ) { static char buf [ 1 << 10 ]; int id = atoi ( req -> buf ); off_t pos = sizeof ( Account ) * ( id - 1 ); off_t len = sizeof ( Account ); // try set read lock if ( locked [ id ] || ! try_set_lock ( F_RDLCK , pos , len ) ) { send_msg ( req , \"This account is locked. \\n \" ); end_conn ( req -> conn_fd ); return ; } // read bytes lseek ( account_fd , sizeof ( Account ) * ( id - 1 ), SEEK_SET ); Account ans ; read ( account_fd , & ans , sizeof ( Account )); un_lock ( pos , len ); // write to client sprintf ( buf , \"%d %d \\n \" , ans . id , ans . balance ); send_msg ( req , buf ); end_conn ( req -> conn_fd ); } static void query_for_write ( request * req ) { if ( wait_for_cmd [ req -> conn_fd ] ) { do_action ( req , wait_for_cmd [ req -> conn_fd ]); return ; } char buf [ 1 << 10 ]; int id = atoi ( req -> buf ); off_t pos = sizeof ( Account ) * ( id - 1 ); off_t len = sizeof ( Account ); if ( locked [ id ] || ! try_set_lock ( F_WRLCK , pos , len ) ) { send_msg ( req , \"This account is locked. \\n \" ); end_conn ( req -> conn_fd ); return ; } send_msg ( req , \"This account is modifiable. \\n \" ); locked [ id ] = true ; wait_for_cmd [ req -> conn_fd ] = id ; // add to read set add_read_set ( req -> conn_fd ); return ; } static void do_action ( request * req , int id ) { char cmd [ 1 << 10 ], buf [ 1 << 10 ]; int n ; sscanf ( req -> buf , \"%s %d\" , cmd , & n ); off_t pos = sizeof ( Account ) * ( id - 1 ); off_t len = sizeof ( Account ); Account a ; lseek ( account_fd , pos , SEEK_SET ); read ( account_fd , & a , sizeof ( Account )); bool failed = false ; if ( strcmp ( cmd , \"save\" ) == 0 ) { if ( n >= 0 ) { a . balance += n ; } else { failed = true ; } } else if ( strcmp ( cmd , \"withdraw\" ) == 0 ) { if ( n >= 0 && n <= a . balance ) { a . balance -= n ; } else { failed = true ; } } else if ( strcmp ( cmd , \"transfer\" ) == 0 ) { int bid ; sscanf ( req -> buf , \"%s %d %d\" , cmd , & bid , & n ); const off_t bpos = sizeof ( Account ) * ( bid - 1 ); if ( n < 0 || n > a . balance ) { failed = true ; } else { a . balance -= n ; lseek ( account_fd , bpos , SEEK_SET ); Account b ; read ( account_fd , & b , sizeof ( Account )); b . balance += n ; lseek ( account_fd , bpos , SEEK_SET ); write ( account_fd , & b , sizeof ( Account )); } } else if ( strcmp ( cmd , \"balance\" ) == 0 ) { if ( n > 0 ) { a . balance = n ; } else { failed = true ; } } if ( failed ) { send_msg ( req , \"Operation failed. \\n \" ); } else { lseek ( account_fd , pos , SEEK_SET ); write ( account_fd , & a , sizeof ( Account )); } un_lock ( pos , len ); locked [ id ] = 0 ; wait_for_cmd [ req -> conn_fd ] = 0 ; end_conn ( req -> conn_fd ); return ; } static bool try_set_lock ( short type , off_t start , off_t len ) { struct flock flk = mk_lock ( type , start , len ); if ( fcntl ( account_fd , F_SETLK , & flk ) < 0 ) { if ( errno == EACCES || errno == EAGAIN ) { return false ; } else { ERR_EXIT ( \"fcntl\" ); } } return true ; } static void un_lock ( off_t start , off_t len ) { struct flock flk = mk_lock ( F_UNLCK , start , len ); if ( fcntl ( account_fd , F_SETLK , & flk ) < 0 ) ERR_EXIT ( \"un_lock\" ); } static struct flock mk_lock ( short type , off_t start , off_t len ) { struct flock flk ; flk . l_type = type ; flk . l_whence = SEEK_SET ; flk . l_start = start ; flk . l_len = len ; return flk ; } // End of Request Handling Utilities // ====================================================================================================== // You don't need to know how the following codes are working #include <fcntl.h> static void * e_malloc ( size_t size ); static void init_request ( request * reqP ) { reqP -> conn_fd = - 1 ; reqP -> buf_len = 0 ; reqP -> item = 0 ; reqP -> wait_for_write = 0 ; } static void free_request ( request * reqP ) { /*if (reqP->filename != NULL) { free(reqP->filename); reqP->filename = NULL; }*/ init_request ( reqP ); } // return 0: socket ended, request done. // return 1: success, message (without header) got this time is in reqP->buf with reqP->buf_len bytes. read more until got <= 0. // It's guaranteed that the header would be correctly set after the first read. // error code: // -1: client connection error static int handle_read ( request * reqP ) { int r ; char buf [ 512 ]; // Read in request from client r = read ( reqP -> conn_fd , buf , sizeof ( buf )); if ( r < 0 ) return - 1 ; if ( r == 0 ) return 0 ; char * p1 = strstr ( buf , \" \\015\\012 \" ); int newline_len = 2 ; // be careful that in Windows, line ends with \\015\\012 if ( p1 == NULL ) { p1 = strstr ( buf , \" \\012 \" ); newline_len = 1 ; if ( p1 == NULL ) { ERR_EXIT ( \"this really should not happen...\" ); } } size_t len = p1 - buf + 1 ; memmove ( reqP -> buf , buf , len ); reqP -> buf [ len - 1 ] = '\\0' ; reqP -> buf_len = len - 1 ; return 1 ; } static void init_server ( unsigned short port ) { struct sockaddr_in servaddr ; int tmp ; gethostname ( svr . hostname , sizeof ( svr . hostname )); svr . port = port ; svr . listen_fd = socket ( AF_INET , SOCK_STREAM , 0 ); if ( svr . listen_fd < 0 ) ERR_EXIT ( \"socket\" ); bzero ( & servaddr , sizeof ( servaddr )); servaddr . sin_family = AF_INET ; servaddr . sin_addr . s_addr = htonl ( INADDR_ANY ); servaddr . sin_port = htons ( port ); tmp = 1 ; if ( setsockopt ( svr . listen_fd , SOL_SOCKET , SO_REUSEADDR , ( void * ) & tmp , sizeof ( tmp )) < 0 ) { ERR_EXIT ( \"setsockopt\" ); } if ( bind ( svr . listen_fd , ( struct sockaddr * ) & servaddr , sizeof ( servaddr )) < 0 ) { ERR_EXIT ( \"bind\" ); } if ( listen ( svr . listen_fd , 1024 ) < 0 ) { ERR_EXIT ( \"listen\" ); } } static void * e_malloc ( size_t size ) { void * ptr ; ptr = malloc ( size ); if ( ptr == NULL ) ERR_EXIT ( \"out of memory\" ); return ptr ; }","title":"Programming Assignment #1"},{"location":"courses/sp-fall-2019/programming/hw1/#programming-assignment-1","text":"","title":"Programming Assignment #1"},{"location":"courses/sp-fall-2019/programming/hw1/#important-techniques-learned-in-this-homework","text":"how to use select() to do I/O multiplexing how to use struct flock and fcntl() to operate on advisory file lock","title":"Important Techniques Learned in this Homework"},{"location":"courses/sp-fall-2019/programming/hw1/#readmetxt","text":"\u6211\u5c07\u9019\u6b21\u4f5c\u696d\u5206\u6210\u5169\u500b\u968e\u6bb5\u89e3\u6c7a\uff1a \uff081\uff09 IO Multiplexing * \u5361\u95dc1\uff1a\u672a\u5c07server\u7684fd\u8003\u616e\u9032IO Multiplexing\uff0c\u56e0\u6b64\u6211\u7684\u7a0b\u5f0f\u6703\u5361\u5728accept\u9019\u500b\u51fd\u6578\uff0c\u800c\u7121\u6cd5\u53bb\u8655\u7406\u5176\u4ed6\u8981\u6c42 * \u5361\u95dc2\uff1a\u6c92\u6ce8\u610f\u5230\u5728call select\u7684\u6642\u5019\uff0ctimeout\u53ef\u80fd\u6703\u88ab\u6539\u8b8a -> solution: \u5fa9\u5236\u4e00\u4efdtmp_timeout * \u512a\u53161\uff1a\u539f\u672c\u6211\u5c0d3~maxfd\u9032\u884cselect\uff0c\u5f8c\u4f86\u6539\u6210\u53ea\u6aa2\u67e5\u5230\u7576\u4e0b\u958b\u5553\u7684\u6700\u5927fd * \u512a\u53162\uff1a\u5c07server\u53ca\u6bcf\u4e00\u500bconnection\u90fd\u8a2d\u6210nonblocking mode\uff0c\u96d6\u7136\u5728select\u7684\u63a7\u5236\u4e0b\u7406\u61c9\u4e0d\u6703\u88abblock\uff0c\u4f46\u56e0\u7232\u6559\u6388\u5728\u4e0a\u8ab2\u6642\u8aaa\u5efa\u8b70\u5169\u8005\u90fd\u505a\uff0c\u6240\u4ee5\u6211\u4ecd\u7136\u5c07\u5b83\u5011\u8a2d\u7232nonblocking * \u512a\u53163: \u6211\u672c\u4f86\u6bcf\u6b21select\u90fd\u53ea\u53d6\u4e00\u500b\u6700\u5c0f\u53ef\u8b80\u7684fd\u505a\u8655\u7406\uff0c\u5176\u4ed6\u7559\u5230\u4e0b\u6b21select\uff0c\u96d6\u7136\u5728query\u4e0d\u983b\u7e41\u7684\u60c5\u6cc1\u6c92\u6709\u554f\u984c\uff0c\u4f46\u7576concurrency\u589e\u52a0\uff0c\u9019\u6a23\u7406\u8ad6\u4e0a\u5f88\u6c92\u6709\u6548\u7387\uff0c\u56e0\u6b64\u6211\u4fbf\u6539\u7232 \u4e00\u6b21\u6027\u5c0d\u6240\u6709\u53ef\u8b80\u7684fd\u505a\u8655\u7406 # \u51fd\u6578 void add_read_set(int fd): \u5c07fd\u52a0\u5230master_set # \u51fd\u6578 fd_set do_select(): \u56de\u50b3select\u8655\u7406\u904e\u7684fd_set \uff082\uff09 Requests Handling * \u5361\u95dc1\uff1a\u672a\u6ce8\u610f\u5230\u540c\u4e00\u500bprocess\u662f\u7121\u6cd5\u5229\u7528fcntl\u5f97\u77e5\u81ea\u5df1\u4e4b\u524d\u662f\u5426\u6709\u5c0d\u4e00\u500bbyte\u4e0alock -> \u89e3\u6c7a\u8fa6\u6cd5\uff1a\u5229\u7528\u4e00\u500barray\u53bb\u8a18\u61b6\u73fe\u5728\u4e00\u500bid\u662f\u5426\u6709\u88ab\u9396\u4f4f * \u5c0d\u65bc\u5beb\u5165\u52d5\u4f5c\u5169\u500b\u968e\u6bb5\u7684\u8655\u7406\uff1a\u6211\u4f7f\u7528\u4e00\u500barray (wait_for_cmd) \u8a18\u9304\u73fe\u5728\u4e00\u500bconnection\u662f\u5728\u54ea\u4e00\u500b\u968e\u6bb5\u3002\u7531\u65bc\u7576\u6211select\u5230\u4e00\u500b\u4e0d\u662fserver\u7684fd\u6642\uff0c\u6211\u90fd\u6703\u5148\u628a\u8a72fd\u5f9emaster_set\u4e2d\u79fb\u9664\uff0c \u56e0\u6b64\u82e5\u662f\u7b2c\u4e00\u968e\u6bb5\u7684write query\uff0c\u6211\u6703\u5728\u8655\u7406\u7d50\u675f\u5f8c\u518d\u6b21\u5c07\u5b83\u52a0\u5230master_set * \u6211\u5229\u7528 F_SETLK \u9019\u500b fcntl command \u4f86\u4f7f\u6aa2\u67e5\u6709\u6c92\u6709lock\u548c\u4e0alock\u662f\u4e00\u500batomic operation\uff0c\u5982\u6b64\u4e00\u4f86\u5c31\u53ef\u4ee5\u907f\u514d\u5728\u9019\u5169\u8005\u4e4b\u9593\u767c\u751fcontext switch\u7684\u60c5\u6cc1 # \u51fd\u6578 void query_for_read(request *req): \u8655\u7406read query # \u51fd\u6578 query_for_write(request *req): \u8655\u7406write_query\uff0c\u5982\u679c\u8a72connection\u662f\u7b2c\u4e8c\u968e\u6bb5\uff0c\u5247\u547c\u53ebdo_action\u5f8creturn # \u51fd\u6578 do_action(request *req): \u8655\u7406\u7b2c\u4e8c\u968e\u6bb5\u7684write_query\uff0c\u5305\u542b\u5c0daccount_list\u7684\u5404\u7a2e\u5beb\u5165\u64cd\u4f5c","title":"readme.txt"},{"location":"courses/sp-fall-2019/programming/hw1/#serverc","text":"#include <unistd.h> #include <stdio.h> #include <stdlib.h> #include <string.h> #include <stdbool.h> #include <errno.h> #include <sys/socket.h> #include <fcntl.h> #include <netinet/in.h> #include <arpa/inet.h> #include <netdb.h> #include <sys/select.h> #define ERR_EXIT(a) { perror(a); exit(1); } typedef struct { char hostname [ 512 ]; // server's hostname unsigned short port ; // port to listen int listen_fd ; // fd to wait for a new connection } server ; typedef struct { char host [ 512 ]; // client's host int conn_fd ; // fd to talk with client char buf [ 512 ]; // data sent by/to client size_t buf_len ; // bytes used by buf // you don't need to change this. int item ; int wait_for_write ; // used by handle_read to know if the header is read or not. } request ; typedef struct { int id ; int balance ; } Account ; server svr ; // server request * requestP = NULL ; // point to a list of requests int maxfd ; // size of open file descriptor table, size of request list const char * accept_read_header = \"ACCEPT_FROM_READ\" ; const char * accept_write_header = \"ACCEPT_FROM_WRITE\" ; // Forwards static void init_server ( unsigned short port ); // initailize a server, exit for error static void init_request ( request * reqP ); // initailize a request instance static void free_request ( request * reqP ); // free resources used by a request instance static int handle_read ( request * reqP ); // return 0: socket ended, request done. // return 1: success, message (without header) got this time is in reqP->buf with reqP->buf_len bytes. read more until got <= 0. // It's guaranteed that the header would be correctly set after the first read. // error code: // -1: client connection error // auxiliary function static void end_conn ( int fd ) { close ( fd ); free_request ( & requestP [ fd ]); } static void set_nonblock ( int fd ) { int flags = fcntl ( fd , F_GETFL , 0 ); flags |= O_NONBLOCK ; fcntl ( fd , F_SETFL , flags ); } // io multiplexing static void init_io_multiplexing (); static void add_read_set ( int fd ); static fd_set do_select (); // request handling static void init_req_handling (); static void query_for_read ( request * req ); static void query_for_write ( request * req ); static void do_action ( request * req , int fd ); int maxfd_now = 0 ; // the max fd among current open fds fd_set master_set ; int main ( int argc , char ** argv ) { int i , ret ; struct sockaddr_in cliaddr ; // used by accept() int clilen ; int conn_fd ; // fd for a new connection with client int file_fd ; // fd for file that we open for reading char buf [ 512 ]; int buf_len ; // Parse args. if ( argc != 2 ) { fprintf ( stderr , \"usage: %s [port] \\n \" , argv [ 0 ]); exit ( 1 ); } // Initialize server init_server (( unsigned short ) atoi ( argv [ 1 ])); // change server to nonblocking mode set_nonblock ( svr . listen_fd ); // Get file descripter table size and initize request table maxfd = getdtablesize (); requestP = ( request * ) malloc ( sizeof ( request ) * maxfd ); if ( requestP == NULL ) { ERR_EXIT ( \"out of memory allocating all requests\" ); } for ( i = 0 ; i < maxfd ; i ++ ) { init_request ( & requestP [ i ]); } requestP [ svr . listen_fd ]. conn_fd = svr . listen_fd ; strcpy ( requestP [ svr . listen_fd ]. host , svr . hostname ); // Loop for handling connections fprintf ( stderr , \" \\n starting on %.80s, port %d, fd %d, maxconn %d... \\n \" , svr . hostname , svr . port , svr . listen_fd , maxfd ); init_io_multiplexing (); add_read_set ( svr . listen_fd ); init_req_handling (); while ( 1 ) { // select one ready to read fd fd_set working_set = do_select (); for ( int fd = 3 ; fd <= maxfd_now ; fd ++ ) { if ( FD_ISSET ( fd , & working_set ) ) { if ( fd == svr . listen_fd ) { // Check new connection clilen = sizeof ( cliaddr ); conn_fd = accept ( svr . listen_fd , ( struct sockaddr * ) & cliaddr , ( socklen_t * ) & clilen ); if ( conn_fd < 0 ) { if ( errno == EINTR || errno == EAGAIN ) { continue ; } if ( errno == ENFILE ) { ( void ) fprintf ( stderr , \"out of file descriptor table ... (maxconn %d) \\n \" , maxfd ); continue ; } ERR_EXIT ( \"accept\" ) } // add conn_fd to io multiplexing waiting queue add_read_set ( conn_fd ); set_nonblock ( conn_fd ); requestP [ conn_fd ]. conn_fd = conn_fd ; strcpy ( requestP [ conn_fd ]. host , inet_ntoa ( cliaddr . sin_addr )); fprintf ( stderr , \"getting a new request... fd %d from %s \\n \" , conn_fd , requestP [ conn_fd ]. host ); } else { FD_CLR ( fd , & master_set ); ret = handle_read ( & requestP [ fd ]); if ( ret < 0 ) { fprintf ( stderr , \"bad request from %s \\n \" , requestP [ fd ]. host ); continue ; } else { #ifdef READ_SERVER query_for_read ( & requestP [ fd ]); #else query_for_write ( & requestP [ fd ]); #endif } } } } } free ( requestP ); return 0 ; } // Start of IO Multiplexing Utilities const static struct timeval timeout = { . tv_sec = 0 , . tv_usec = 10000 }; static void init_io_multiplexing () { FD_ZERO ( & master_set ); maxfd_now = 0 ; } static void add_read_set ( int fd ) { FD_SET ( fd , & master_set ); if ( fd > maxfd_now ) maxfd_now = fd ; } static fd_set do_select () { fd_set fdset ; struct timeval tmp_timeout ; memcpy ( & fdset , & master_set , sizeof ( fd_set )); memcpy ( & tmp_timeout , & timeout , sizeof ( timeout )); if ( select ( maxfd_now + 1 , & fdset , NULL , NULL , & tmp_timeout ) == - 1 ) ERR_EXIT ( \"select\" ); return fdset ; } // End of IO Multiplexing Utilities // Start of Request Handling Utilities static bool try_set_lock ( short type , off_t start , off_t len ); static bool is_locked ( short type , off_t start , off_t len ); static void un_lock ( off_t start , off_t len ); static struct flock mk_lock ( short type , off_t start , off_t len ); static void send_msg ( request * req , char * msg ) { write ( req -> conn_fd , msg , strlen ( msg )); } int account_fd ; int * wait_for_cmd ; bool locked [ 21 ]; static void init_req_handling () { account_fd = open ( \"account_list\" , O_RDWR ); wait_for_cmd = calloc ( maxfd + 1 , sizeof ( int )); memset ( locked , 0 , sizeof ( locked )); } static void query_for_read ( request * req ) { static char buf [ 1 << 10 ]; int id = atoi ( req -> buf ); off_t pos = sizeof ( Account ) * ( id - 1 ); off_t len = sizeof ( Account ); // try set read lock if ( locked [ id ] || ! try_set_lock ( F_RDLCK , pos , len ) ) { send_msg ( req , \"This account is locked. \\n \" ); end_conn ( req -> conn_fd ); return ; } // read bytes lseek ( account_fd , sizeof ( Account ) * ( id - 1 ), SEEK_SET ); Account ans ; read ( account_fd , & ans , sizeof ( Account )); un_lock ( pos , len ); // write to client sprintf ( buf , \"%d %d \\n \" , ans . id , ans . balance ); send_msg ( req , buf ); end_conn ( req -> conn_fd ); } static void query_for_write ( request * req ) { if ( wait_for_cmd [ req -> conn_fd ] ) { do_action ( req , wait_for_cmd [ req -> conn_fd ]); return ; } char buf [ 1 << 10 ]; int id = atoi ( req -> buf ); off_t pos = sizeof ( Account ) * ( id - 1 ); off_t len = sizeof ( Account ); if ( locked [ id ] || ! try_set_lock ( F_WRLCK , pos , len ) ) { send_msg ( req , \"This account is locked. \\n \" ); end_conn ( req -> conn_fd ); return ; } send_msg ( req , \"This account is modifiable. \\n \" ); locked [ id ] = true ; wait_for_cmd [ req -> conn_fd ] = id ; // add to read set add_read_set ( req -> conn_fd ); return ; } static void do_action ( request * req , int id ) { char cmd [ 1 << 10 ], buf [ 1 << 10 ]; int n ; sscanf ( req -> buf , \"%s %d\" , cmd , & n ); off_t pos = sizeof ( Account ) * ( id - 1 ); off_t len = sizeof ( Account ); Account a ; lseek ( account_fd , pos , SEEK_SET ); read ( account_fd , & a , sizeof ( Account )); bool failed = false ; if ( strcmp ( cmd , \"save\" ) == 0 ) { if ( n >= 0 ) { a . balance += n ; } else { failed = true ; } } else if ( strcmp ( cmd , \"withdraw\" ) == 0 ) { if ( n >= 0 && n <= a . balance ) { a . balance -= n ; } else { failed = true ; } } else if ( strcmp ( cmd , \"transfer\" ) == 0 ) { int bid ; sscanf ( req -> buf , \"%s %d %d\" , cmd , & bid , & n ); const off_t bpos = sizeof ( Account ) * ( bid - 1 ); if ( n < 0 || n > a . balance ) { failed = true ; } else { a . balance -= n ; lseek ( account_fd , bpos , SEEK_SET ); Account b ; read ( account_fd , & b , sizeof ( Account )); b . balance += n ; lseek ( account_fd , bpos , SEEK_SET ); write ( account_fd , & b , sizeof ( Account )); } } else if ( strcmp ( cmd , \"balance\" ) == 0 ) { if ( n > 0 ) { a . balance = n ; } else { failed = true ; } } if ( failed ) { send_msg ( req , \"Operation failed. \\n \" ); } else { lseek ( account_fd , pos , SEEK_SET ); write ( account_fd , & a , sizeof ( Account )); } un_lock ( pos , len ); locked [ id ] = 0 ; wait_for_cmd [ req -> conn_fd ] = 0 ; end_conn ( req -> conn_fd ); return ; } static bool try_set_lock ( short type , off_t start , off_t len ) { struct flock flk = mk_lock ( type , start , len ); if ( fcntl ( account_fd , F_SETLK , & flk ) < 0 ) { if ( errno == EACCES || errno == EAGAIN ) { return false ; } else { ERR_EXIT ( \"fcntl\" ); } } return true ; } static void un_lock ( off_t start , off_t len ) { struct flock flk = mk_lock ( F_UNLCK , start , len ); if ( fcntl ( account_fd , F_SETLK , & flk ) < 0 ) ERR_EXIT ( \"un_lock\" ); } static struct flock mk_lock ( short type , off_t start , off_t len ) { struct flock flk ; flk . l_type = type ; flk . l_whence = SEEK_SET ; flk . l_start = start ; flk . l_len = len ; return flk ; } // End of Request Handling Utilities // ====================================================================================================== // You don't need to know how the following codes are working #include <fcntl.h> static void * e_malloc ( size_t size ); static void init_request ( request * reqP ) { reqP -> conn_fd = - 1 ; reqP -> buf_len = 0 ; reqP -> item = 0 ; reqP -> wait_for_write = 0 ; } static void free_request ( request * reqP ) { /*if (reqP->filename != NULL) { free(reqP->filename); reqP->filename = NULL; }*/ init_request ( reqP ); } // return 0: socket ended, request done. // return 1: success, message (without header) got this time is in reqP->buf with reqP->buf_len bytes. read more until got <= 0. // It's guaranteed that the header would be correctly set after the first read. // error code: // -1: client connection error static int handle_read ( request * reqP ) { int r ; char buf [ 512 ]; // Read in request from client r = read ( reqP -> conn_fd , buf , sizeof ( buf )); if ( r < 0 ) return - 1 ; if ( r == 0 ) return 0 ; char * p1 = strstr ( buf , \" \\015\\012 \" ); int newline_len = 2 ; // be careful that in Windows, line ends with \\015\\012 if ( p1 == NULL ) { p1 = strstr ( buf , \" \\012 \" ); newline_len = 1 ; if ( p1 == NULL ) { ERR_EXIT ( \"this really should not happen...\" ); } } size_t len = p1 - buf + 1 ; memmove ( reqP -> buf , buf , len ); reqP -> buf [ len - 1 ] = '\\0' ; reqP -> buf_len = len - 1 ; return 1 ; } static void init_server ( unsigned short port ) { struct sockaddr_in servaddr ; int tmp ; gethostname ( svr . hostname , sizeof ( svr . hostname )); svr . port = port ; svr . listen_fd = socket ( AF_INET , SOCK_STREAM , 0 ); if ( svr . listen_fd < 0 ) ERR_EXIT ( \"socket\" ); bzero ( & servaddr , sizeof ( servaddr )); servaddr . sin_family = AF_INET ; servaddr . sin_addr . s_addr = htonl ( INADDR_ANY ); servaddr . sin_port = htons ( port ); tmp = 1 ; if ( setsockopt ( svr . listen_fd , SOL_SOCKET , SO_REUSEADDR , ( void * ) & tmp , sizeof ( tmp )) < 0 ) { ERR_EXIT ( \"setsockopt\" ); } if ( bind ( svr . listen_fd , ( struct sockaddr * ) & servaddr , sizeof ( servaddr )) < 0 ) { ERR_EXIT ( \"bind\" ); } if ( listen ( svr . listen_fd , 1024 ) < 0 ) { ERR_EXIT ( \"listen\" ); } } static void * e_malloc ( size_t size ) { void * ptr ; ptr = malloc ( size ); if ( ptr == NULL ) ERR_EXIT ( \"out of memory\" ); return ptr ; }","title":"server.c"},{"location":"courses/sp-fall-2019/programming/hw2/","text":"Programming Assignment #2 \u00b6 Important Techniques Learned in this Homework \u00b6 how to use fork() , wait() , waitpid() how to use pipe() and mkfifo() to do inter process communication(IPC) how to avoid deadlock when opening a FIFO readme.txt \u00b6 Execution: (1) Compilation: $ make (2) Run: $ ./bidding_system [host_num] [player_num] * NOTE: Please ensure that there are no any .FIFO files in working directory, or it will exit and print error message Description: (1) bidding_system.c: * algorithm to enumerate all subset of size 8 on the player set: \u4e00\u958b\u59cb\uff0c\u6211\u5c07 int set[8] \u521d\u59cb\u5316\u6210 {1, 2, 3, 4, 5, 6, 7, 8} \u4e26\u5728\u6bcf\u6b21\u9700\u8981assign\u65b0\u7684coompetition\u7d66root_host\u6642\uff0c \u51fd\u6578 next_subset() \u6703\u5c07 set[] \u6539\u6210\u5b57\u5178\u5e8f\u6bd4\u539f\u672c\u7684subset\u5927\u7684\u6700\u5c0fsubset\u3002\u5177\u9ad4\u5be6\u4f5c\u65b9\u5f0f\u7232\u5f9e i = 7 \u958b\u59cb\u5f80\u524d\u6383\uff0c\u5982\u679c \u628a set[i] + 1 \u4e0d\u8d85\u904e player_num\uff0c\u4e14 set[i] + 1 ... player_num \u8db3\u5920\u586b\u5b8c set[i...7]\uff0c\u5c31\u4ee4 set[i] = set[i] + 1 \uff0c\u4e26\u4ee4set[i+1] = set[i] + 1, set[i+2] = set[i+1] + 1...\u4ee5\u6b64\u985e\u63a8\u3002\u5982\u6b64\u4ee5\u4f86\uff0c\u6211\u5c31\u80fd\u5f97\u5230\u5b57\u5178\u5e8f\u6bd4\u539f\u672c\u7684subset\u5927\u7684\u6700\u5c0fsubset\u3002 \u82e5\u627e\u4e0d\u5230\u9019\u6a23\u7684subset\uff0c\u4e5f\u5c31\u662f\u7576\u524d\u7684subset\u5df2\u7d93\u662f\u5b57\u5178\u5e8f\u6700\u5927\u7684subset\u4e86\uff0cnext_subset()\u56de\u50b3-1,\u6211\u5c31\u77e5\u9053\u5df2\u7d93\u679a\u8209\u5b8c C(player_num, 8) \u7a2e\u4e0d\u540c\u7684subset\u4e86\u3002 * create FIFO: \u6211\u5728\u628a\u6bcf\u4e00\u500bFIFO\u6210\u529fopen\u4e4b\u5f8c\uff0c\u4fbf\u7acb\u523bunlink\u6389\u4ed6\u5011\uff0c\u78ba\u4fdd\u5373\u4f7f\u7a0b\u5f0fcrash\u4e86\uff0c\u4e5f\u4e0d\u6703\u907a\u7559\u9019\u4e9b\u6a94\u6848\u3002 * avoid deadlock when opening FIFO: \u56e0\u7232\u5728blocking mode\u4e0bopen FIFO\u6642\uff0c\u5982\u679c\u5c0d\u9762\u6c92\u6709reader/writer\uff0c\u4fbf\u6703\u88abblock\u4f4f\uff0c\u56e0\u6b64\uff0c\u6211\u5728\u57f7\u884copen() + exec()\u5f8c\u624d\u80fd\u53bbopen\u9019\u4e9b FIFO\uff0c\u5982\u6b64\u4ee5\u4f86\uff0c\u5982\u679c\u5176\u4e2d\u4e00\u908a\u88abblock\u4f4f\u4e86\uff0c\u7cfb\u7d71\u4fbf\u6703context switch\u5230\u53e6\u4e00\u500bprocess\uff0c\u6b64\u6642\u56e0\u7232\u4ed6\u5df2\u7d93\u80fd\u770b\u5230reader/writer\uff0c\u6240\u4ee5\u5c31\u4e0d\u6703 \u88abblock\u4f4f\u3002\u6700\u5f8c\u5728\u5207\u63db\u6703\u672c\u4f86\u88abblock\u4f4f\u7684process\uff0c\u5c31\u80fd\u4f7fparent\u548cchild\u90fd\u9806\u5229\u958b\u5553FIFO\u3002 * output rank of each player: \u56e0\u7232\u5728\u6392\u5e8f\u5f8c\u6211\u5011\u4ecd\u7136\u8981\u77e5\u9053\u6bcf\u4e00\u500bplayer\u672c\u4f86\u7684index\uff0c\u6240\u4ee5\u6211\u5c0dpointer\u6392\u5e8f\uff0c\u9019\u6a23\u5c31\u53ef\u4ee5\u900f\u904epointer\u7684value\u5f97\u77e5\u539f\u672c\u5728array\u4e2d\u7684\u4f4d\u7f6e\u3002 (2) host.c: * pipe \u6211\u5728host\u5efapipe\u7684\u7b56\u7565\u662f\u5c0d\u65bc\u6bcf\u4e00\u500b\u4e0d\u540c\u7684child\u3001write/read\u90fd\u5404\u81ea\u5efa\u7acb\u4e00\u500b\u7368\u7acb\u7684pipe\uff0c\u6211\u8a8d\u7232\u9019\u6a23\u53ef\u4ee5\u6e1b\u5c11\u767c\u751frace condition\u7684\u53ef\u80fd\u6027\u3002 * function sublist(int list[], int L, int R, char buf[]): \u5c07list[]\u4e2d [L, R) \u7684\u6578\u5b57\u8f49\u63db\u7232\u5b57\u4e32\u5beb\u5230buffer\u88cf\uff0c\u65b9\u4fbf\u6211\u5efa\u69cb\u7d66child\u7684\u8a0a\u606f\u3002 (3) player.c: * \u7531\u65bc\u5c0d\u65bcplayer\u4f86\u8aaa\uff0c\u6240\u6709\u8b80\u5beb\u90fd\u662f\u5728standard input/output\u5b8c\u6210\u7684\uff0c\u56e0\u6b64\u53ea\u9700\u8981\u7c21\u55ae\u7684scanf/printf\u5c31\u80fd\u9054\u6210\u6211\u5011\u7684\u8981\u6c42 bidding_system.c \u00b6 #include <unistd.h> #include <stdio.h> #include <stdlib.h> #include <string.h> #include <time.h> #include <fcntl.h> #include <sys/wait.h> #include <sys/stat.h> const char * const usage_msg = \"usage: ./bidding_system [host_num] [player_num] \\n \" ; const char * const read_fifo_name = \"Host.FIFO\" ; #define HOST_NUM_MAX 10 #define PLAYER_NUM_MAX 14 #define FIFO_NAME_MAX 128 typedef struct { pid_t pid ; int fd ; int random_key ; char fifo_name [ FIFO_NAME_MAX ]; } RootHost ; void ERR_EXIT ( char * msg ) { perror ( msg ); exit ( 128 ); } void flush_fsync ( FILE * stream ) { fflush ( stream ); fsync ( fileno ( stream )); } int rank_to_score ( int rank ) { return 8 - rank ; } int next_subset ( int , int []); void create_fifo ( RootHost root_host_list [], int host_num ); void fork_root_hosts ( RootHost root_host_list [], int host_num ); void assign_competition ( RootHost * root_host , int set []); void output_rank ( int player_num , int player_score []); int main ( int argc , char * argv []) { if ( argc != 3 ) { // the number of arguments should be exactly 2 fprintf ( stderr , usage_msg ); exit ( 2 ); } int host_num = atoi ( argv [ 1 ]); // 1 <= x <= 10 int player_num = atoi ( argv [ 2 ]); // 8 <= x <= 14 FILE * read_fifo ; RootHost root_host_list [ HOST_NUM_MAX + 5 ]; create_fifo ( root_host_list , host_num ); // fork root hosts fork_root_hosts ( root_host_list , host_num ); if ( ( read_fifo = fopen ( read_fifo_name , \"rt\" )) == NULL ) ERR_EXIT ( \"fopen\" ); unlink ( read_fifo_name ); // assign every hosts a competition int set [ 8 ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 }; int active_host_num = 0 ; for ( int i = 1 ; i <= host_num ; i ++ ) { if ( ( i == 1 ) || ( i > 1 && next_subset ( player_num , set )) ) { assign_competition ( & root_host_list [ i ], set ); active_host_num ++ ; } } int player_score [ PLAYER_NUM_MAX + 5 ] = { 0 }; while ( active_host_num > 0 ) { int key ; fscanf ( read_fifo , \"%d\" , & key ); for ( int i = 0 ; i < 8 ; i ++ ) { int id , rank ; fscanf ( read_fifo , \"%d %d\" , & id , & rank ); player_score [ id ] += rank_to_score ( rank ); } for ( int i = 1 ; i <= host_num ; i ++ ) { if ( root_host_list [ i ]. random_key == key ) { if ( next_subset ( player_num , set ) ) { assign_competition ( & root_host_list [ i ], set ); } else { active_host_num -- ; } } } } for ( int i = 1 ; i <= host_num ; i ++ ) { char * msg = \"-1 -1 -1 -1 -1 -1 -1 -1 \\n \" ; write ( root_host_list [ i ]. fd , msg , strlen ( msg )); fsync ( root_host_list [ i ]. fd ); } for ( int i = 1 ; i <= host_num ; i ++ ) { int term_status ; waitpid ( root_host_list [ i ]. pid , & term_status , 0 ); if ( close ( root_host_list [ i ]. fd ) == - 1 ) ERR_EXIT ( \"close\" ); } output_rank ( player_num , player_score ); exit ( EXIT_SUCCESS ); } void create_fifo ( RootHost root_host_list [], int host_num ) { if ( mkfifo ( read_fifo_name , 0600 ) < 0 ) ERR_EXIT ( \"mkfifo\" ); for ( int i = 1 ; i <= host_num ; i ++ ) { snprintf ( root_host_list [ i ]. fifo_name , FIFO_NAME_MAX , \"Host%d.FIFO\" , i ); if ( mkfifo ( root_host_list [ i ]. fifo_name , 0600 ) < 0 ) ERR_EXIT ( \"mkfifo\" ); } } #define KEY_MAX 65536 void fork_root_hosts ( RootHost root_host_list [], int host_num ) { int used [ KEY_MAX ] = { 0 }; srand ( time ( NULL )); for ( int i = 1 ; i <= host_num ; i ++ ) { do { root_host_list [ i ]. random_key = rand () % KEY_MAX ; } while ( used [ root_host_list [ i ]. random_key ] ); used [ root_host_list [ i ]. random_key ] = 1 ; root_host_list [ i ]. pid = fork (); if ( root_host_list [ i ]. pid == - 1 ) { ERR_EXIT ( \"fork\" ); } else if ( root_host_list [ i ]. pid == 0 ) { char host_id_str [ 32 ], random_key_str [ 32 ]; snprintf ( host_id_str , 32 , \"%d\" , i ); snprintf ( random_key_str , 32 , \"%d\" , root_host_list [ i ]. random_key ); execl ( \"./host\" , \"host\" , host_id_str , random_key_str , \"0\" , ( char * ) 0 ); } else { if ( ( root_host_list [ i ]. fd = open ( root_host_list [ i ]. fifo_name , O_WRONLY )) == - 1 ) ERR_EXIT ( \"open\" ); unlink ( root_host_list [ i ]. fifo_name ); } } } void assign_competition ( RootHost * root_host , int set []) { char set_str [ BUFSIZ ]; int len = snprintf ( set_str , BUFSIZ , \"%d %d %d %d %d %d %d %d \\n \" , set [ 0 ], set [ 1 ], set [ 2 ], set [ 3 ], set [ 4 ], set [ 5 ], set [ 6 ], set [ 7 ]); write ( root_host -> fd , set_str , len ); fsync ( root_host -> fd ); } int next_subset ( int player_num , int set []) { for ( int i = 7 ; i >= 0 ; i -- ) { if ( set [ i ] + ( 7 - i ) < player_num ) { set [ i ] ++ ; for ( int j = i + 1 ; j <= 7 ; j ++ ) set [ j ] = set [ j - 1 ] + 1 ; return 1 ; } } return 0 ; } int cmp ( const void * a , const void * b ) { int x = ** ( int ** ) a , y = ** ( int ** ) b ; return ( x < y ) - ( x > y ); } void output_rank ( int player_num , int player_score []) { int * ptr [ PLAYER_NUM_MAX + 5 ]; for ( int i = 1 ; i <= player_num ; i ++ ) ptr [ i ] = & player_score [ i ]; qsort ( ptr + 1 , player_num , sizeof ( int * ), cmp ); int rank [ PLAYER_NUM_MAX + 5 ]; rank [ ptr [ 1 ] - player_score ] = 1 ; for ( int i = 2 ; i <= player_num ; i ++ ) rank [ ptr [ i ] - player_score ] = ( * ptr [ i ] == * ptr [ i - 1 ]) ? rank [ ptr [ i - 1 ] - player_score ] : i ; for ( int i = 1 ; i <= player_num ; i ++ ) printf ( \"%d %d \\n \" , i , rank [ i ]); } host.c \u00b6 #include <unistd.h> #include <stdio.h> #include <stdlib.h> #include <string.h> #include <fcntl.h> #include <sys/wait.h> #include <sys/stat.h> #include <sys/types.h> const char * const usage_msg = \"usage: ./host [host_id] [random_key] [depth]\" ; const char * const write_fifo_name = \"Host.FIFO\" ; #define FIFO_NAME_MAX 128 const int ROOT_HOST_DEP = 0 ; const int CHILD_HOST_DEP = 1 ; const int LEAF_HOST_DEP = 2 ; const int ROUND_NUM = 10 ; typedef struct { int player_id , score , rank ; } PlayerRecord ; typedef struct { pid_t pid ; int wr_pipe_fd , rd_pipe_fd ; } Child ; void ERR_EXIT ( char * msg ) { perror ( msg ); exit ( 128 ); } void flush_fsync ( FILE * stream ) { fflush ( stream ); fsync ( fileno ( stream )); } void read_player_id ( int player_id_list [], int n , int fd ); int sublist ( int list [], int L , int R , char buf []); void fork_child ( Child child_list [], int player_id_list [], int depth , char * argv []); void run_game ( Child child_list [], int depth , void * extra ); void calc_rank ( PlayerRecord player_record_list []); void clean_child ( Child child_host_list []); int main ( int argc , char * argv []) { if ( argc != 4 ) { // the number of arguments should be exactly 3 fprintf ( stderr , usage_msg ); exit ( 2 ); } int host_id = atoi ( argv [ 1 ]); int random_key = atoi ( argv [ 2 ]); int depth = atoi ( argv [ 3 ]); if ( depth == ROOT_HOST_DEP ) { // fifo for read from bidding system char fifo_path [ FIFO_NAME_MAX ]; snprintf ( fifo_path , FIFO_NAME_MAX , \"Host%d.FIFO\" , host_id ); int read_fifo_fd = open ( fifo_path , O_RDONLY ); if ( read_fifo_fd == - 1 ) ERR_EXIT ( \"open\" ); // fifo for write to bidding system int write_fifo_fd = open ( write_fifo_name , O_WRONLY ); if ( write_fifo_fd == - 1 ) ERR_EXIT ( \"open\" ); // fork 2 child hosts Child child_host_list [ 2 ]; fork_child ( child_host_list , NULL , depth , argv ); while ( 1 ) { int player_id_list [ 8 ]; read_player_id ( player_id_list , 8 , read_fifo_fd ); if ( player_id_list [ 0 ] == - 1 ) { for ( int i = 0 ; i < 2 ; i ++ ) { char * msg = \"-1 -1 -1 -1 \\n \" ; write ( child_host_list [ i ]. wr_pipe_fd , msg , strlen ( msg )); fsync ( child_host_list [ i ]. wr_pipe_fd ); } break ; } // assign players to 2 child hosts for ( int i = 0 ; i < 2 ; i ++ ) { char buf [ BUFSIZ ]; int len = sublist ( player_id_list , i * ( 4 >> depth ), i * ( 4 >> depth ) + ( 4 >> depth ), buf ); write ( child_host_list [ i ]. wr_pipe_fd , buf , len ); fsync ( child_host_list [ i ]. wr_pipe_fd ); } // init player record PlayerRecord player_record_list [ 8 ]; for ( int i = 0 ; i < 8 ; i ++ ) { player_record_list [ i ]. player_id = player_id_list [ i ]; player_record_list [ i ]. score = 0 ; } run_game ( child_host_list , depth , player_record_list ); calc_rank ( player_record_list ); char buf [ BUFSIZ ]; char * p = buf ; p += snprintf ( buf , BUFSIZ , \"%d \\n \" , random_key ); for ( int i = 0 ; i < 8 ; i ++ ) { p += snprintf ( p , BUFSIZ , \"%d %d \\n \" , player_record_list [ i ]. player_id , player_record_list [ i ]. rank ); } write ( write_fifo_fd , buf , strlen ( buf )); fsync ( write_fifo_fd ); } clean_child ( child_host_list ); close ( read_fifo_fd ); close ( write_fifo_fd ); } else if ( depth == CHILD_HOST_DEP ) { Child leaf_host_list [ 2 ]; fork_child ( leaf_host_list , NULL , depth , argv ); while ( 1 ) { int player_id_list [ 4 ]; read_player_id ( player_id_list , 4 , STDIN_FILENO ); if ( player_id_list [ 0 ] == - 1 ) { for ( int i = 0 ; i < 2 ; i ++ ) { char * msg = \"-1 -1 \\n \" ; write ( leaf_host_list [ i ]. wr_pipe_fd , msg , strlen ( msg )); fsync ( leaf_host_list [ i ]. wr_pipe_fd ); } break ; } for ( int i = 0 ; i < 2 ; i ++ ) { char buf [ BUFSIZ ]; int len = sublist ( player_id_list , i * ( 4 >> depth ), i * ( 4 >> depth ) + ( 4 >> depth ), buf ); write ( leaf_host_list [ i ]. wr_pipe_fd , buf , len ); fsync ( leaf_host_list [ i ]. wr_pipe_fd ); } run_game ( leaf_host_list , depth , NULL ); } clean_child ( leaf_host_list ); } else if ( depth == LEAF_HOST_DEP ) { while ( 1 ) { int player_id_list [ 2 ]; read_player_id ( player_id_list , 2 , STDIN_FILENO ); if ( player_id_list [ 0 ] == - 1 ) { break ; } Child player_list [ 2 ]; fork_child ( player_list , player_id_list , depth , argv ); run_game ( player_list , depth , NULL ); clean_child ( player_list ); } } return EXIT_SUCCESS ; } void read_player_id ( int player_id_list [], int n , int fd ) { char buf [ BUFSIZ ]; char * p = buf ; read ( fd , p , BUFSIZ ); for ( int i = 0 ; i < n ; i ++ ) { player_id_list [ i ] = strtol ( p , & p , 10 ); } } int sublist ( int list [], int L , int R , char buf []) { char * ptr = buf ; for ( int i = L ; i < R ; i ++ ) ptr += snprintf ( ptr , BUFSIZ , \"%d%c\" , list [ i ], \" \\n \" [ i == R - 1 ]); return ( ptr - buf ); } void fork_child ( Child child_list [], int player_id_list [], int depth , char * argv []) { for ( int i = 0 ; i < 2 ; i ++ ) { // pipe int pfd [ 2 ][ 2 ]; int pip_res1 = pipe ( pfd [ 0 ]); // parent read, child write int pip_res2 = pipe ( pfd [ 1 ]); // parent write, child read if ( pip_res1 == - 1 || pip_res2 == - 1 ) ERR_EXIT ( \"pipe\" ); // fork child_list [ i ]. pid = fork (); if ( child_list [ i ]. pid == - 1 ) { ERR_EXIT ( \"fork\" ); } else if ( child_list [ i ]. pid == 0 ) { // child close ( pfd [ 0 ][ 0 ]); dup2 ( pfd [ 0 ][ 1 ], 1 ); close ( pfd [ 0 ][ 1 ]); close ( pfd [ 1 ][ 1 ]); dup2 ( pfd [ 1 ][ 0 ], 0 ); close ( pfd [ 1 ][ 0 ]); if ( depth != LEAF_HOST_DEP ) { char next_dep [ 4 ]; snprintf ( next_dep , 4 , \"%d\" , depth + 1 ); execl ( \"./host\" , \"host\" , argv [ 1 ], argv [ 2 ], next_dep , NULL ); } else { char buf [ 4 ]; snprintf ( buf , 4 , \"%d\" , player_id_list [ i ]); execl ( \"./player\" , \"player\" , buf , NULL ); } } else { // parent close ( pfd [ 0 ][ 1 ]); child_list [ i ]. rd_pipe_fd = pfd [ 0 ][ 0 ]; close ( pfd [ 1 ][ 0 ]); child_list [ i ]. wr_pipe_fd = pfd [ 1 ][ 1 ]; } } } void run_game ( Child child_list [], int depth , void * extra ) { PlayerRecord * player_record_list = ( PlayerRecord * ) extra ; int id_2_idx [ 32 ]; for ( int i = 0 ; depth == 0 && i < 8 ; i ++ ) id_2_idx [ player_record_list [ i ]. player_id ] = i ; for ( int round = 1 ; round <= ROUND_NUM ; round ++ ) { // read result from two child hosts int player_id [ 2 ], money [ 2 ]; char buf [ BUFSIZ ]; read ( child_list [ 0 ]. rd_pipe_fd , buf , BUFSIZ ); sscanf ( buf , \"%d %d\" , & player_id [ 0 ], & money [ 0 ]); read ( child_list [ 1 ]. rd_pipe_fd , buf , BUFSIZ ); sscanf ( buf , \"%d %d\" , & player_id [ 1 ], & money [ 1 ]); // compare two results int winner_id , win_money ; if ( money [ 0 ] > money [ 1 ] ) { winner_id = player_id [ 0 ]; win_money = money [ 0 ]; } else { winner_id = player_id [ 1 ]; win_money = money [ 1 ]; } if ( depth == 0 ) { // if dep == 0: update player score and write winner to 2 child ++ player_record_list [ id_2_idx [ winner_id ] ]. score ; if ( round != ROUND_NUM ) { for ( int i = 0 ; i < 2 ; i ++ ) { int len = sprintf ( buf , \"%d \\n \" , winner_id ); write ( child_list [ i ]. wr_pipe_fd , buf , len ); fsync ( child_list [ i ]. wr_pipe_fd ); } } } else { // if dep > 0: write winner, money to stdout and read final winner from stdin and write final winner to 2 child int len = sprintf ( buf , \"%d %d \\n \" , winner_id , win_money ); write ( STDOUT_FILENO , buf , len ); fsync ( STDOUT_FILENO ); if ( round != ROUND_NUM ) { int len = read ( STDIN_FILENO , buf , BUFSIZ ); for ( int i = 0 ; i < 2 ; i ++ ) { write ( child_list [ i ]. wr_pipe_fd , buf , len ); fsync ( child_list [ i ]. wr_pipe_fd ); } } } } } int cmp ( const void * a , const void * b ) { int x = ( * ( PlayerRecord ** ) a ) -> score , y = ( * ( PlayerRecord ** ) b ) -> score ; return ( x < y ) - ( x > y ); } void calc_rank ( PlayerRecord player_record_list []) { PlayerRecord * ptr [ 8 ]; for ( int i = 0 ; i < 8 ; i ++ ) ptr [ i ] = & player_record_list [ i ]; qsort ( ptr , 8 , sizeof ( PlayerRecord * ), cmp ); ptr [ 0 ] -> rank = 1 ; for ( int i = 1 ; i < 8 ; i ++ ) ptr [ i ] -> rank = ( ptr [ i ] -> score == ptr [ i - 1 ] -> score ) ? ptr [ i - 1 ] -> rank : i + 1 ; } void clean_child ( Child child_list []) { for ( int i = 0 ; i < 2 ; i ++ ) { int status ; waitpid ( child_list [ i ]. pid , & status , 0 ); close ( child_list [ i ]. rd_pipe_fd ); close ( child_list [ i ]. wr_pipe_fd ); } } player.c \u00b6 #include <unistd.h> #include <stdio.h> #include <stdlib.h> const char * const usage_msg = \"usage: ./player [player_id]\" ; const int ROUND_NUM = 10 ; void ERR_EXIT ( char * msg ) { perror ( msg ); exit ( 128 ); } void flush_fsync ( FILE * stream ) { fflush ( stream ); fsync ( fileno ( stream )); } void read_winner_id () { int winner_id ; scanf ( \"%d\" , & winner_id ); } void tell_host_money ( int player_id , int money ) { printf ( \"%d %d \\n \" , player_id , money ); flush_fsync ( stdout ); } int main ( int argc , char * argv []) { if ( argc != 2 ) { // the number of arguments should be exactly 1 fprintf ( stderr , usage_msg ); exit ( 2 ); } const int player_id = atoi ( argv [ 1 ]); const int money = player_id * 100 ; for ( int round = 1 ; round <= ROUND_NUM ; ++ round ) { if ( round > 1 ) read_winner_id (); tell_host_money ( player_id , money ); } return EXIT_SUCCESS ; }","title":"Programming Assignment #2"},{"location":"courses/sp-fall-2019/programming/hw2/#programming-assignment-2","text":"","title":"Programming Assignment #2"},{"location":"courses/sp-fall-2019/programming/hw2/#important-techniques-learned-in-this-homework","text":"how to use fork() , wait() , waitpid() how to use pipe() and mkfifo() to do inter process communication(IPC) how to avoid deadlock when opening a FIFO","title":"Important Techniques Learned in this Homework"},{"location":"courses/sp-fall-2019/programming/hw2/#readmetxt","text":"Execution: (1) Compilation: $ make (2) Run: $ ./bidding_system [host_num] [player_num] * NOTE: Please ensure that there are no any .FIFO files in working directory, or it will exit and print error message Description: (1) bidding_system.c: * algorithm to enumerate all subset of size 8 on the player set: \u4e00\u958b\u59cb\uff0c\u6211\u5c07 int set[8] \u521d\u59cb\u5316\u6210 {1, 2, 3, 4, 5, 6, 7, 8} \u4e26\u5728\u6bcf\u6b21\u9700\u8981assign\u65b0\u7684coompetition\u7d66root_host\u6642\uff0c \u51fd\u6578 next_subset() \u6703\u5c07 set[] \u6539\u6210\u5b57\u5178\u5e8f\u6bd4\u539f\u672c\u7684subset\u5927\u7684\u6700\u5c0fsubset\u3002\u5177\u9ad4\u5be6\u4f5c\u65b9\u5f0f\u7232\u5f9e i = 7 \u958b\u59cb\u5f80\u524d\u6383\uff0c\u5982\u679c \u628a set[i] + 1 \u4e0d\u8d85\u904e player_num\uff0c\u4e14 set[i] + 1 ... player_num \u8db3\u5920\u586b\u5b8c set[i...7]\uff0c\u5c31\u4ee4 set[i] = set[i] + 1 \uff0c\u4e26\u4ee4set[i+1] = set[i] + 1, set[i+2] = set[i+1] + 1...\u4ee5\u6b64\u985e\u63a8\u3002\u5982\u6b64\u4ee5\u4f86\uff0c\u6211\u5c31\u80fd\u5f97\u5230\u5b57\u5178\u5e8f\u6bd4\u539f\u672c\u7684subset\u5927\u7684\u6700\u5c0fsubset\u3002 \u82e5\u627e\u4e0d\u5230\u9019\u6a23\u7684subset\uff0c\u4e5f\u5c31\u662f\u7576\u524d\u7684subset\u5df2\u7d93\u662f\u5b57\u5178\u5e8f\u6700\u5927\u7684subset\u4e86\uff0cnext_subset()\u56de\u50b3-1,\u6211\u5c31\u77e5\u9053\u5df2\u7d93\u679a\u8209\u5b8c C(player_num, 8) \u7a2e\u4e0d\u540c\u7684subset\u4e86\u3002 * create FIFO: \u6211\u5728\u628a\u6bcf\u4e00\u500bFIFO\u6210\u529fopen\u4e4b\u5f8c\uff0c\u4fbf\u7acb\u523bunlink\u6389\u4ed6\u5011\uff0c\u78ba\u4fdd\u5373\u4f7f\u7a0b\u5f0fcrash\u4e86\uff0c\u4e5f\u4e0d\u6703\u907a\u7559\u9019\u4e9b\u6a94\u6848\u3002 * avoid deadlock when opening FIFO: \u56e0\u7232\u5728blocking mode\u4e0bopen FIFO\u6642\uff0c\u5982\u679c\u5c0d\u9762\u6c92\u6709reader/writer\uff0c\u4fbf\u6703\u88abblock\u4f4f\uff0c\u56e0\u6b64\uff0c\u6211\u5728\u57f7\u884copen() + exec()\u5f8c\u624d\u80fd\u53bbopen\u9019\u4e9b FIFO\uff0c\u5982\u6b64\u4ee5\u4f86\uff0c\u5982\u679c\u5176\u4e2d\u4e00\u908a\u88abblock\u4f4f\u4e86\uff0c\u7cfb\u7d71\u4fbf\u6703context switch\u5230\u53e6\u4e00\u500bprocess\uff0c\u6b64\u6642\u56e0\u7232\u4ed6\u5df2\u7d93\u80fd\u770b\u5230reader/writer\uff0c\u6240\u4ee5\u5c31\u4e0d\u6703 \u88abblock\u4f4f\u3002\u6700\u5f8c\u5728\u5207\u63db\u6703\u672c\u4f86\u88abblock\u4f4f\u7684process\uff0c\u5c31\u80fd\u4f7fparent\u548cchild\u90fd\u9806\u5229\u958b\u5553FIFO\u3002 * output rank of each player: \u56e0\u7232\u5728\u6392\u5e8f\u5f8c\u6211\u5011\u4ecd\u7136\u8981\u77e5\u9053\u6bcf\u4e00\u500bplayer\u672c\u4f86\u7684index\uff0c\u6240\u4ee5\u6211\u5c0dpointer\u6392\u5e8f\uff0c\u9019\u6a23\u5c31\u53ef\u4ee5\u900f\u904epointer\u7684value\u5f97\u77e5\u539f\u672c\u5728array\u4e2d\u7684\u4f4d\u7f6e\u3002 (2) host.c: * pipe \u6211\u5728host\u5efapipe\u7684\u7b56\u7565\u662f\u5c0d\u65bc\u6bcf\u4e00\u500b\u4e0d\u540c\u7684child\u3001write/read\u90fd\u5404\u81ea\u5efa\u7acb\u4e00\u500b\u7368\u7acb\u7684pipe\uff0c\u6211\u8a8d\u7232\u9019\u6a23\u53ef\u4ee5\u6e1b\u5c11\u767c\u751frace condition\u7684\u53ef\u80fd\u6027\u3002 * function sublist(int list[], int L, int R, char buf[]): \u5c07list[]\u4e2d [L, R) \u7684\u6578\u5b57\u8f49\u63db\u7232\u5b57\u4e32\u5beb\u5230buffer\u88cf\uff0c\u65b9\u4fbf\u6211\u5efa\u69cb\u7d66child\u7684\u8a0a\u606f\u3002 (3) player.c: * \u7531\u65bc\u5c0d\u65bcplayer\u4f86\u8aaa\uff0c\u6240\u6709\u8b80\u5beb\u90fd\u662f\u5728standard input/output\u5b8c\u6210\u7684\uff0c\u56e0\u6b64\u53ea\u9700\u8981\u7c21\u55ae\u7684scanf/printf\u5c31\u80fd\u9054\u6210\u6211\u5011\u7684\u8981\u6c42","title":"readme.txt"},{"location":"courses/sp-fall-2019/programming/hw2/#bidding_systemc","text":"#include <unistd.h> #include <stdio.h> #include <stdlib.h> #include <string.h> #include <time.h> #include <fcntl.h> #include <sys/wait.h> #include <sys/stat.h> const char * const usage_msg = \"usage: ./bidding_system [host_num] [player_num] \\n \" ; const char * const read_fifo_name = \"Host.FIFO\" ; #define HOST_NUM_MAX 10 #define PLAYER_NUM_MAX 14 #define FIFO_NAME_MAX 128 typedef struct { pid_t pid ; int fd ; int random_key ; char fifo_name [ FIFO_NAME_MAX ]; } RootHost ; void ERR_EXIT ( char * msg ) { perror ( msg ); exit ( 128 ); } void flush_fsync ( FILE * stream ) { fflush ( stream ); fsync ( fileno ( stream )); } int rank_to_score ( int rank ) { return 8 - rank ; } int next_subset ( int , int []); void create_fifo ( RootHost root_host_list [], int host_num ); void fork_root_hosts ( RootHost root_host_list [], int host_num ); void assign_competition ( RootHost * root_host , int set []); void output_rank ( int player_num , int player_score []); int main ( int argc , char * argv []) { if ( argc != 3 ) { // the number of arguments should be exactly 2 fprintf ( stderr , usage_msg ); exit ( 2 ); } int host_num = atoi ( argv [ 1 ]); // 1 <= x <= 10 int player_num = atoi ( argv [ 2 ]); // 8 <= x <= 14 FILE * read_fifo ; RootHost root_host_list [ HOST_NUM_MAX + 5 ]; create_fifo ( root_host_list , host_num ); // fork root hosts fork_root_hosts ( root_host_list , host_num ); if ( ( read_fifo = fopen ( read_fifo_name , \"rt\" )) == NULL ) ERR_EXIT ( \"fopen\" ); unlink ( read_fifo_name ); // assign every hosts a competition int set [ 8 ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 }; int active_host_num = 0 ; for ( int i = 1 ; i <= host_num ; i ++ ) { if ( ( i == 1 ) || ( i > 1 && next_subset ( player_num , set )) ) { assign_competition ( & root_host_list [ i ], set ); active_host_num ++ ; } } int player_score [ PLAYER_NUM_MAX + 5 ] = { 0 }; while ( active_host_num > 0 ) { int key ; fscanf ( read_fifo , \"%d\" , & key ); for ( int i = 0 ; i < 8 ; i ++ ) { int id , rank ; fscanf ( read_fifo , \"%d %d\" , & id , & rank ); player_score [ id ] += rank_to_score ( rank ); } for ( int i = 1 ; i <= host_num ; i ++ ) { if ( root_host_list [ i ]. random_key == key ) { if ( next_subset ( player_num , set ) ) { assign_competition ( & root_host_list [ i ], set ); } else { active_host_num -- ; } } } } for ( int i = 1 ; i <= host_num ; i ++ ) { char * msg = \"-1 -1 -1 -1 -1 -1 -1 -1 \\n \" ; write ( root_host_list [ i ]. fd , msg , strlen ( msg )); fsync ( root_host_list [ i ]. fd ); } for ( int i = 1 ; i <= host_num ; i ++ ) { int term_status ; waitpid ( root_host_list [ i ]. pid , & term_status , 0 ); if ( close ( root_host_list [ i ]. fd ) == - 1 ) ERR_EXIT ( \"close\" ); } output_rank ( player_num , player_score ); exit ( EXIT_SUCCESS ); } void create_fifo ( RootHost root_host_list [], int host_num ) { if ( mkfifo ( read_fifo_name , 0600 ) < 0 ) ERR_EXIT ( \"mkfifo\" ); for ( int i = 1 ; i <= host_num ; i ++ ) { snprintf ( root_host_list [ i ]. fifo_name , FIFO_NAME_MAX , \"Host%d.FIFO\" , i ); if ( mkfifo ( root_host_list [ i ]. fifo_name , 0600 ) < 0 ) ERR_EXIT ( \"mkfifo\" ); } } #define KEY_MAX 65536 void fork_root_hosts ( RootHost root_host_list [], int host_num ) { int used [ KEY_MAX ] = { 0 }; srand ( time ( NULL )); for ( int i = 1 ; i <= host_num ; i ++ ) { do { root_host_list [ i ]. random_key = rand () % KEY_MAX ; } while ( used [ root_host_list [ i ]. random_key ] ); used [ root_host_list [ i ]. random_key ] = 1 ; root_host_list [ i ]. pid = fork (); if ( root_host_list [ i ]. pid == - 1 ) { ERR_EXIT ( \"fork\" ); } else if ( root_host_list [ i ]. pid == 0 ) { char host_id_str [ 32 ], random_key_str [ 32 ]; snprintf ( host_id_str , 32 , \"%d\" , i ); snprintf ( random_key_str , 32 , \"%d\" , root_host_list [ i ]. random_key ); execl ( \"./host\" , \"host\" , host_id_str , random_key_str , \"0\" , ( char * ) 0 ); } else { if ( ( root_host_list [ i ]. fd = open ( root_host_list [ i ]. fifo_name , O_WRONLY )) == - 1 ) ERR_EXIT ( \"open\" ); unlink ( root_host_list [ i ]. fifo_name ); } } } void assign_competition ( RootHost * root_host , int set []) { char set_str [ BUFSIZ ]; int len = snprintf ( set_str , BUFSIZ , \"%d %d %d %d %d %d %d %d \\n \" , set [ 0 ], set [ 1 ], set [ 2 ], set [ 3 ], set [ 4 ], set [ 5 ], set [ 6 ], set [ 7 ]); write ( root_host -> fd , set_str , len ); fsync ( root_host -> fd ); } int next_subset ( int player_num , int set []) { for ( int i = 7 ; i >= 0 ; i -- ) { if ( set [ i ] + ( 7 - i ) < player_num ) { set [ i ] ++ ; for ( int j = i + 1 ; j <= 7 ; j ++ ) set [ j ] = set [ j - 1 ] + 1 ; return 1 ; } } return 0 ; } int cmp ( const void * a , const void * b ) { int x = ** ( int ** ) a , y = ** ( int ** ) b ; return ( x < y ) - ( x > y ); } void output_rank ( int player_num , int player_score []) { int * ptr [ PLAYER_NUM_MAX + 5 ]; for ( int i = 1 ; i <= player_num ; i ++ ) ptr [ i ] = & player_score [ i ]; qsort ( ptr + 1 , player_num , sizeof ( int * ), cmp ); int rank [ PLAYER_NUM_MAX + 5 ]; rank [ ptr [ 1 ] - player_score ] = 1 ; for ( int i = 2 ; i <= player_num ; i ++ ) rank [ ptr [ i ] - player_score ] = ( * ptr [ i ] == * ptr [ i - 1 ]) ? rank [ ptr [ i - 1 ] - player_score ] : i ; for ( int i = 1 ; i <= player_num ; i ++ ) printf ( \"%d %d \\n \" , i , rank [ i ]); }","title":"bidding_system.c"},{"location":"courses/sp-fall-2019/programming/hw2/#hostc","text":"#include <unistd.h> #include <stdio.h> #include <stdlib.h> #include <string.h> #include <fcntl.h> #include <sys/wait.h> #include <sys/stat.h> #include <sys/types.h> const char * const usage_msg = \"usage: ./host [host_id] [random_key] [depth]\" ; const char * const write_fifo_name = \"Host.FIFO\" ; #define FIFO_NAME_MAX 128 const int ROOT_HOST_DEP = 0 ; const int CHILD_HOST_DEP = 1 ; const int LEAF_HOST_DEP = 2 ; const int ROUND_NUM = 10 ; typedef struct { int player_id , score , rank ; } PlayerRecord ; typedef struct { pid_t pid ; int wr_pipe_fd , rd_pipe_fd ; } Child ; void ERR_EXIT ( char * msg ) { perror ( msg ); exit ( 128 ); } void flush_fsync ( FILE * stream ) { fflush ( stream ); fsync ( fileno ( stream )); } void read_player_id ( int player_id_list [], int n , int fd ); int sublist ( int list [], int L , int R , char buf []); void fork_child ( Child child_list [], int player_id_list [], int depth , char * argv []); void run_game ( Child child_list [], int depth , void * extra ); void calc_rank ( PlayerRecord player_record_list []); void clean_child ( Child child_host_list []); int main ( int argc , char * argv []) { if ( argc != 4 ) { // the number of arguments should be exactly 3 fprintf ( stderr , usage_msg ); exit ( 2 ); } int host_id = atoi ( argv [ 1 ]); int random_key = atoi ( argv [ 2 ]); int depth = atoi ( argv [ 3 ]); if ( depth == ROOT_HOST_DEP ) { // fifo for read from bidding system char fifo_path [ FIFO_NAME_MAX ]; snprintf ( fifo_path , FIFO_NAME_MAX , \"Host%d.FIFO\" , host_id ); int read_fifo_fd = open ( fifo_path , O_RDONLY ); if ( read_fifo_fd == - 1 ) ERR_EXIT ( \"open\" ); // fifo for write to bidding system int write_fifo_fd = open ( write_fifo_name , O_WRONLY ); if ( write_fifo_fd == - 1 ) ERR_EXIT ( \"open\" ); // fork 2 child hosts Child child_host_list [ 2 ]; fork_child ( child_host_list , NULL , depth , argv ); while ( 1 ) { int player_id_list [ 8 ]; read_player_id ( player_id_list , 8 , read_fifo_fd ); if ( player_id_list [ 0 ] == - 1 ) { for ( int i = 0 ; i < 2 ; i ++ ) { char * msg = \"-1 -1 -1 -1 \\n \" ; write ( child_host_list [ i ]. wr_pipe_fd , msg , strlen ( msg )); fsync ( child_host_list [ i ]. wr_pipe_fd ); } break ; } // assign players to 2 child hosts for ( int i = 0 ; i < 2 ; i ++ ) { char buf [ BUFSIZ ]; int len = sublist ( player_id_list , i * ( 4 >> depth ), i * ( 4 >> depth ) + ( 4 >> depth ), buf ); write ( child_host_list [ i ]. wr_pipe_fd , buf , len ); fsync ( child_host_list [ i ]. wr_pipe_fd ); } // init player record PlayerRecord player_record_list [ 8 ]; for ( int i = 0 ; i < 8 ; i ++ ) { player_record_list [ i ]. player_id = player_id_list [ i ]; player_record_list [ i ]. score = 0 ; } run_game ( child_host_list , depth , player_record_list ); calc_rank ( player_record_list ); char buf [ BUFSIZ ]; char * p = buf ; p += snprintf ( buf , BUFSIZ , \"%d \\n \" , random_key ); for ( int i = 0 ; i < 8 ; i ++ ) { p += snprintf ( p , BUFSIZ , \"%d %d \\n \" , player_record_list [ i ]. player_id , player_record_list [ i ]. rank ); } write ( write_fifo_fd , buf , strlen ( buf )); fsync ( write_fifo_fd ); } clean_child ( child_host_list ); close ( read_fifo_fd ); close ( write_fifo_fd ); } else if ( depth == CHILD_HOST_DEP ) { Child leaf_host_list [ 2 ]; fork_child ( leaf_host_list , NULL , depth , argv ); while ( 1 ) { int player_id_list [ 4 ]; read_player_id ( player_id_list , 4 , STDIN_FILENO ); if ( player_id_list [ 0 ] == - 1 ) { for ( int i = 0 ; i < 2 ; i ++ ) { char * msg = \"-1 -1 \\n \" ; write ( leaf_host_list [ i ]. wr_pipe_fd , msg , strlen ( msg )); fsync ( leaf_host_list [ i ]. wr_pipe_fd ); } break ; } for ( int i = 0 ; i < 2 ; i ++ ) { char buf [ BUFSIZ ]; int len = sublist ( player_id_list , i * ( 4 >> depth ), i * ( 4 >> depth ) + ( 4 >> depth ), buf ); write ( leaf_host_list [ i ]. wr_pipe_fd , buf , len ); fsync ( leaf_host_list [ i ]. wr_pipe_fd ); } run_game ( leaf_host_list , depth , NULL ); } clean_child ( leaf_host_list ); } else if ( depth == LEAF_HOST_DEP ) { while ( 1 ) { int player_id_list [ 2 ]; read_player_id ( player_id_list , 2 , STDIN_FILENO ); if ( player_id_list [ 0 ] == - 1 ) { break ; } Child player_list [ 2 ]; fork_child ( player_list , player_id_list , depth , argv ); run_game ( player_list , depth , NULL ); clean_child ( player_list ); } } return EXIT_SUCCESS ; } void read_player_id ( int player_id_list [], int n , int fd ) { char buf [ BUFSIZ ]; char * p = buf ; read ( fd , p , BUFSIZ ); for ( int i = 0 ; i < n ; i ++ ) { player_id_list [ i ] = strtol ( p , & p , 10 ); } } int sublist ( int list [], int L , int R , char buf []) { char * ptr = buf ; for ( int i = L ; i < R ; i ++ ) ptr += snprintf ( ptr , BUFSIZ , \"%d%c\" , list [ i ], \" \\n \" [ i == R - 1 ]); return ( ptr - buf ); } void fork_child ( Child child_list [], int player_id_list [], int depth , char * argv []) { for ( int i = 0 ; i < 2 ; i ++ ) { // pipe int pfd [ 2 ][ 2 ]; int pip_res1 = pipe ( pfd [ 0 ]); // parent read, child write int pip_res2 = pipe ( pfd [ 1 ]); // parent write, child read if ( pip_res1 == - 1 || pip_res2 == - 1 ) ERR_EXIT ( \"pipe\" ); // fork child_list [ i ]. pid = fork (); if ( child_list [ i ]. pid == - 1 ) { ERR_EXIT ( \"fork\" ); } else if ( child_list [ i ]. pid == 0 ) { // child close ( pfd [ 0 ][ 0 ]); dup2 ( pfd [ 0 ][ 1 ], 1 ); close ( pfd [ 0 ][ 1 ]); close ( pfd [ 1 ][ 1 ]); dup2 ( pfd [ 1 ][ 0 ], 0 ); close ( pfd [ 1 ][ 0 ]); if ( depth != LEAF_HOST_DEP ) { char next_dep [ 4 ]; snprintf ( next_dep , 4 , \"%d\" , depth + 1 ); execl ( \"./host\" , \"host\" , argv [ 1 ], argv [ 2 ], next_dep , NULL ); } else { char buf [ 4 ]; snprintf ( buf , 4 , \"%d\" , player_id_list [ i ]); execl ( \"./player\" , \"player\" , buf , NULL ); } } else { // parent close ( pfd [ 0 ][ 1 ]); child_list [ i ]. rd_pipe_fd = pfd [ 0 ][ 0 ]; close ( pfd [ 1 ][ 0 ]); child_list [ i ]. wr_pipe_fd = pfd [ 1 ][ 1 ]; } } } void run_game ( Child child_list [], int depth , void * extra ) { PlayerRecord * player_record_list = ( PlayerRecord * ) extra ; int id_2_idx [ 32 ]; for ( int i = 0 ; depth == 0 && i < 8 ; i ++ ) id_2_idx [ player_record_list [ i ]. player_id ] = i ; for ( int round = 1 ; round <= ROUND_NUM ; round ++ ) { // read result from two child hosts int player_id [ 2 ], money [ 2 ]; char buf [ BUFSIZ ]; read ( child_list [ 0 ]. rd_pipe_fd , buf , BUFSIZ ); sscanf ( buf , \"%d %d\" , & player_id [ 0 ], & money [ 0 ]); read ( child_list [ 1 ]. rd_pipe_fd , buf , BUFSIZ ); sscanf ( buf , \"%d %d\" , & player_id [ 1 ], & money [ 1 ]); // compare two results int winner_id , win_money ; if ( money [ 0 ] > money [ 1 ] ) { winner_id = player_id [ 0 ]; win_money = money [ 0 ]; } else { winner_id = player_id [ 1 ]; win_money = money [ 1 ]; } if ( depth == 0 ) { // if dep == 0: update player score and write winner to 2 child ++ player_record_list [ id_2_idx [ winner_id ] ]. score ; if ( round != ROUND_NUM ) { for ( int i = 0 ; i < 2 ; i ++ ) { int len = sprintf ( buf , \"%d \\n \" , winner_id ); write ( child_list [ i ]. wr_pipe_fd , buf , len ); fsync ( child_list [ i ]. wr_pipe_fd ); } } } else { // if dep > 0: write winner, money to stdout and read final winner from stdin and write final winner to 2 child int len = sprintf ( buf , \"%d %d \\n \" , winner_id , win_money ); write ( STDOUT_FILENO , buf , len ); fsync ( STDOUT_FILENO ); if ( round != ROUND_NUM ) { int len = read ( STDIN_FILENO , buf , BUFSIZ ); for ( int i = 0 ; i < 2 ; i ++ ) { write ( child_list [ i ]. wr_pipe_fd , buf , len ); fsync ( child_list [ i ]. wr_pipe_fd ); } } } } } int cmp ( const void * a , const void * b ) { int x = ( * ( PlayerRecord ** ) a ) -> score , y = ( * ( PlayerRecord ** ) b ) -> score ; return ( x < y ) - ( x > y ); } void calc_rank ( PlayerRecord player_record_list []) { PlayerRecord * ptr [ 8 ]; for ( int i = 0 ; i < 8 ; i ++ ) ptr [ i ] = & player_record_list [ i ]; qsort ( ptr , 8 , sizeof ( PlayerRecord * ), cmp ); ptr [ 0 ] -> rank = 1 ; for ( int i = 1 ; i < 8 ; i ++ ) ptr [ i ] -> rank = ( ptr [ i ] -> score == ptr [ i - 1 ] -> score ) ? ptr [ i - 1 ] -> rank : i + 1 ; } void clean_child ( Child child_list []) { for ( int i = 0 ; i < 2 ; i ++ ) { int status ; waitpid ( child_list [ i ]. pid , & status , 0 ); close ( child_list [ i ]. rd_pipe_fd ); close ( child_list [ i ]. wr_pipe_fd ); } }","title":"host.c"},{"location":"courses/sp-fall-2019/programming/hw2/#playerc","text":"#include <unistd.h> #include <stdio.h> #include <stdlib.h> const char * const usage_msg = \"usage: ./player [player_id]\" ; const int ROUND_NUM = 10 ; void ERR_EXIT ( char * msg ) { perror ( msg ); exit ( 128 ); } void flush_fsync ( FILE * stream ) { fflush ( stream ); fsync ( fileno ( stream )); } void read_winner_id () { int winner_id ; scanf ( \"%d\" , & winner_id ); } void tell_host_money ( int player_id , int money ) { printf ( \"%d %d \\n \" , player_id , money ); flush_fsync ( stdout ); } int main ( int argc , char * argv []) { if ( argc != 2 ) { // the number of arguments should be exactly 1 fprintf ( stderr , usage_msg ); exit ( 2 ); } const int player_id = atoi ( argv [ 1 ]); const int money = player_id * 100 ; for ( int round = 1 ; round <= ROUND_NUM ; ++ round ) { if ( round > 1 ) read_winner_id (); tell_host_money ( player_id , money ); } return EXIT_SUCCESS ; }","title":"player.c"},{"location":"courses/sp-fall-2019/programming/hw3/","text":"Programming Assignment #3 \u00b6 Important Techniques Learned in this Homework \u00b6 how to use longjmp() , setjmp() to switch between multiple stack frame without hurting the integrity of data how to use sigprocmask() , sigaction() to manipulate the signal disposition and signal mask report \u00b6 link on github main.c \u00b6 #include <stdlib.h> #include <stdio.h> #include <string.h> #include <unistd.h> #include <signal.h> #include <errno.h> #include <sys/wait.h> #include <time.h> #define MAXR 16 #define SIGUSR3 SIGWINCH #define ERR_EXIT(msg) { char buf[1024]; \\ snprintf(buf, 1024, \"%d, %s\", __LINE__, msg); \\ perror(buf); exit(127); \\ } char buf [ BUFSIZ ]; int mp [ 4 ] = { 0 , SIGUSR1 , SIGUSR2 , SIGUSR3 }; int main () { int P , Q ; scanf ( \"%d %d\" , & P , & Q ); int R ; scanf ( \"%d\" , & R ); int sig [ MAXR ]; for ( int i = 0 ; i < R ; i ++ ) scanf ( \"%d\" , & sig [ i ]); int pfd [ 2 ]; pipe ( pfd ); sigset_t set ; sigemptyset ( & set ); sigaddset ( & set , SIGUSR1 ); sigaddset ( & set , SIGUSR2 ); sigaddset ( & set , SIGUSR3 ); sigprocmask ( SIG_BLOCK , & set , NULL ); pid_t pid = fork (); if ( pid == - 1 ) { ERR_EXIT ( \"fork\" ); } else if ( pid == 0 ) { close ( pfd [ 0 ]); dup2 ( pfd [ 1 ], STDOUT_FILENO ); char arg [ 3 ][ 16 ]; snprintf ( arg [ 1 ], 16 , \"%d\" , P ); snprintf ( arg [ 2 ], 16 , \"%d\" , Q ); execl ( \"./hw3\" , \"./hw3\" , arg [ 1 ], arg [ 2 ], \"3\" , \"0\" , ( char * ) 0 ); } close ( pfd [ 1 ]); for ( int i = 0 ; i < R ; i ++ ) { sleep ( 5 ); kill ( pid , mp [ sig [ i ]]); read ( pfd [ 0 ], buf , BUFSIZ ); if ( sig [ i ] == 3 ) { printf ( \"%s \\n \" , buf ); } } read ( pfd [ 0 ], buf , BUFSIZ ); printf ( \"%s\" , buf ); int status ; waitpid ( pid , & status , 0 ); close ( pfd [ 0 ]); return EXIT_SUCCESS ; } hw3.c \u00b6 #include <stdio.h> #include <stdlib.h> #include <signal.h> #include <setjmp.h> #include <unistd.h> #include <errno.h> #include <string.h> #include \"scheduler.h\" #define SIGUSR3 SIGWINCH #define ERR_EXIT(msg) { char buf[1024]; \\ snprintf(buf, 1024, \"%d, %s\", __LINE__, msg); \\ perror(buf); exit(127); \\ } typedef void ( * sighandler_t )( int ); void funct_5 ( int name ) { int a [ 10000 ]; switch ( name ) { case 1 : funct_1 ( 1 ); break ; case 2 : funct_2 ( 2 ); break ; case 3 : funct_3 ( 3 ); break ; case 4 : funct_4 ( 4 ); break ; default : ERR_EXIT ( \"argument error\" ); } } int P , Q , K , TASK ; int idx = 0 , mutex = 0 ; char arr [ 10000 ]; jmp_buf SCHEDULER ; jmp_buf main_env ; FCB fcb_list [ 5 ]; FCB_ptr Current , Head ; int in_queue [ 5 ]; sigset_t oldset ; void sigusr1_act ( int signo ) { //fprintf(stderr, \"get SIGUSR1\\n\"); char * ACK = \"ACK1\" ; write ( STDOUT_FILENO , ACK , 5 ); sigprocmask ( SIG_SETMASK , & oldset , NULL ); longjmp ( SCHEDULER , 1 ); } void sigusr2_act ( int signo ) { //fprintf(stderr, \"get SIGUSR2\\n\"); char * ACK = \"ACK2\" ; write ( STDOUT_FILENO , ACK , 5 ); sigprocmask ( SIG_SETMASK , & oldset , NULL ); longjmp ( SCHEDULER , 1 ); } void sigusr3_act ( int signo ) { //fprintf(stderr, \"get SIGUSR3\\n\"); char buf [ BUFSIZ ]; char * p = buf ; for ( int i = 1 ; i <= 4 ; i ++ ) { if ( in_queue [ i ] ) { p += sprintf ( p , \"%d \" , i ); } } write ( STDOUT_FILENO , buf , strlen ( buf ) + 1 ); sigprocmask ( SIG_SETMASK , & oldset , NULL ); longjmp ( SCHEDULER , 1 ); } void funct_1 ( int n ) { int sj = setjmp ( fcb_list [ n ]. Environment ); if ( sj < 0 ) { ERR_EXIT ( \"setjmp\" ); } else if ( sj == 0 ) { if ( n != 4 ) funct_5 ( n + 1 ); else // n = 4 longjmp ( main_env , 1 ); } else if ( sj > 0 ) { for ( int i = 1 ; i <= P ; i ++ ) { // check lock while ( 1 ) { if ( mutex != 0 && mutex != n ) { in_queue [ n ] = 1 ; int sj = setjmp ( fcb_list [ n ]. Environment ); if ( sj == 0 ) longjmp ( SCHEDULER , 1 ); } else { break ; } } in_queue [ n ] = 0 ; mutex = n ; // acquire lock for ( int j = 1 ; j <= Q ; j ++ ) { sleep ( 1 ); //fprintf(stderr, \"append %d\\n\", n); arr [ idx ++ ] = '0' + n ; } // For task 2 if ( i % K == 0 ) { mutex = 0 ; // release lock int res = setjmp ( fcb_list [ n ]. Environment ); if ( res < 0 ) { ERR_EXIT ( \"setjmp\" ); } else if ( res == 0 && i != P ) { longjmp ( SCHEDULER , 1 ); } } // For task 3 sigset_t set ; int signo = - 1 ; int res = sigpending ( & set ); if ( sigismember ( & set , SIGUSR1 ) ) { signo = SIGUSR1 ; } else if ( sigismember ( & set , SIGUSR2 ) ) { mutex = 0 ; signo = SIGUSR2 ; } else if ( sigismember ( & set , SIGUSR3 ) ) { Current = Current -> Previous ; signo = SIGUSR3 ; } if ( signo == - 1 ) continue ; if ( setjmp ( fcb_list [ n ]. Environment ) != 0 ) continue ; sigprocmask ( 0 , NULL , & oldset ); sigset_t unblock_set ; sigemptyset ( & unblock_set ); sigaddset ( & unblock_set , signo ); sigprocmask ( SIG_UNBLOCK , & unblock_set , NULL ); } mutex = 0 ; // release lock longjmp ( SCHEDULER , - 2 ); } } void funct_2 ( int n ) { int sj = setjmp ( fcb_list [ n ]. Environment ); if ( sj < 0 ) { ERR_EXIT ( \"setjmp\" ); } else if ( sj == 0 ) { if ( n != 4 ) funct_5 ( n + 1 ); else // n = 4 longjmp ( main_env , 1 ); } else if ( sj > 0 ) { for ( int i = 1 ; i <= P ; i ++ ) { // check lock while ( 1 ) { if ( mutex != 0 && mutex != n ) { in_queue [ n ] = 1 ; int sj = setjmp ( fcb_list [ n ]. Environment ); if ( sj == 0 ) longjmp ( SCHEDULER , 1 ); } else { break ; } } in_queue [ n ] = 0 ; mutex = n ; // acquire lock for ( int j = 1 ; j <= Q ; j ++ ) { sleep ( 1 ); //fprintf(stderr, \"append %d\\n\", n); arr [ idx ++ ] = '0' + n ; } // For task 2 if ( i % K == 0 ) { mutex = 0 ; // release lock int res = setjmp ( fcb_list [ n ]. Environment ); if ( res < 0 ) { ERR_EXIT ( \"setjmp\" ); } else if ( res == 0 && i != P ) { longjmp ( SCHEDULER , 1 ); } } // For task 3 sigset_t set ; int signo = - 1 ; int res = sigpending ( & set ); if ( sigismember ( & set , SIGUSR1 ) ) { signo = SIGUSR1 ; } else if ( sigismember ( & set , SIGUSR2 ) ) { mutex = 0 ; signo = SIGUSR2 ; } else if ( sigismember ( & set , SIGUSR3 ) ) { Current = Current -> Previous ; signo = SIGUSR3 ; } if ( signo == - 1 ) continue ; if ( setjmp ( fcb_list [ n ]. Environment ) != 0 ) continue ; sigprocmask ( 0 , NULL , & oldset ); sigset_t unblock_set ; sigemptyset ( & unblock_set ); sigaddset ( & unblock_set , signo ); sigprocmask ( SIG_UNBLOCK , & unblock_set , NULL ); } mutex = 0 ; // release lock longjmp ( SCHEDULER , - 2 ); } } void funct_3 ( int n ) { int sj = setjmp ( fcb_list [ n ]. Environment ); if ( sj < 0 ) { ERR_EXIT ( \"setjmp\" ); } else if ( sj == 0 ) { if ( n != 4 ) funct_5 ( n + 1 ); else // n = 4 longjmp ( main_env , 1 ); } else if ( sj > 0 ) { for ( int i = 1 ; i <= P ; i ++ ) { // check lock while ( 1 ) { if ( mutex != 0 && mutex != n ) { in_queue [ n ] = 1 ; int sj = setjmp ( fcb_list [ n ]. Environment ); if ( sj == 0 ) longjmp ( SCHEDULER , 1 ); } else { break ; } } in_queue [ n ] = 0 ; mutex = n ; // acquire lock for ( int j = 1 ; j <= Q ; j ++ ) { sleep ( 1 ); //fprintf(stderr, \"append %d\\n\", n); arr [ idx ++ ] = '0' + n ; } // For task 2 if ( i % K == 0 ) { mutex = 0 ; // release lock int res = setjmp ( fcb_list [ n ]. Environment ); if ( res < 0 ) { ERR_EXIT ( \"setjmp\" ); } else if ( res == 0 && i != P ) { longjmp ( SCHEDULER , 1 ); } } // For task 3 sigset_t set ; int signo = - 1 ; int res = sigpending ( & set ); if ( sigismember ( & set , SIGUSR1 ) ) { signo = SIGUSR1 ; } else if ( sigismember ( & set , SIGUSR2 ) ) { mutex = 0 ; signo = SIGUSR2 ; } else if ( sigismember ( & set , SIGUSR3 ) ) { Current = Current -> Previous ; signo = SIGUSR3 ; } if ( signo == - 1 ) continue ; if ( setjmp ( fcb_list [ n ]. Environment ) != 0 ) continue ; sigprocmask ( 0 , NULL , & oldset ); sigset_t unblock_set ; sigemptyset ( & unblock_set ); sigaddset ( & unblock_set , signo ); sigprocmask ( SIG_UNBLOCK , & unblock_set , NULL ); } mutex = 0 ; // release lock longjmp ( SCHEDULER , - 2 ); } } void funct_4 ( int n ) { int sj = setjmp ( fcb_list [ n ]. Environment ); if ( sj < 0 ) { ERR_EXIT ( \"setjmp\" ); } else if ( sj == 0 ) { if ( n != 4 ) funct_5 ( n + 1 ); else // n = 4 longjmp ( main_env , 1 ); } else if ( sj > 0 ) { for ( int i = 1 ; i <= P ; i ++ ) { // check lock while ( 1 ) { if ( mutex != 0 && mutex != n ) { in_queue [ n ] = 1 ; int sj = setjmp ( fcb_list [ n ]. Environment ); if ( sj == 0 ) longjmp ( SCHEDULER , 1 ); } else { break ; } } in_queue [ n ] = 0 ; mutex = n ; // acquire lock for ( int j = 1 ; j <= Q ; j ++ ) { sleep ( 1 ); //fprintf(stderr, \"append %d\\n\", n); arr [ idx ++ ] = '0' + n ; } // For task 2 if ( i % K == 0 ) { mutex = 0 ; // release lock int res = setjmp ( fcb_list [ n ]. Environment ); if ( res < 0 ) { ERR_EXIT ( \"setjmp\" ); } else if ( res == 0 && i != P ) { longjmp ( SCHEDULER , 1 ); } } // For task 3 sigset_t set ; int signo = - 1 ; int res = sigpending ( & set ); if ( sigismember ( & set , SIGUSR1 ) ) { signo = SIGUSR1 ; } else if ( sigismember ( & set , SIGUSR2 ) ) { mutex = 0 ; signo = SIGUSR2 ; } else if ( sigismember ( & set , SIGUSR3 ) ) { Current = Current -> Previous ; signo = SIGUSR3 ; } if ( signo == - 1 ) continue ; if ( setjmp ( fcb_list [ n ]. Environment ) != 0 ) continue ; sigprocmask ( 0 , NULL , & oldset ); sigset_t unblock_set ; sigemptyset ( & unblock_set ); sigaddset ( & unblock_set , signo ); sigprocmask ( SIG_UNBLOCK , & unblock_set , NULL ); } mutex = 0 ; // release lock longjmp ( SCHEDULER , - 2 ); } } void build_linked_list () { Head = & fcb_list [ 1 ]; for ( int i = 1 ; i <= 4 ; i ++ ) { fcb_list [ i ]. Name = i ; fcb_list [ i ]. Next = & fcb_list [ i == 4 ? 1 : i + 1 ]; fcb_list [ i ]. Previous = & fcb_list [ i == 1 ? 4 : i - 1 ]; } Current = & fcb_list [ 4 ]; } void set_action ( int signo , sighandler_t handler ) { struct sigaction act ; act . sa_handler = handler ; sigemptyset ( & act . sa_mask ); act . sa_flags = 0 ; if ( sigaction ( signo , & act , NULL ) < 0 ) ERR_EXIT ( \"sigaction\" ); } int main ( int argc , char * argv []) { if ( argc != 5 ) ERR_EXIT ( \"wrong number of arguments\" ); P = atoi ( argv [ 1 ]); Q = atoi ( argv [ 2 ]); TASK = atoi ( argv [ 3 ]); K = ( TASK == 2 ) ? atoi ( argv [ 4 ]) : 1000000007 ; if ( setjmp ( main_env ) == 0 ) funct_5 ( 1 ); build_linked_list (); set_action ( SIGUSR1 , sigusr1_act ); set_action ( SIGUSR2 , sigusr2_act ); set_action ( SIGUSR3 , sigusr3_act ); Scheduler (); }","title":"Programming Assignment #3"},{"location":"courses/sp-fall-2019/programming/hw3/#programming-assignment-3","text":"","title":"Programming Assignment #3"},{"location":"courses/sp-fall-2019/programming/hw3/#important-techniques-learned-in-this-homework","text":"how to use longjmp() , setjmp() to switch between multiple stack frame without hurting the integrity of data how to use sigprocmask() , sigaction() to manipulate the signal disposition and signal mask","title":"Important Techniques Learned in this Homework"},{"location":"courses/sp-fall-2019/programming/hw3/#report","text":"link on github","title":"report"},{"location":"courses/sp-fall-2019/programming/hw3/#mainc","text":"#include <stdlib.h> #include <stdio.h> #include <string.h> #include <unistd.h> #include <signal.h> #include <errno.h> #include <sys/wait.h> #include <time.h> #define MAXR 16 #define SIGUSR3 SIGWINCH #define ERR_EXIT(msg) { char buf[1024]; \\ snprintf(buf, 1024, \"%d, %s\", __LINE__, msg); \\ perror(buf); exit(127); \\ } char buf [ BUFSIZ ]; int mp [ 4 ] = { 0 , SIGUSR1 , SIGUSR2 , SIGUSR3 }; int main () { int P , Q ; scanf ( \"%d %d\" , & P , & Q ); int R ; scanf ( \"%d\" , & R ); int sig [ MAXR ]; for ( int i = 0 ; i < R ; i ++ ) scanf ( \"%d\" , & sig [ i ]); int pfd [ 2 ]; pipe ( pfd ); sigset_t set ; sigemptyset ( & set ); sigaddset ( & set , SIGUSR1 ); sigaddset ( & set , SIGUSR2 ); sigaddset ( & set , SIGUSR3 ); sigprocmask ( SIG_BLOCK , & set , NULL ); pid_t pid = fork (); if ( pid == - 1 ) { ERR_EXIT ( \"fork\" ); } else if ( pid == 0 ) { close ( pfd [ 0 ]); dup2 ( pfd [ 1 ], STDOUT_FILENO ); char arg [ 3 ][ 16 ]; snprintf ( arg [ 1 ], 16 , \"%d\" , P ); snprintf ( arg [ 2 ], 16 , \"%d\" , Q ); execl ( \"./hw3\" , \"./hw3\" , arg [ 1 ], arg [ 2 ], \"3\" , \"0\" , ( char * ) 0 ); } close ( pfd [ 1 ]); for ( int i = 0 ; i < R ; i ++ ) { sleep ( 5 ); kill ( pid , mp [ sig [ i ]]); read ( pfd [ 0 ], buf , BUFSIZ ); if ( sig [ i ] == 3 ) { printf ( \"%s \\n \" , buf ); } } read ( pfd [ 0 ], buf , BUFSIZ ); printf ( \"%s\" , buf ); int status ; waitpid ( pid , & status , 0 ); close ( pfd [ 0 ]); return EXIT_SUCCESS ; }","title":"main.c"},{"location":"courses/sp-fall-2019/programming/hw3/#hw3c","text":"#include <stdio.h> #include <stdlib.h> #include <signal.h> #include <setjmp.h> #include <unistd.h> #include <errno.h> #include <string.h> #include \"scheduler.h\" #define SIGUSR3 SIGWINCH #define ERR_EXIT(msg) { char buf[1024]; \\ snprintf(buf, 1024, \"%d, %s\", __LINE__, msg); \\ perror(buf); exit(127); \\ } typedef void ( * sighandler_t )( int ); void funct_5 ( int name ) { int a [ 10000 ]; switch ( name ) { case 1 : funct_1 ( 1 ); break ; case 2 : funct_2 ( 2 ); break ; case 3 : funct_3 ( 3 ); break ; case 4 : funct_4 ( 4 ); break ; default : ERR_EXIT ( \"argument error\" ); } } int P , Q , K , TASK ; int idx = 0 , mutex = 0 ; char arr [ 10000 ]; jmp_buf SCHEDULER ; jmp_buf main_env ; FCB fcb_list [ 5 ]; FCB_ptr Current , Head ; int in_queue [ 5 ]; sigset_t oldset ; void sigusr1_act ( int signo ) { //fprintf(stderr, \"get SIGUSR1\\n\"); char * ACK = \"ACK1\" ; write ( STDOUT_FILENO , ACK , 5 ); sigprocmask ( SIG_SETMASK , & oldset , NULL ); longjmp ( SCHEDULER , 1 ); } void sigusr2_act ( int signo ) { //fprintf(stderr, \"get SIGUSR2\\n\"); char * ACK = \"ACK2\" ; write ( STDOUT_FILENO , ACK , 5 ); sigprocmask ( SIG_SETMASK , & oldset , NULL ); longjmp ( SCHEDULER , 1 ); } void sigusr3_act ( int signo ) { //fprintf(stderr, \"get SIGUSR3\\n\"); char buf [ BUFSIZ ]; char * p = buf ; for ( int i = 1 ; i <= 4 ; i ++ ) { if ( in_queue [ i ] ) { p += sprintf ( p , \"%d \" , i ); } } write ( STDOUT_FILENO , buf , strlen ( buf ) + 1 ); sigprocmask ( SIG_SETMASK , & oldset , NULL ); longjmp ( SCHEDULER , 1 ); } void funct_1 ( int n ) { int sj = setjmp ( fcb_list [ n ]. Environment ); if ( sj < 0 ) { ERR_EXIT ( \"setjmp\" ); } else if ( sj == 0 ) { if ( n != 4 ) funct_5 ( n + 1 ); else // n = 4 longjmp ( main_env , 1 ); } else if ( sj > 0 ) { for ( int i = 1 ; i <= P ; i ++ ) { // check lock while ( 1 ) { if ( mutex != 0 && mutex != n ) { in_queue [ n ] = 1 ; int sj = setjmp ( fcb_list [ n ]. Environment ); if ( sj == 0 ) longjmp ( SCHEDULER , 1 ); } else { break ; } } in_queue [ n ] = 0 ; mutex = n ; // acquire lock for ( int j = 1 ; j <= Q ; j ++ ) { sleep ( 1 ); //fprintf(stderr, \"append %d\\n\", n); arr [ idx ++ ] = '0' + n ; } // For task 2 if ( i % K == 0 ) { mutex = 0 ; // release lock int res = setjmp ( fcb_list [ n ]. Environment ); if ( res < 0 ) { ERR_EXIT ( \"setjmp\" ); } else if ( res == 0 && i != P ) { longjmp ( SCHEDULER , 1 ); } } // For task 3 sigset_t set ; int signo = - 1 ; int res = sigpending ( & set ); if ( sigismember ( & set , SIGUSR1 ) ) { signo = SIGUSR1 ; } else if ( sigismember ( & set , SIGUSR2 ) ) { mutex = 0 ; signo = SIGUSR2 ; } else if ( sigismember ( & set , SIGUSR3 ) ) { Current = Current -> Previous ; signo = SIGUSR3 ; } if ( signo == - 1 ) continue ; if ( setjmp ( fcb_list [ n ]. Environment ) != 0 ) continue ; sigprocmask ( 0 , NULL , & oldset ); sigset_t unblock_set ; sigemptyset ( & unblock_set ); sigaddset ( & unblock_set , signo ); sigprocmask ( SIG_UNBLOCK , & unblock_set , NULL ); } mutex = 0 ; // release lock longjmp ( SCHEDULER , - 2 ); } } void funct_2 ( int n ) { int sj = setjmp ( fcb_list [ n ]. Environment ); if ( sj < 0 ) { ERR_EXIT ( \"setjmp\" ); } else if ( sj == 0 ) { if ( n != 4 ) funct_5 ( n + 1 ); else // n = 4 longjmp ( main_env , 1 ); } else if ( sj > 0 ) { for ( int i = 1 ; i <= P ; i ++ ) { // check lock while ( 1 ) { if ( mutex != 0 && mutex != n ) { in_queue [ n ] = 1 ; int sj = setjmp ( fcb_list [ n ]. Environment ); if ( sj == 0 ) longjmp ( SCHEDULER , 1 ); } else { break ; } } in_queue [ n ] = 0 ; mutex = n ; // acquire lock for ( int j = 1 ; j <= Q ; j ++ ) { sleep ( 1 ); //fprintf(stderr, \"append %d\\n\", n); arr [ idx ++ ] = '0' + n ; } // For task 2 if ( i % K == 0 ) { mutex = 0 ; // release lock int res = setjmp ( fcb_list [ n ]. Environment ); if ( res < 0 ) { ERR_EXIT ( \"setjmp\" ); } else if ( res == 0 && i != P ) { longjmp ( SCHEDULER , 1 ); } } // For task 3 sigset_t set ; int signo = - 1 ; int res = sigpending ( & set ); if ( sigismember ( & set , SIGUSR1 ) ) { signo = SIGUSR1 ; } else if ( sigismember ( & set , SIGUSR2 ) ) { mutex = 0 ; signo = SIGUSR2 ; } else if ( sigismember ( & set , SIGUSR3 ) ) { Current = Current -> Previous ; signo = SIGUSR3 ; } if ( signo == - 1 ) continue ; if ( setjmp ( fcb_list [ n ]. Environment ) != 0 ) continue ; sigprocmask ( 0 , NULL , & oldset ); sigset_t unblock_set ; sigemptyset ( & unblock_set ); sigaddset ( & unblock_set , signo ); sigprocmask ( SIG_UNBLOCK , & unblock_set , NULL ); } mutex = 0 ; // release lock longjmp ( SCHEDULER , - 2 ); } } void funct_3 ( int n ) { int sj = setjmp ( fcb_list [ n ]. Environment ); if ( sj < 0 ) { ERR_EXIT ( \"setjmp\" ); } else if ( sj == 0 ) { if ( n != 4 ) funct_5 ( n + 1 ); else // n = 4 longjmp ( main_env , 1 ); } else if ( sj > 0 ) { for ( int i = 1 ; i <= P ; i ++ ) { // check lock while ( 1 ) { if ( mutex != 0 && mutex != n ) { in_queue [ n ] = 1 ; int sj = setjmp ( fcb_list [ n ]. Environment ); if ( sj == 0 ) longjmp ( SCHEDULER , 1 ); } else { break ; } } in_queue [ n ] = 0 ; mutex = n ; // acquire lock for ( int j = 1 ; j <= Q ; j ++ ) { sleep ( 1 ); //fprintf(stderr, \"append %d\\n\", n); arr [ idx ++ ] = '0' + n ; } // For task 2 if ( i % K == 0 ) { mutex = 0 ; // release lock int res = setjmp ( fcb_list [ n ]. Environment ); if ( res < 0 ) { ERR_EXIT ( \"setjmp\" ); } else if ( res == 0 && i != P ) { longjmp ( SCHEDULER , 1 ); } } // For task 3 sigset_t set ; int signo = - 1 ; int res = sigpending ( & set ); if ( sigismember ( & set , SIGUSR1 ) ) { signo = SIGUSR1 ; } else if ( sigismember ( & set , SIGUSR2 ) ) { mutex = 0 ; signo = SIGUSR2 ; } else if ( sigismember ( & set , SIGUSR3 ) ) { Current = Current -> Previous ; signo = SIGUSR3 ; } if ( signo == - 1 ) continue ; if ( setjmp ( fcb_list [ n ]. Environment ) != 0 ) continue ; sigprocmask ( 0 , NULL , & oldset ); sigset_t unblock_set ; sigemptyset ( & unblock_set ); sigaddset ( & unblock_set , signo ); sigprocmask ( SIG_UNBLOCK , & unblock_set , NULL ); } mutex = 0 ; // release lock longjmp ( SCHEDULER , - 2 ); } } void funct_4 ( int n ) { int sj = setjmp ( fcb_list [ n ]. Environment ); if ( sj < 0 ) { ERR_EXIT ( \"setjmp\" ); } else if ( sj == 0 ) { if ( n != 4 ) funct_5 ( n + 1 ); else // n = 4 longjmp ( main_env , 1 ); } else if ( sj > 0 ) { for ( int i = 1 ; i <= P ; i ++ ) { // check lock while ( 1 ) { if ( mutex != 0 && mutex != n ) { in_queue [ n ] = 1 ; int sj = setjmp ( fcb_list [ n ]. Environment ); if ( sj == 0 ) longjmp ( SCHEDULER , 1 ); } else { break ; } } in_queue [ n ] = 0 ; mutex = n ; // acquire lock for ( int j = 1 ; j <= Q ; j ++ ) { sleep ( 1 ); //fprintf(stderr, \"append %d\\n\", n); arr [ idx ++ ] = '0' + n ; } // For task 2 if ( i % K == 0 ) { mutex = 0 ; // release lock int res = setjmp ( fcb_list [ n ]. Environment ); if ( res < 0 ) { ERR_EXIT ( \"setjmp\" ); } else if ( res == 0 && i != P ) { longjmp ( SCHEDULER , 1 ); } } // For task 3 sigset_t set ; int signo = - 1 ; int res = sigpending ( & set ); if ( sigismember ( & set , SIGUSR1 ) ) { signo = SIGUSR1 ; } else if ( sigismember ( & set , SIGUSR2 ) ) { mutex = 0 ; signo = SIGUSR2 ; } else if ( sigismember ( & set , SIGUSR3 ) ) { Current = Current -> Previous ; signo = SIGUSR3 ; } if ( signo == - 1 ) continue ; if ( setjmp ( fcb_list [ n ]. Environment ) != 0 ) continue ; sigprocmask ( 0 , NULL , & oldset ); sigset_t unblock_set ; sigemptyset ( & unblock_set ); sigaddset ( & unblock_set , signo ); sigprocmask ( SIG_UNBLOCK , & unblock_set , NULL ); } mutex = 0 ; // release lock longjmp ( SCHEDULER , - 2 ); } } void build_linked_list () { Head = & fcb_list [ 1 ]; for ( int i = 1 ; i <= 4 ; i ++ ) { fcb_list [ i ]. Name = i ; fcb_list [ i ]. Next = & fcb_list [ i == 4 ? 1 : i + 1 ]; fcb_list [ i ]. Previous = & fcb_list [ i == 1 ? 4 : i - 1 ]; } Current = & fcb_list [ 4 ]; } void set_action ( int signo , sighandler_t handler ) { struct sigaction act ; act . sa_handler = handler ; sigemptyset ( & act . sa_mask ); act . sa_flags = 0 ; if ( sigaction ( signo , & act , NULL ) < 0 ) ERR_EXIT ( \"sigaction\" ); } int main ( int argc , char * argv []) { if ( argc != 5 ) ERR_EXIT ( \"wrong number of arguments\" ); P = atoi ( argv [ 1 ]); Q = atoi ( argv [ 2 ]); TASK = atoi ( argv [ 3 ]); K = ( TASK == 2 ) ? atoi ( argv [ 4 ]) : 1000000007 ; if ( setjmp ( main_env ) == 0 ) funct_5 ( 1 ); build_linked_list (); set_action ( SIGUSR1 , sigusr1_act ); set_action ( SIGUSR2 , sigusr2_act ); set_action ( SIGUSR3 , sigusr3_act ); Scheduler (); }","title":"hw3.c"},{"location":"courses/sp-fall-2019/programming/hw4/","text":"Programming Assignment #4 \u00b6 Important Techniques Learned in this Homework \u00b6 how to use pthread library (mainly pthread_create , pthread_join , pthread_exit ) how to write cache-friendly program report \u00b6 link on github hw4.c \u00b6 #include <stdlib.h> #include <stdio.h> #include <string.h> #include <math.h> #include <pthread.h> #include <assert.h> void err_exit ( char * msg ) { fprintf ( stderr , \"%s \\n \" , msg ); exit ( 128 ); } int min ( int a , int b ) { return a < b ? a : b ; } const double INIT_LR = 0.1 ; const int UPD_L = 45 ; int UPD = 100 ; #define TRAIN_N 60000 #define TEST_N 10000 #define PICSZ 784 #define K 10 unsigned char X_train [ TRAIN_N ][ PICSZ ], X_test [ TEST_N ][ PICSZ ]; unsigned char Y_train [ TRAIN_N ]; int Y_test [ TEST_N ]; double X [ TRAIN_N ][ PICSZ ], XT [ PICSZ ][ TRAIN_N ], Xtest [ TEST_N ][ PICSZ ]; double y [ TRAIN_N ][ K ], yhat [ TRAIN_N ][ K ]; double W [ PICSZ ][ K ], Wg [ PICSZ ][ K ], Wf [ PICSZ ][ K ]; int thread_n ; int R ; void softmax ( int row_n ) { for ( int i = 0 ; i < row_n ; ++ i ) { double tmp [ K ]; for ( int k = 0 ; k < K ; ++ k ) tmp [ k ] = yhat [ i ][ k ]; for ( int j = 0 ; j < K ; ++ j ) { double sum = 0.0 ; for ( int k = 0 ; k < K ; ++ k ) sum += exp ( tmp [ k ] - tmp [ j ]); yhat [ i ][ j ] = 1.0 / sum ; } } } double calc_accuracy () { int correct = 0 ; for ( int i = 0 ; i < TRAIN_N ; ++ i ) { int p = 0 ; double v = yhat [ i ][ 0 ]; for ( int k = 1 ; k < K ; ++ k ) if ( yhat [ i ][ k ] > v ) p = k , v = yhat [ i ][ k ]; if ( p == Y_train [ i ] ) ++ correct ; } return ( double ) correct / TRAIN_N ; } void * XT_mul_err_r ( void * arg ) { int id = ( int ) arg ; int start_row = id * R , end_row = min ( id * R + R , PICSZ ); for ( int i = start_row ; i < end_row ; ++ i ) for ( int k = 0 ; k < TRAIN_N ; ++ k ) for ( int j = 0 ; j < K ; ++ j ) Wg [ i ][ j ] += XT [ i ][ k ] * yhat [ k ][ j ]; } void XT_mul_err () { memset ( Wg , 0 , sizeof ( Wg )); R = PICSZ / thread_n + !! ( PICSZ % thread_n ); pthread_t tid [ thread_n ]; for ( int i = 0 ; i < thread_n ; ++ i ) pthread_create ( & tid [ i ], NULL , XT_mul_err_r , ( void * ) i ); void * ret ; for ( int i = 0 ; i < thread_n ; ++ i ) pthread_join ( tid [ i ], & ret ); } void * X_mul_W_r ( void * arg ) { int id = ( int ) arg ; int start_row = id * R , end_row = min ( id * R + R , TRAIN_N ); for ( int i = start_row ; i < end_row ; ++ i ) for ( int k = 0 ; k < PICSZ ; ++ k ) for ( int j = 0 ; j < K ; ++ j ) yhat [ i ][ j ] += X [ i ][ k ] * W [ k ][ j ]; } void X_mul_W () { memset ( yhat , 0 , sizeof ( yhat )); R = TRAIN_N / thread_n + !! ( TRAIN_N % thread_n ); pthread_t tid [ thread_n ]; for ( int i = 0 ; i < thread_n ; ++ i ) pthread_create ( & tid [ i ], NULL , X_mul_W_r , ( void * ) i ); void * ret ; for ( int i = 0 ; i < thread_n ; ++ i ) pthread_join ( tid [ i ], & ret ); } void train () { double drop = 0.8 , epochs_drop = 20.0 ; double lr = INIT_LR ; for ( int epoch = 0 ; epoch < UPD ; ++ epoch ) { X_mul_W (); softmax ( TRAIN_N ); //double acc = calc_accuracy(); //fprintf(stderr, \"%d: %lf\\n\", epoch, acc); for ( int i = 0 ; i < TRAIN_N ; ++ i ) for ( int j = 0 ; j < K ; ++ j ) yhat [ i ][ j ] -= y [ i ][ j ]; XT_mul_err (); for ( int i = 0 ; i < PICSZ ; ++ i ) for ( int j = 0 ; j < K ; ++ j ) W [ i ][ j ] -= lr * Wg [ i ][ j ]; lr = INIT_LR * pow ( drop , floor (( 1 + epoch ) / epochs_drop )); } memcpy ( Wf , W , sizeof ( W )); } void * Xtest_mul_W_r ( void * arg ) { int id = ( int ) arg ; int start_row = id * R , end_row = min ( id * R + R , TEST_N ); for ( int i = start_row ; i < end_row ; ++ i ) for ( int j = 0 ; j < K ; ++ j ) for ( int k = 0 ; k < PICSZ ; ++ k ) yhat [ i ][ j ] += Xtest [ i ][ k ] * Wf [ k ][ j ]; } void Xtest_mul_W () { memset ( yhat , 0 , sizeof ( yhat )); R = TEST_N / thread_n + !! ( TEST_N % thread_n ); pthread_t tid [ thread_n ]; for ( int i = 0 ; i < thread_n ; ++ i ) pthread_create ( & tid [ i ], NULL , Xtest_mul_W_r , ( void * ) i ); void * ret ; for ( int i = 0 ; i < thread_n ; ++ i ) pthread_join ( tid [ i ], & ret ); } void predict () { Xtest_mul_W (); softmax ( TEST_N ); for ( int i = 0 ; i < TEST_N ; i ++ ) { int p = 0 ; double v = yhat [ i ][ 0 ]; for ( int k = 1 ; k < K ; k ++ ) if ( yhat [ i ][ k ] > v ) p = k , v = yhat [ i ][ k ]; Y_test [ i ] = p ; } } void write_result () { FILE * fp_output = fopen ( \"result.csv\" , \"w\" ); fprintf ( fp_output , \"id,label \\n \" ); for ( int i = 0 ; i < TEST_N ; i ++ ) fprintf ( fp_output , \"%d,%d \\n \" , i , Y_test [ i ]); fclose ( fp_output ); } int main ( int argc , char * argv []) { if ( argc != 5 ) err_exit ( \"wrong number of argument\" ); FILE * fp_x_train = fopen ( argv [ 1 ], \"rb\" ); FILE * fp_y_train = fopen ( argv [ 2 ], \"rb\" ); FILE * fp_x_test = fopen ( argv [ 3 ], \"rb\" ); thread_n = atoi ( argv [ 4 ]); if ( thread_n <= 5 ) UPD = UPD_L ; for ( int i = 0 ; i < TRAIN_N ; i ++ ) if ( fread ( X_train [ i ], 1 , PICSZ , fp_x_train ) != PICSZ ) err_exit ( \"data reading error\" ); for ( int i = 0 ; i < TRAIN_N ; i ++ ) for ( int j = 0 ; j < PICSZ ; j ++ ) X [ i ][ j ] = XT [ j ][ i ] = ( double ) X_train [ i ][ j ]; if ( fread ( Y_train , 1 , TRAIN_N , fp_y_train ) != TRAIN_N ) err_exit ( \"data reading error\" ); for ( int i = 0 ; i < TRAIN_N ; i ++ ) y [ i ][ Y_train [ i ] ] = 1.0 ; for ( int i = 0 ; i < TEST_N ; i ++ ) if ( fread ( X_test [ i ], 1 , PICSZ , fp_x_test ) != PICSZ ) err_exit ( \"data reading error\" ); for ( int i = 0 ; i < TEST_N ; i ++ ) for ( int j = 0 ; j < PICSZ ; j ++ ) Xtest [ i ][ j ] = ( double ) X_test [ i ][ j ]; train (); predict (); write_result (); return EXIT_SUCCESS ; }","title":"Programming Assignment #4"},{"location":"courses/sp-fall-2019/programming/hw4/#programming-assignment-4","text":"","title":"Programming Assignment #4"},{"location":"courses/sp-fall-2019/programming/hw4/#important-techniques-learned-in-this-homework","text":"how to use pthread library (mainly pthread_create , pthread_join , pthread_exit ) how to write cache-friendly program","title":"Important Techniques Learned in this Homework"},{"location":"courses/sp-fall-2019/programming/hw4/#report","text":"link on github","title":"report"},{"location":"courses/sp-fall-2019/programming/hw4/#hw4c","text":"#include <stdlib.h> #include <stdio.h> #include <string.h> #include <math.h> #include <pthread.h> #include <assert.h> void err_exit ( char * msg ) { fprintf ( stderr , \"%s \\n \" , msg ); exit ( 128 ); } int min ( int a , int b ) { return a < b ? a : b ; } const double INIT_LR = 0.1 ; const int UPD_L = 45 ; int UPD = 100 ; #define TRAIN_N 60000 #define TEST_N 10000 #define PICSZ 784 #define K 10 unsigned char X_train [ TRAIN_N ][ PICSZ ], X_test [ TEST_N ][ PICSZ ]; unsigned char Y_train [ TRAIN_N ]; int Y_test [ TEST_N ]; double X [ TRAIN_N ][ PICSZ ], XT [ PICSZ ][ TRAIN_N ], Xtest [ TEST_N ][ PICSZ ]; double y [ TRAIN_N ][ K ], yhat [ TRAIN_N ][ K ]; double W [ PICSZ ][ K ], Wg [ PICSZ ][ K ], Wf [ PICSZ ][ K ]; int thread_n ; int R ; void softmax ( int row_n ) { for ( int i = 0 ; i < row_n ; ++ i ) { double tmp [ K ]; for ( int k = 0 ; k < K ; ++ k ) tmp [ k ] = yhat [ i ][ k ]; for ( int j = 0 ; j < K ; ++ j ) { double sum = 0.0 ; for ( int k = 0 ; k < K ; ++ k ) sum += exp ( tmp [ k ] - tmp [ j ]); yhat [ i ][ j ] = 1.0 / sum ; } } } double calc_accuracy () { int correct = 0 ; for ( int i = 0 ; i < TRAIN_N ; ++ i ) { int p = 0 ; double v = yhat [ i ][ 0 ]; for ( int k = 1 ; k < K ; ++ k ) if ( yhat [ i ][ k ] > v ) p = k , v = yhat [ i ][ k ]; if ( p == Y_train [ i ] ) ++ correct ; } return ( double ) correct / TRAIN_N ; } void * XT_mul_err_r ( void * arg ) { int id = ( int ) arg ; int start_row = id * R , end_row = min ( id * R + R , PICSZ ); for ( int i = start_row ; i < end_row ; ++ i ) for ( int k = 0 ; k < TRAIN_N ; ++ k ) for ( int j = 0 ; j < K ; ++ j ) Wg [ i ][ j ] += XT [ i ][ k ] * yhat [ k ][ j ]; } void XT_mul_err () { memset ( Wg , 0 , sizeof ( Wg )); R = PICSZ / thread_n + !! ( PICSZ % thread_n ); pthread_t tid [ thread_n ]; for ( int i = 0 ; i < thread_n ; ++ i ) pthread_create ( & tid [ i ], NULL , XT_mul_err_r , ( void * ) i ); void * ret ; for ( int i = 0 ; i < thread_n ; ++ i ) pthread_join ( tid [ i ], & ret ); } void * X_mul_W_r ( void * arg ) { int id = ( int ) arg ; int start_row = id * R , end_row = min ( id * R + R , TRAIN_N ); for ( int i = start_row ; i < end_row ; ++ i ) for ( int k = 0 ; k < PICSZ ; ++ k ) for ( int j = 0 ; j < K ; ++ j ) yhat [ i ][ j ] += X [ i ][ k ] * W [ k ][ j ]; } void X_mul_W () { memset ( yhat , 0 , sizeof ( yhat )); R = TRAIN_N / thread_n + !! ( TRAIN_N % thread_n ); pthread_t tid [ thread_n ]; for ( int i = 0 ; i < thread_n ; ++ i ) pthread_create ( & tid [ i ], NULL , X_mul_W_r , ( void * ) i ); void * ret ; for ( int i = 0 ; i < thread_n ; ++ i ) pthread_join ( tid [ i ], & ret ); } void train () { double drop = 0.8 , epochs_drop = 20.0 ; double lr = INIT_LR ; for ( int epoch = 0 ; epoch < UPD ; ++ epoch ) { X_mul_W (); softmax ( TRAIN_N ); //double acc = calc_accuracy(); //fprintf(stderr, \"%d: %lf\\n\", epoch, acc); for ( int i = 0 ; i < TRAIN_N ; ++ i ) for ( int j = 0 ; j < K ; ++ j ) yhat [ i ][ j ] -= y [ i ][ j ]; XT_mul_err (); for ( int i = 0 ; i < PICSZ ; ++ i ) for ( int j = 0 ; j < K ; ++ j ) W [ i ][ j ] -= lr * Wg [ i ][ j ]; lr = INIT_LR * pow ( drop , floor (( 1 + epoch ) / epochs_drop )); } memcpy ( Wf , W , sizeof ( W )); } void * Xtest_mul_W_r ( void * arg ) { int id = ( int ) arg ; int start_row = id * R , end_row = min ( id * R + R , TEST_N ); for ( int i = start_row ; i < end_row ; ++ i ) for ( int j = 0 ; j < K ; ++ j ) for ( int k = 0 ; k < PICSZ ; ++ k ) yhat [ i ][ j ] += Xtest [ i ][ k ] * Wf [ k ][ j ]; } void Xtest_mul_W () { memset ( yhat , 0 , sizeof ( yhat )); R = TEST_N / thread_n + !! ( TEST_N % thread_n ); pthread_t tid [ thread_n ]; for ( int i = 0 ; i < thread_n ; ++ i ) pthread_create ( & tid [ i ], NULL , Xtest_mul_W_r , ( void * ) i ); void * ret ; for ( int i = 0 ; i < thread_n ; ++ i ) pthread_join ( tid [ i ], & ret ); } void predict () { Xtest_mul_W (); softmax ( TEST_N ); for ( int i = 0 ; i < TEST_N ; i ++ ) { int p = 0 ; double v = yhat [ i ][ 0 ]; for ( int k = 1 ; k < K ; k ++ ) if ( yhat [ i ][ k ] > v ) p = k , v = yhat [ i ][ k ]; Y_test [ i ] = p ; } } void write_result () { FILE * fp_output = fopen ( \"result.csv\" , \"w\" ); fprintf ( fp_output , \"id,label \\n \" ); for ( int i = 0 ; i < TEST_N ; i ++ ) fprintf ( fp_output , \"%d,%d \\n \" , i , Y_test [ i ]); fclose ( fp_output ); } int main ( int argc , char * argv []) { if ( argc != 5 ) err_exit ( \"wrong number of argument\" ); FILE * fp_x_train = fopen ( argv [ 1 ], \"rb\" ); FILE * fp_y_train = fopen ( argv [ 2 ], \"rb\" ); FILE * fp_x_test = fopen ( argv [ 3 ], \"rb\" ); thread_n = atoi ( argv [ 4 ]); if ( thread_n <= 5 ) UPD = UPD_L ; for ( int i = 0 ; i < TRAIN_N ; i ++ ) if ( fread ( X_train [ i ], 1 , PICSZ , fp_x_train ) != PICSZ ) err_exit ( \"data reading error\" ); for ( int i = 0 ; i < TRAIN_N ; i ++ ) for ( int j = 0 ; j < PICSZ ; j ++ ) X [ i ][ j ] = XT [ j ][ i ] = ( double ) X_train [ i ][ j ]; if ( fread ( Y_train , 1 , TRAIN_N , fp_y_train ) != TRAIN_N ) err_exit ( \"data reading error\" ); for ( int i = 0 ; i < TRAIN_N ; i ++ ) y [ i ][ Y_train [ i ] ] = 1.0 ; for ( int i = 0 ; i < TEST_N ; i ++ ) if ( fread ( X_test [ i ], 1 , PICSZ , fp_x_test ) != PICSZ ) err_exit ( \"data reading error\" ); for ( int i = 0 ; i < TEST_N ; i ++ ) for ( int j = 0 ; j < PICSZ ; j ++ ) Xtest [ i ][ j ] = ( double ) X_test [ i ][ j ]; train (); predict (); write_result (); return EXIT_SUCCESS ; }","title":"hw4.c"},{"location":"misc/","text":"Miscellaneous \u00b6 Kubuntu installation note","title":"Miscellaneous"},{"location":"misc/#miscellaneous","text":"Kubuntu installation note","title":"Miscellaneous"},{"location":"misc/kubuntu-installation-note/","text":"Kubuntu Installation Note \u00b6 Because I frequently mess up my operating system, plus I am so bad at debugging Linux issues, I usually just resort to reinstallation . So to minimize the time wasted, I make this note.... set terminal shortcut \u00b6 System Settings -> Shortcuts -> custom shortcut -> edit -> new .... action is \"konsole\" (lowercase) install chrome \u00b6 Just do it Set Chrome as default browser \u00b6 update : the easy way: create a temporary html file, right click -> file extension setting -> change the priority Beside the one in System Setting, run: xdg-mime default google-chrome.desktop text/html Check ~/.config/mimeapps.list install packages \u00b6 vim wget curl build-essential git zsh exfat-fuse exfat-utils tmux python3-pip sudo apt install vim wget curl build-essential git zsh exfat-fuse exfat-utils tmux python3-pip dotfiles \u00b6 .profile .tmux.conf .vimrc generate ssh key and deploy \u00b6 ssh-keygen && ssh-copy-id b07902075@linux1.csie.org add ssh key to github clone repo \u00b6 Just do it install vscode \u00b6 extensions: material theme(dark), git lens install chinese pinyin input method (fcitx + google-pinyin) \u00b6 Install required packages sudo apt install fcitx-bin fcitx-config-gtk2 fcitx-frontend-qt4 fcitx-frontend-qt5 fcitx-googlepinyin fcitx-imlist fcitx-module-dbus Edit /etc/enviroment GTK_IM_MODULE = fcitx QT_IM_MODULE = fcitx XMODIFIERS = \"@im=fcitx\" Edit ~/.xprofile export GTK_IM_MODULE = fcitx export QT_IM_MODULE = fcitx export XMODIFIERS = \"@im=fcitx\" In System Settings -> Regional Settings -> Language change some setting Run im-config In System Settings , add fcitx to start-up routine Reboot In fcitx's configuration panel, add google-pinyin If you cannot toggle to traditional chinese, try ctrl+shift+F If there is error when starting fcitx, it is possibly an ibus related issue If fcitx still doesn't work, try run fcitx-diagnose install mkdocs for this website \u00b6 pip install mkdocs mkdocs-material mkdocs-macros-plugin pymdown-extensions install oh-my-zsh \u00b6 go to official page on github and follow its instructions configure themes \u00b6 Breeze, Breeze, Breeze... google cursor","title":"Kubuntu Installation Note"},{"location":"misc/kubuntu-installation-note/#kubuntu-installation-note","text":"Because I frequently mess up my operating system, plus I am so bad at debugging Linux issues, I usually just resort to reinstallation . So to minimize the time wasted, I make this note....","title":"Kubuntu Installation Note"},{"location":"misc/kubuntu-installation-note/#set-terminal-shortcut","text":"System Settings -> Shortcuts -> custom shortcut -> edit -> new .... action is \"konsole\" (lowercase)","title":"set terminal shortcut"},{"location":"misc/kubuntu-installation-note/#install-chrome","text":"Just do it","title":"install chrome"},{"location":"misc/kubuntu-installation-note/#set-chrome-as-default-browser","text":"update : the easy way: create a temporary html file, right click -> file extension setting -> change the priority Beside the one in System Setting, run: xdg-mime default google-chrome.desktop text/html Check ~/.config/mimeapps.list","title":"Set Chrome as default browser"},{"location":"misc/kubuntu-installation-note/#install-packages","text":"vim wget curl build-essential git zsh exfat-fuse exfat-utils tmux python3-pip sudo apt install vim wget curl build-essential git zsh exfat-fuse exfat-utils tmux python3-pip","title":"install packages"},{"location":"misc/kubuntu-installation-note/#dotfiles","text":".profile .tmux.conf .vimrc","title":"dotfiles"},{"location":"misc/kubuntu-installation-note/#generate-ssh-key-and-deploy","text":"ssh-keygen && ssh-copy-id b07902075@linux1.csie.org add ssh key to github","title":"generate ssh key and deploy"},{"location":"misc/kubuntu-installation-note/#clone-repo","text":"Just do it","title":"clone repo"},{"location":"misc/kubuntu-installation-note/#install-vscode","text":"extensions: material theme(dark), git lens","title":"install vscode"},{"location":"misc/kubuntu-installation-note/#install-chinese-pinyin-input-method-fcitx-google-pinyin","text":"Install required packages sudo apt install fcitx-bin fcitx-config-gtk2 fcitx-frontend-qt4 fcitx-frontend-qt5 fcitx-googlepinyin fcitx-imlist fcitx-module-dbus Edit /etc/enviroment GTK_IM_MODULE = fcitx QT_IM_MODULE = fcitx XMODIFIERS = \"@im=fcitx\" Edit ~/.xprofile export GTK_IM_MODULE = fcitx export QT_IM_MODULE = fcitx export XMODIFIERS = \"@im=fcitx\" In System Settings -> Regional Settings -> Language change some setting Run im-config In System Settings , add fcitx to start-up routine Reboot In fcitx's configuration panel, add google-pinyin If you cannot toggle to traditional chinese, try ctrl+shift+F If there is error when starting fcitx, it is possibly an ibus related issue If fcitx still doesn't work, try run fcitx-diagnose","title":"install chinese pinyin input method (fcitx + google-pinyin)"},{"location":"misc/kubuntu-installation-note/#install-mkdocs-for-this-website","text":"pip install mkdocs mkdocs-material mkdocs-macros-plugin pymdown-extensions","title":"install mkdocs for this website"},{"location":"misc/kubuntu-installation-note/#install-oh-my-zsh","text":"go to official page on github and follow its instructions","title":"install oh-my-zsh"},{"location":"misc/kubuntu-installation-note/#configure-themes","text":"Breeze, Breeze, Breeze... google cursor","title":"configure themes"}]}